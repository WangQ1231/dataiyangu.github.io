<!-- build time:Sat Apr 06 2019 08:14:31 GMT+0800 (China Standard Time) --><!DOCTYPE html><script src="/js/src/pjax/jquery_min_js.js"></script><script src="/js/src/pjax/jquery_pjax_min_js.js"></script><script src="/js/src/pjax/pjaxMain.js"></script><html class="theme-next muse use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222"><link rel="manifest" href="/images/favicon.ico"><meta name="msapplication-config" content="/images/favicon.ico"><meta name="keywords" content="高并发,"><link rel="alternate" href="/atom.xml" title="Leesin's Blog" type="application/atom+xml"><meta name="description" content="1. 各种同步控制工具的使用1.1. ReentrantLock在synchronize的基础上新加了功能，如果是特别简单的场景，两者是没有太大的区别的。1.1.1.可重入单线程可以重复进入，但要重复退出对于同一个线程，自己是可以重复进入的，否则会把自己卡死。结论：重入锁是可重复获得资源的锁，已经获得锁的线程可以对当前的资源重入加锁而不会引起阻塞；不可重入锁是不可重复获得资源的锁，当已经获得锁的线"><meta name="keywords" content="高并发"><meta property="og:type" content="article"><meta property="og:title" content="Java高并发程序设计学习笔记（五）：JDK并发包(各种同步控制工具的使用、并发容器及典型源码分析（Hashmap等）)"><meta property="og:url" content="http://mmmmmm.me/2019-01-31-3.html"><meta property="og:site_name" content="Leesin&#39;s Blog"><meta property="og:description" content="1. 各种同步控制工具的使用1.1. ReentrantLock在synchronize的基础上新加了功能，如果是特别简单的场景，两者是没有太大的区别的。1.1.1.可重入单线程可以重复进入，但要重复退出对于同一个线程，自己是可以重复进入的，否则会把自己卡死。结论：重入锁是可重复获得资源的锁，已经获得锁的线程可以对当前的资源重入加锁而不会引起阻塞；不可重入锁是不可重复获得资源的锁，当已经获得锁的线"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-03-12T12:16:32.777Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java高并发程序设计学习笔记（五）：JDK并发包(各种同步控制工具的使用、并发容器及典型源码分析（Hashmap等）)"><meta name="twitter:description" content="1. 各种同步控制工具的使用1.1. ReentrantLock在synchronize的基础上新加了功能，如果是特别简单的场景，两者是没有太大的区别的。1.1.1.可重入单线程可以重复进入，但要重复退出对于同一个线程，自己是可以重复进入的，否则会把自己卡死。结论：重入锁是可重复获得资源的锁，已经获得锁的线程可以对当前的资源重入加锁而不会引起阻塞；不可重入锁是不可重复获得资源的锁，当已经获得锁的线"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"hide",offset:12,b2t:!1,scrollpercent:!1,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"P88H67GUII",apiKey:"5489ac7ce78f59f4a8cb5445035f54d8",indexName:"dataiyangu",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://mmmmmm.me/2019-01-31-3.html"><title>Java高并发程序设计学习笔记（五）：JDK并发包(各种同步控制工具的使用、并发容器及典型源码分析（Hashmap等）) | Leesin's Blog</title></head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans"><link rel="stylesheet" href="/dist/APlayer.min.css"><div class="hover_sidebar"></div><header id="header_left" class="header_left" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header_left_inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu_left" class="menu_left"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-top"><a href="/top/" rel="section"><i class="menu-item-icon fa fa-fw fa-signal"></i><br>热度</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-message"><a href="/message/" rel="section"><i class="menu-item-icon fa fa-fw fa-heart"></i><br>留言</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="algolia-popup popup search-popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div></nav></div><div class="header_sidebar">黑匣子</div></header><div class="eye"><div class="eye1"><ul><li style="background-color:#C7EDCC">豆沙绿</li><li style="background-color:#FAF9DE">杏仁黄</li><li style="background-color:#FFF">银河白</li><li style="background-color:#323232">极光黑</li><li style="background-color:#FFF2E2">秋叶褐</li><li style="background-color:#FDE6E0">胭脂红</li><li style="background-color:#E3EDCD">青草绿</li><li style="background-color:#DCE2F1">海天蓝</li><li style="background-color:#E9EBFE">葛巾紫</li><li style="background-color:#EAEAEF">极光灰</li><li style="background-color:#cce8cf">qq管家</li></ul></div><div class="eye2">满天星</div></div><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><a href="https://github.com/dataiyangu?tab=repositories"><img style="position:absolute;top:0;left:0;border:0" alt="Fork me on GitHub" data-original="/images/github_fork.png"></a><div class="bg_content"><canvas id="canvas"></canvas></div><header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Leesin's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">To be a better me</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-top"><a href="/top/" rel="section"><i class="menu-item-icon fa fa-fw fa-signal"></i><br>热度</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-message"><a href="/message/" rel="section"><i class="menu-item-icon fa fa-fw fa-heart"></i><br>留言</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="algolia-popup popup search-popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div></nav></div></header><div id="pjax-container"><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article data-scroll-reveal="enter bottom move 80px over 1s after 0.0s" class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://mmmmmm.me/2019-01-31-3.html"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Leesin.Dong"><meta itemprop="description" content=""><meta itemprop="image" content="/images/header.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Leesin's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java高并发程序设计学习笔记（五）：JDK并发包(各种同步控制工具的使用、并发容器及典型源码分析（Hashmap等）)</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-18T19:20:04+08:00">2019-01-18 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span> </a></span>， <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Java高并发程序设计学习笔记/" itemprop="url" rel="index"><span itemprop="name">Java高并发程序设计学习笔记</span> </a></span></span><span id="/2019-01-31-3.html" class="leancloud_visitors" data-flag-title="Java高并发程序设计学习笔记（五）：JDK并发包(各种同步控制工具的使用、并发容器及典型源码分析（Hashmap等）)"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数&#58;</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i>Read the number <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>times</span><div class="post-wordcount"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">7.3k字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">35分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="1-各种同步控制工具的使用"><a href="#1-各种同步控制工具的使用" class="headerlink" title="1. 各种同步控制工具的使用"></a>1. 各种同步控制工具的使用</h1><h2 id="1-1-ReentrantLock"><a href="#1-1-ReentrantLock" class="headerlink" title="1.1. ReentrantLock"></a>1.1. ReentrantLock</h2><p>在synchronize的基础上新加了功能，如果是特别简单的场景，两者是没有太大的区别的。</p><h3 id="1-1-1-可重入"><a href="#1-1-1-可重入" class="headerlink" title="1.1.1.可重入"></a>1.1.1.可重入</h3><p>单线程可以重复进入，但要重复退出<br>对于同一个线程，自己是可以重复进入的，否则会把自己卡死。<br>结论：<br>重入锁是可重复获得资源的锁，已经获得锁的线程可以对当前的资源重入加锁而不会引起阻塞；不可重入锁是不可重复获得资源的锁，当已经获得锁的线程对当前资源再次加锁时，会把自己阻塞</p><p>广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。ReentrantLock和synchronized都是可重入锁，下面是一个用synchronized实现的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ReentrantTest</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    public synchronized <span class="keyword">void</span> get() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        set();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized <span class="keyword">void</span> set() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> run() &#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        ReentrantTest rt = <span class="keyword">new</span> ReentrantTest();</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(rt).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个过程没有发生死锁的情况，截取一部分输出结果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread<span class="number">-8492</span></span><br><span class="line">Thread<span class="number">-8492</span></span><br><span class="line">Thread<span class="number">-8494</span></span><br><span class="line">Thread<span class="number">-8494</span></span><br><span class="line">Thread<span class="number">-8495</span></span><br><span class="line">Thread<span class="number">-8495</span></span><br><span class="line">Thread<span class="number">-8493</span></span><br><span class="line">Thread<span class="number">-8493</span></span><br></pre></td></tr></table></figure><p>set()和get()同时输出了线程名称，表明即使递归使用synchronized也没有发生死锁，证明其是可重入的。</p><p>以上原文：<a href="https://blog.csdn.net/rickiyeat/article/details/78314451" target="_blank" rel="noopener">https://blog.csdn.net/rickiyeat/article/details/78314451</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	public <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	public <span class="keyword">static</span> int i = <span class="number">0</span>;</span><br><span class="line">	public <span class="keyword">void</span> run() &#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			lock.lock();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">//不论如何都进行unlock</span></span><br><span class="line">				<span class="comment">//加两次锁必须解锁两次。</span></span><br><span class="line">				lock.unlock();</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//synchronize只要在大括号外面，出了大括号，虚拟机会自动释放锁，可是lock是通过unlock来控制什么时候释放锁</span></span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">		Lock tl = <span class="keyword">new</span> Lock();</span><br><span class="line">		<span class="comment">//同时开两个一样的线程</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">		t1.start();t2.start();</span><br><span class="line">		t1.join();t2.join();</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20000</span></span><br></pre></td></tr></table></figure><h3 id="1-1-2-可中断-lockInterruptibly"><a href="#1-1-2-可中断-lockInterruptibly" class="headerlink" title="1.1.2. 可中断 lockInterruptibly()"></a>1.1.2. 可中断 lockInterruptibly()</h3><p>在发生死锁或者其他的导致长期等待的情况，希望锁停下来的功能，synchronize没有这个功能，ReentrantLock提供了可中断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Interruptible</span>  <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	public <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	public <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	int lock;</span><br><span class="line">	public Interruptible(int lock)&#123;</span><br><span class="line">		<span class="keyword">this</span>.lock = lock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">void</span> run() &#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">//lock=1的时候lock1上锁,lock=2的时候lock2上锁，刚才的lock1上了锁</span></span><br><span class="line">			<span class="comment">//之后还要给lock2上锁,lock2上了锁之后还要给lock1上锁，</span></span><br><span class="line">			<span class="comment">// 可是lock2在lock=2的时候被locl=2拿到了，lock1在lock=1的时候</span></span><br><span class="line">			<span class="comment">//被locl=1拿到了所以形成了死锁</span></span><br><span class="line">			<span class="keyword">if</span> (lock == <span class="number">1</span>)&#123;</span><br><span class="line">				lock1.lockInterruptibly();</span><br><span class="line">				<span class="keyword">try</span>&#123;</span><br><span class="line">					Thread.sleep(<span class="number">500</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				lock2.lockInterruptibly();</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				lock2.lockInterruptibly();</span><br><span class="line">				<span class="keyword">try</span>&#123;</span><br><span class="line">					Thread.sleep(<span class="number">500</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				lock1.lockInterruptibly();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">//如果lock1还拿着这把锁的话，就解掉。</span></span><br><span class="line">			<span class="keyword">if</span> (lock1.isHeldByCurrentThread())</span><br><span class="line">				lock1.unlock();</span><br><span class="line">			<span class="keyword">if</span> (lock2.isHeldByCurrentThread())</span><br><span class="line">				lock2.unlock();</span><br><span class="line">			System.out.println(Thread.currentThread().getId()+<span class="string">":线程退出"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">		Interruptible interruptible1 = <span class="keyword">new</span> Interruptible(<span class="number">1</span>);</span><br><span class="line">		Interruptible interruptible2 = <span class="keyword">new</span> Interruptible(<span class="number">2</span>);</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(interruptible1);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(interruptible2);</span><br><span class="line">		t1.start();t2.start();</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		DeadlockChecker.check();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DeadlockChecker.check();如果将这句话注释，将会进行无限期的死锁。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadInfo;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadMXBean;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DeadLockChecker</span> </span>&#123;</span><br><span class="line">	private final <span class="keyword">static</span> ThreadMXBean mbean = ManagementFactory.getThreadMXBean();</span><br><span class="line">	final  <span class="keyword">static</span>  Runnable deadLockCheck = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">		public <span class="keyword">void</span> run() &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				long [] deadLockedThreadIds = mbean.findDeadlockedThreads();</span><br><span class="line">				<span class="keyword">if</span> (deadLockedThreadIds != <span class="literal">null</span>) &#123;</span><br><span class="line">					ThreadInfo[] threadInfos = mbean.getThreadInfo(deadLockedThreadIds);</span><br><span class="line">					<span class="keyword">for</span> (Thread t : Thread.getAllStackTraces().keySet()) &#123;</span><br><span class="line">						<span class="keyword">for</span> (int i = <span class="number">0</span>; i&lt;threadInfos.length ; i++) &#123;</span><br><span class="line">							<span class="keyword">if</span> (t.getId() == threadInfos[i].getThreadId()) &#123;</span><br><span class="line">								t.interrupt();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span>&#123;</span><br><span class="line">					Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">				&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> check()&#123;</span><br><span class="line">		Thread t = <span class="keyword">new</span> Thread(deadLockCheck);</span><br><span class="line">		t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="1-1-3-可限时"><a href="#1-1-3-可限时" class="headerlink" title="1.1.3. 可限时"></a>1.1.3. 可限时</h3><p>超时不能获得锁，就返回false，不会永久等待构成死锁</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeLock</span> <span class="title">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	public <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">void</span> run() &#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">//如果线程在5秒之内没有拿到锁就走else里面的内容</span></span><br><span class="line">			<span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">				Thread.sleep(<span class="number">6000</span>);	</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"get lock failed"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">		TimeLock tl = <span class="keyword">new</span> TimeLock();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(t1);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-4-公平锁"><a href="#1-1-4-公平锁" class="headerlink" title="1.1.4. 公平锁"></a>1.1.4. 公平锁</h3><p>什么是公平锁？<br>先来先得，避免产生饥饿现象，但是性能差很多。所以不是特殊情况下，不要使用公平锁。<br>public ReentrantLock(boolean fair)<br>public static ReentrantLock fairLock = new ReentrantLock(true);</p><h2 id="1-2-Condition"><a href="#1-2-Condition" class="headerlink" title="1.2. Condition"></a>1.2. Condition</h2><h3 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1. 概述"></a>1.2.1. 概述</h3><p>类似于 Object.wait()和Object.notify() 与ReentrantLock结合使用</p><h3 id="1-2-2-主要接口"><a href="#1-2-2-主要接口" class="headerlink" title="1.2.2. 主要接口"></a>1.2.2. 主要接口</h3><p>void await() throws InterruptedException;//等待<br>void awaitUninterruptibly();<br>long awaitNanos(long nanosTimeout) throws InterruptedException; boolean await(long time, TimeUnit unit) throws InterruptedException; boolean awaitUntil(Date deadline) throws InterruptedException;<br>void signal();//通知继续往下走<br>void signalAll();</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ReenTerLockCondition</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	public <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	public <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">void</span> run() &#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			condition.await();</span><br><span class="line">			System.out.println(<span class="string">"Thread is going on "</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">		ReenTerLockCondition tl = <span class="keyword">new</span> ReenTerLockCondition();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">		t1.start();</span><br><span class="line">		Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		lock.lock();</span><br><span class="line">		condition.signal();</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//必须在lock和unlock执行完了之后才会到上面将t1的锁解开。</span></span><br><span class="line"><span class="comment">//类似于之前的Synchronize代码块。</span></span><br></pre></td></tr></table></figure><h3 id="1-2-3-API详解"><a href="#1-2-3-API详解" class="headerlink" title="1.2.3. API详解"></a>1.2.3. API详解</h3><p>await()方法会使当前线程等待，同时释放当前锁，当其他线程中使用signal()时或者signalAll()方法时，线<br>程会重新获得锁并继续执行。或者当线程被中断时，也能跳出等待。这和Object.wait()方法很相似。</p><p>awaitUninterruptibly()方法与await()方法基本相同，但是它并不会再等待过程中响应中断。不会被中断。<br>singal()方法用于唤醒一个在等待中的线程。相对的singalAll()方法会唤醒所有在等待中的线程。这和Obej ct.notify()方法很类似。</p><h2 id="1-3-Semaphore"><a href="#1-3-Semaphore" class="headerlink" title="1.3. Semaphore"></a>1.3. Semaphore</h2><p><strong><font color="red">信号量<br>互斥的、排他的<br>可以有多个线程去共享这个临界区，广义上的锁，比如每个信号量指定十个许可，每个许可分配若干个线程，当然每个线程也可以持有多个许可，如果有多余的许可就可以进入，如果没有许可，后面的线程就必须等待，不能进入。<br>信号量允许多个线程进入临界区，信号量的许可等于一的时候就相当于一把锁。</font></strong></p><h3 id="1-3-1-概述"><a href="#1-3-1-概述" class="headerlink" title="1.3.1. 概述"></a>1.3.1. 概述</h3><p>共享锁 运行多个线程同时临界区</p><h3 id="1-3-2-主要接口"><a href="#1-3-2-主要接口" class="headerlink" title="1.3.2. 主要接口"></a>1.3.2. 主要接口</h3><p>public void acquire()//获得信号量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> acquire() throws InterruptedException &#123;</span><br><span class="line">       sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//也可以拿到多个许可</span></span><br><span class="line">public <span class="keyword">void</span> acquire(int permits) throws InterruptedException &#123;</span><br><span class="line">       <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       sync.acquireSharedInterruptibly(permits);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>public void acquireUninterruptibly()//不支持中断的获得信号量<br>public boolean tryAcquire()//不会等待，只是试一试，拿不到就返回false<br>public boolean tryAcquire(long timeout, TimeUnit unit)//try的时间，等待的时间，和上线功能差差不多<br>public void release()释放。<br>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span>  <span class="title">SemapDemo</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	final Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">void</span> run() &#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="comment">//也可以semp.acquire(2);下面将会每两个线程输出一次</span></span><br><span class="line">			semp.acquire();</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			System.out.println(Thread.currentThread().getId()+<span class="string">":done!"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			semp.release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">		ExecutorService exec = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">		final SemapDemo demo = <span class="keyword">new</span> SemapDemo();</span><br><span class="line">		<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">			exec.submit(demo);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:done!</span><br><span class="line"><span class="number">19</span>:done!</span><br><span class="line"><span class="number">12</span>:done!</span><br><span class="line"><span class="number">10</span>:done!</span><br><span class="line"><span class="number">13</span>:done!</span><br><span class="line"><span class="number">14</span>:done!</span><br><span class="line"><span class="number">15</span>:done!</span><br><span class="line"><span class="number">18</span>:done!</span><br><span class="line"><span class="number">17</span>:done!</span><br><span class="line"><span class="number">16</span>:done!</span><br><span class="line"><span class="number">20</span>:done!</span><br><span class="line"><span class="number">22</span>:done!</span><br><span class="line"><span class="number">23</span>:done!</span><br><span class="line"><span class="number">21</span>:done!</span><br><span class="line"><span class="number">19</span>:done!</span><br><span class="line"><span class="number">25</span>:done!</span><br><span class="line"><span class="number">28</span>:done!</span><br><span class="line"><span class="number">24</span>:done!</span><br><span class="line"><span class="number">27</span>:done!</span><br><span class="line"><span class="number">26</span>:done!</span><br></pre></td></tr></table></figure><p>可以看到每五个线程输出一次，每次停留两秒，同样的如果semp.acquire(2);每个线程拿到两个许可，一共有五个许可，release（2），所以每次只有两个线程输出。</p><h2 id="1-4-ReadWriteLock"><a href="#1-4-ReadWriteLock" class="headerlink" title="1.4. ReadWriteLock"></a>1.4. ReadWriteLock</h2><p>写会修改数据，读不会修改数据，从性能上来看，如果不管读还是写都加锁，会十分影响性能，synchronized并行度只有一，一次只允许一个线程经过。如果没有写操作，这个所有的read线程必然是无等待的。</p><h3 id="1-4-1-概述"><a href="#1-4-1-概述" class="headerlink" title="1.4.1. 概述"></a>1.4.1. 概述</h3><p>ReadWriteLock是JDK5中提供的读写分离锁</p><h3 id="1-4-2-访问情况"><a href="#1-4-2-访问情况" class="headerlink" title="1.4.2. 访问情况"></a>1.4.2. 访问情况</h3><p>读-读不互斥:读读之间不阻塞。<br>读-写互斥:读阻塞写，写也会阻塞读。<br>写-写互斥:写写阻塞。<br><img alt="" data-original="../images/15488916638470.png"></p><h3 id="1-4-3-主要接口"><a href="#1-4-3-主要接口" class="headerlink" title="1.4.3. 主要接口"></a>1.4.3. 主要接口</h3><p>private static ReentrantReadWriteLock readWriteLock=newReentrantReadWriteLock();<br>private static Lock readLock = readWriteLock.readLock();<br>获得readLock，然后通过readLock.lock()惊醒操作<br>private static Lock writeLock = readWriteLock.writeLock();<br>获得readLock，然后通过readLock.lock()惊醒操作</p><h2 id="1-5-CountDownLatch"><a href="#1-5-CountDownLatch" class="headerlink" title="1.5. CountDownLatch"></a>1.5. CountDownLatch</h2><h3 id="1-5-1-概述"><a href="#1-5-1-概述" class="headerlink" title="1.5.1. 概述"></a>1.5.1. 概述</h3><p>倒数计时器 一种典型的场景就是火箭发射。在火箭发射前，为了保证万无一失，往往还要进行各项设备、仪器的检查。 只有等所有检查完毕后，引擎才能点火。这种场景就非常适合使用CountDownLatch。它可以使得点火线程 ，等待所有检查线程全部完工后，再执行</p><h3 id="1-5-2-主要接口"><a href="#1-5-2-主要接口" class="headerlink" title="1.5.2. 主要接口"></a>1.5.2. 主要接口</h3><p>static final CountDownLatch end = new CountDownLatch(10); //加入有十个检查项（十个线程）<br>end.countDown();//没通过一个就减一<br>end.await();//见到最后就返回，执行比如发射火箭的操作</p><h3 id="1-5-3-示意图"><a href="#1-5-3-示意图" class="headerlink" title="1.5.3. 示意图"></a>1.5.3. 示意图</h3><p><img alt="" data-original="../images/15488916716971.png"></p><p>主线程在这里等待，等到所有的检查任务都到达临界点之后，主线程就继续执行。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> final CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);<span class="comment">//开启十个线程来进行检查</span></span><br><span class="line">	<span class="keyword">static</span> final CountDownLatchDemo demo = <span class="keyword">new</span> CountDownLatchDemo();</span><br><span class="line">	public <span class="keyword">void</span> run() &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)*<span class="number">1000</span>);</span><br><span class="line">			System.out.println(<span class="string">"check complete"</span>);</span><br><span class="line">			end.countDown();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">		ExecutorService exec = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">			exec.submit(demo);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//等待检查</span></span><br><span class="line">		end.await();</span><br><span class="line">		<span class="comment">//发射火箭</span></span><br><span class="line">		System.out.println(<span class="string">"Fire"</span>);</span><br><span class="line">		exec.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">Fire</span><br></pre></td></tr></table></figure><h2 id="1-6-CyclicBarrier"><a href="#1-6-CyclicBarrier" class="headerlink" title="1.6. CyclicBarrier"></a>1.6. CyclicBarrier</h2><h3 id="1-6-1-概述"><a href="#1-6-1-概述" class="headerlink" title="1.6.1. 概述"></a>1.6.1. 概述</h3><p>循环栅栏 Cyclic意为循环，也就是说这个计数器可以反复使用。比如，假设我们将计数器设置为10。那么凑齐第一批1 0个线程后，计数器就会归零，然后接着凑齐下一批10个线程<br>它和CountDownLatch的区别是CountDownLatch的计数器只能有一次，而CyclicBarrier可以再重复利用。</p><h3 id="1-6-2-主要接口"><a href="#1-6-2-主要接口" class="headerlink" title="1.6.2. 主要接口"></a>1.6.2. 主要接口</h3><p>public CyclicBarrier(int parties（几个参与者相当于上一节中的10）, Runnable barrierAction（所有的线程到了之后，栅栏（系统）执行的动作）)<br>barrierAction就是当计数器一次计数完成后，系统会执行的动作<br>await() //都到了之后再往下执行</p><h3 id="1-6-3-示意图"><a href="#1-6-3-示意图" class="headerlink" title="1.6.3. 示意图"></a>1.6.3. 示意图</h3><p><img alt="" data-original="../images/15488917438815.png"></p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">	public <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		private <span class="built_in">String</span> soldier;</span><br><span class="line">		private final CyclicBarrier cyclic;</span><br><span class="line"></span><br><span class="line">		Soldier(CyclicBarrier cyclic,<span class="built_in">String</span> soldierName) &#123;</span><br><span class="line">			<span class="keyword">this</span>.soldier = soldierName;</span><br><span class="line">			<span class="keyword">this</span>.cyclic = cyclic;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public <span class="keyword">void</span> run() &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				cyclic.await();</span><br><span class="line">				doWork();</span><br><span class="line">				cyclic.await();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">void</span> doWork()&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="built_in">Math</span>.abs(<span class="keyword">new</span> Random().nextInt()%<span class="number">10000</span>));</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(soldier+<span class="string">":任务完成"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarrierRun</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		boolean flag;</span><br><span class="line">		int N;</span><br><span class="line"></span><br><span class="line">		public BarrierRun(boolean flag, int N) &#123;</span><br><span class="line">			<span class="keyword">this</span>.flag = flag;</span><br><span class="line">			<span class="keyword">this</span>.N = N;</span><br><span class="line">		&#125;</span><br><span class="line">		public <span class="keyword">void</span> run() &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">				System.out.println(<span class="string">"司令:[士兵"</span>+N+<span class="string">"个，任务完成！]"</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"司令:[士兵"</span>+N+<span class="string">"个，集合完毕！]"</span>);</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">		final int N = <span class="number">10</span>;</span><br><span class="line">		Thread[] allSoldier = <span class="keyword">new</span> Thread[N];</span><br><span class="line">		boolean flag = <span class="literal">false</span>;</span><br><span class="line">		CyclicBarrier cyclic = <span class="keyword">new</span> CyclicBarrier(N, <span class="keyword">new</span> BarrierRun(flag, N));</span><br><span class="line">		System.out.println(<span class="string">"集合队伍!"</span>);</span><br><span class="line">		<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;N ; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"士兵"</span>+i+<span class="string">"报道！"</span>);</span><br><span class="line">			allSoldier[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Soldier(cyclic, <span class="string">"士兵"</span> + i));</span><br><span class="line">			allSoldier[i].start();</span><br><span class="line"><span class="comment">//			if (i == 5) &#123;</span></span><br><span class="line"><span class="comment">//				allSoldier[0].interrupt();</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">集合队伍！</span><br><span class="line">士兵<span class="number">0</span>报道</span><br><span class="line">士兵<span class="number">1</span>报道</span><br><span class="line">士兵<span class="number">2</span>报道</span><br><span class="line">士兵<span class="number">3</span>报道</span><br><span class="line">士兵<span class="number">4</span>报道</span><br><span class="line">士兵<span class="number">5</span>报道</span><br><span class="line">士兵<span class="number">6</span>报道</span><br><span class="line">士兵<span class="number">7</span>报道</span><br><span class="line">士兵<span class="number">8</span>报道</span><br><span class="line">士兵<span class="number">9</span>报道</span><br><span class="line">司令[士兵<span class="number">10</span>个，集合完毕！]</span><br><span class="line">士兵<span class="number">2</span>：任务完成</span><br><span class="line">士兵<span class="number">7</span>：任务完成</span><br><span class="line">士兵<span class="number">0</span>：任务完成</span><br><span class="line">士兵<span class="number">4</span>：任务完成</span><br><span class="line">士兵<span class="number">3</span>：任务完成</span><br><span class="line">士兵<span class="number">9</span>：任务完成</span><br><span class="line">士兵<span class="number">6</span>：任务完成</span><br><span class="line">士兵<span class="number">8</span>：任务完成</span><br><span class="line">士兵<span class="number">1</span>：任务完成</span><br><span class="line">士兵<span class="number">5</span>：任务完成</span><br><span class="line">司令：[士兵<span class="number">10</span>个，任务完成！]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//			if (i == 5) &#123;</span></span><br><span class="line"><span class="comment">//				allSoldier[0].interrupt();</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br></pre></td></tr></table></figure><p>将这个注释打开的话<br><img alt="" data-original="../images/15488919151578.png"></p><p>第零个终端之后，将会抛出InterruptedException异常，剩下的九个线程将会抛出BrokenBarrierException异常。</p><h2 id="1-7-LockSupport"><a href="#1-7-LockSupport" class="headerlink" title="1.7. LockSupport"></a>1.7. LockSupport</h2><h3 id="1-7-1-概述"><a href="#1-7-1-概述" class="headerlink" title="1.7.1. 概述"></a>1.7.1. 概述</h3><p>比较偏底层。<br>提供线程阻塞原语<br>挂起</p><h3 id="1-7-2-主要接口"><a href="#1-7-2-主要接口" class="headerlink" title="1.7.2. 主要接口"></a>1.7.2. 主要接口</h3><p>LockSupport.park(); //停下来、挂起，将线程挂起，除非许可是可用的。<br>LockSupport.unpark(t1);//将t1继续执行，使得许可是可用的</p><h3 id="1-7-3-与suspend-比较"><a href="#1-7-3-与suspend-比较" class="headerlink" title="1.7.3. 与suspend()比较"></a>1.7.3. 与suspend()比较</h3><p>LockSupport不容易引起线程冻结，suspend将来可能会被废弃。<br>有点类似于信号量中的许可，如果unpark发生在park之前，park并不会将线程阻塞住。<br>如果rewiew发生在suspend之前，suspend就不能再继续执行了，永久挂起。</p><h3 id="1-7-4-中断响应"><a href="#1-7-4-中断响应" class="headerlink" title="1.7.4. 中断响应"></a>1.7.4. 中断响应</h3><p>wait等是能够try catch 终端异常的，但是park是没有捕获这个异常的，所以：<br>能够响应中断，但不抛出异常。<br>中断响应的结果是，park()函数的返回，可以从Thread.interrupted()得到中断标志</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">	public <span class="keyword">static</span> <span class="built_in">Object</span> u = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	<span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t1"</span>);</span><br><span class="line">	<span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">		public ChangeObjectThread(<span class="built_in">String</span> name) &#123;</span><br><span class="line">			<span class="keyword">super</span>.setName(name);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public <span class="keyword">void</span> run() &#123;</span><br><span class="line">			synchronized (u)&#123;</span><br><span class="line">				System.out.println(<span class="string">"in"</span>+getName());</span><br><span class="line">				LockSupport.park();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">		t1.start();</span><br><span class="line">		Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		t2.start();</span><br><span class="line">		LockSupport.unpark(t1);</span><br><span class="line">		LockSupport.unpark(t2);</span><br><span class="line">		t1.join();</span><br><span class="line">		t2.join();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int <span class="number">1</span> </span><br><span class="line">int <span class="number">2</span></span><br></pre></td></tr></table></figure><p></p><p>不论unpark在park的前面还是后面都不会阻塞。</p><h2 id="1-8-ReentrantLock-的实现"><a href="#1-8-ReentrantLock-的实现" class="headerlink" title="1.8. ReentrantLock 的实现"></a>1.8. ReentrantLock 的实现</h2><h3 id="1-8-1-CAS状态"><a href="#1-8-1-CAS状态" class="headerlink" title="1.8.1. CAS状态"></a>1.8.1. CAS状态</h3><p>锁到底有没有被人占用，通过是否到达期望值，通过值是否改变来判断是否应该拿到锁。</p><h3 id="1-8-2-等待队列"><a href="#1-8-2-等待队列" class="headerlink" title="1.8.2. 等待队列"></a>1.8.2. 等待队列</h3><p>如果没有拿到锁，线程应该怎么办呢，应该进入等待的队列，如果有多个线程进来，多个线程在队列中进行等待。</p><h3 id="1-8-3-park"><a href="#1-8-3-park" class="headerlink" title="1.8.3. park()"></a>1.8.3. park()</h3><p>在队列中的线程都进行park操作。unlock的时候，从等待的队列中挑出一个出来进行unpark操作。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">         * acquire on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        final <span class="keyword">void</span> lock() &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))<span class="comment">//期望值是0，更新成1</span></span><br><span class="line">            <span class="comment">//如果成功了，便能拿到锁，就能继续往下走。</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则就尝试去做申请。</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">     public final <span class="keyword">void</span> acquire(int arg) &#123;</span><br><span class="line">     <span class="comment">//在尝试一下，万一别人释放了呢？</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果尝试了还是不行就把自己放到等待队列中去</span></span><br><span class="line">      private Node addWaiter(Node mode) &#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">//放到队列的尾巴上去。</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//返回的node然后再去尝试请求锁</span></span><br><span class="line">    final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean failed = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            boolean interrupted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">//如果确实是拿不到就会在这里挂起，下面会有详细</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过park进行挂起</span></span><br><span class="line"> private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//unlock操作</span></span><br><span class="line"> public <span class="keyword">void</span> unlock() &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">  *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    public final boolean release(int arg) &#123;</span></span><br><span class="line"><span class="regexp">        if (tryRelease(arg)) &#123;</span></span><br><span class="line"><span class="regexp">            Node h = head;</span></span><br><span class="line"><span class="regexp">            if (h != null &amp;&amp; h.waitStatus != 0)</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/将队列头部的node进行unpark操作</span></span><br><span class="line"><span class="regexp">                unparkSuccessor(h);</span></span><br><span class="line"><span class="regexp">            return true;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        return false;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">private void unparkSuccessor(Node node) &#123;</span></span><br><span class="line"><span class="regexp">        /</span>*</span><br><span class="line">         * If status is negative (i.e., possibly needing signal) <span class="keyword">try</span></span><br><span class="line">         * to clear <span class="keyword">in</span> anticipation <span class="keyword">of</span> signalling.  It is OK <span class="keyword">if</span> <span class="keyword">this</span></span><br><span class="line">         * fails or <span class="keyword">if</span> status is changed by waiting thread.</span><br><span class="line">         *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        int ws = node.waitStatus;</span></span><br><span class="line"><span class="regexp">        if (ws &lt; 0)</span></span><br><span class="line"><span class="regexp">            compareAndSetWaitStatus(node, ws, 0);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        /</span>*</span><br><span class="line">         * Thread to unpark is held <span class="keyword">in</span> successor, which is normally</span><br><span class="line">         * just the next node.  But <span class="keyword">if</span> cancelled or apparently <span class="literal">null</span>,</span><br><span class="line">         * traverse backwards <span class="keyword">from</span> tail to find the actual</span><br><span class="line">         * non-cancelled successor.</span><br><span class="line">         *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        Node s = node.next;</span></span><br><span class="line"><span class="regexp">        if (s == null || s.waitStatus &gt; 0) &#123;</span></span><br><span class="line"><span class="regexp">            s = null;</span></span><br><span class="line"><span class="regexp">            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span></span><br><span class="line"><span class="regexp">                if (t.waitStatus &lt;= 0)</span></span><br><span class="line"><span class="regexp">                    s = t;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        if (s != null)</span></span><br><span class="line"><span class="regexp">            LockSupport.unpark(s.thread);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br></pre></td></tr></table></figure><h1 id="2-并发容器及典型源码分析"><a href="#2-并发容器及典型源码分析" class="headerlink" title="2. 并发容器及典型源码分析"></a>2. 并发容器及典型源码分析</h1><h2 id="2-1-集合包装"><a href="#2-1-集合包装" class="headerlink" title="2.1. 集合包装"></a>2.1. 集合包装</h2><h3 id="2-1-1-HashMap"><a href="#2-1-1-HashMap" class="headerlink" title="2.1.1. HashMap"></a>2.1.1. HashMap</h3><p>HashMap不是一个线程安全的容器，可以通过如下的方法变成线程安全的，但是只适用于并发量比较小的情况。<br>Collections.synchronizedMap<br><img alt="" data-original="../images/15488921053227.png"></p><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        private <span class="keyword">static</span> final long serialVersionUID = <span class="number">1978198479659022715</span>L;</span><br><span class="line"></span><br><span class="line">        private final <span class="built_in">Map</span>&lt;K,V&gt; m;     <span class="comment">// Backing Map</span></span><br><span class="line">        final <span class="built_in">Object</span>      mutex;        <span class="comment">// Object on which to synchronize</span></span><br><span class="line"></span><br><span class="line">        SynchronizedMap(<span class="built_in">Map</span>&lt;K,V&gt; m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">this</span>.m = m;</span><br><span class="line">            mutex = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SynchronizedMap(<span class="built_in">Map</span>&lt;K,V&gt; m, <span class="built_in">Object</span> mutex) &#123;</span><br><span class="line">            <span class="keyword">this</span>.m = m;</span><br><span class="line">            <span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int size() &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.size();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean isEmpty() &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.isEmpty();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean containsKey(<span class="built_in">Object</span> key) &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.containsKey(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean containsValue(<span class="built_in">Object</span> value) &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.containsValue(value);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public V get(<span class="built_in">Object</span> key) &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.get(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public V put(K key, V value) &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public V remove(<span class="built_in">Object</span> key) &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.remove(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public <span class="keyword">void</span> putAll(<span class="built_in">Map</span>&lt;? extends K, ? extends V&gt; map) &#123;</span><br><span class="line">            synchronized (mutex) &#123;m.putAll(map);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public <span class="keyword">void</span> clear() &#123;</span><br><span class="line">            synchronized (mutex) &#123;m.clear();&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private transient <span class="built_in">Set</span>&lt;K&gt; keySet = <span class="literal">null</span>;</span><br><span class="line">        private transient <span class="built_in">Set</span>&lt;<span class="built_in">Map</span>.Entry&lt;K,V&gt;&gt; entrySet = <span class="literal">null</span>;</span><br><span class="line">        private transient Collection&lt;V&gt; values = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        public <span class="built_in">Set</span>&lt;K&gt; keySet() &#123;</span><br><span class="line">            synchronized (mutex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (keySet==<span class="literal">null</span>)</span><br><span class="line">                    keySet = <span class="keyword">new</span> SynchronizedSet&lt;&gt;(m.keySet(), mutex);</span><br><span class="line">                <span class="keyword">return</span> keySet;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public <span class="built_in">Set</span>&lt;<span class="built_in">Map</span>.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">            synchronized (mutex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entrySet==<span class="literal">null</span>)</span><br><span class="line">                    entrySet = <span class="keyword">new</span> SynchronizedSet&lt;&gt;(m.entrySet(), mutex);</span><br><span class="line">                <span class="keyword">return</span> entrySet;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Collection&lt;V&gt; values() &#123;</span><br><span class="line">            synchronized (mutex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (values==<span class="literal">null</span>)</span><br><span class="line">                    values = <span class="keyword">new</span> SynchronizedCollection&lt;&gt;(m.values(), mutex);</span><br><span class="line">                <span class="keyword">return</span> values;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean equals(<span class="built_in">Object</span> o) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.equals(o);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public int hashCode() &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.hashCode();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public <span class="built_in">String</span> toString() &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.toString();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        private <span class="keyword">void</span> writeObject(ObjectOutputStream s) throws IOException &#123;</span><br><span class="line">            synchronized (mutex) &#123;s.defaultWriteObject();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过观察分析，是将map封装到了synchronizeMap中，并且，将get put 等操作都放在了Synchronize代码块中，下面的List和Set同理，因为是放在了synchronize代码块中所以是串行的不是并行的，只能适用于并发量比较小的场景。</p><h3 id="2-1-2-List"><a href="#2-1-2-List" class="headerlink" title="2.1.2. List"></a>2.1.2. List</h3><p>synchronizedList</p><h3 id="2-1-3-Set"><a href="#2-1-3-Set" class="headerlink" title="2.1.3. Set"></a>2.1.3. Set</h3><p>synchronizedSet</p><h2 id="2-2-ConcurrentHashMap"><a href="#2-2-ConcurrentHashMap" class="headerlink" title="2.2. ConcurrentHashMap"></a>2.2. ConcurrentHashMap</h2><p>高性能HashMap（解决synchronize只适用于并发量小的场景）</p><h3 id="2-2-1HashMap源码分析"><a href="#2-2-1HashMap源码分析" class="headerlink" title="2.2.1HashMap源码分析"></a>2.2.1HashMap源码分析</h3><p>HashMap内部是一个数组<br>拿put方法来看<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        int hash = hash(key);</span><br><span class="line">        int i = indexFor(hash, table.length);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="built_in">Object</span> k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入inflateTable方法</span></span><br><span class="line">  private <span class="keyword">void</span> inflateTable(int toSize) &#123;</span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">        int capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">        threshold = (int) <span class="built_in">Math</span>.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看到是将疏浚存到了table中</span></span><br><span class="line">    transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line">    <span class="comment">//每一个table中是entry表象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//每个entry里面是key value next hash</span></span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        int hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates new entry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final K getKey() &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final V getValue() &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final boolean equals(<span class="built_in">Object</span> o) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> <span class="built_in">Map</span>.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">Map</span>.Entry e = (<span class="built_in">Map</span>.Entry)o;</span><br><span class="line">            <span class="built_in">Object</span> k1 = getKey();</span><br><span class="line">            <span class="built_in">Object</span> k2 = e.getKey();</span><br><span class="line">            <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="literal">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">                <span class="built_in">Object</span> v1 = getValue();</span><br><span class="line">                <span class="built_in">Object</span> v2 = e.getValue();</span><br><span class="line">                <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="literal">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final int hashCode() &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final <span class="built_in">String</span> toString() &#123;</span><br><span class="line">            <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is invoked whenever the value in an entry is</span></span><br><span class="line"><span class="comment">         * overwritten by an invocation of put(k,v) for a key k that's already</span></span><br><span class="line"><span class="comment">         * in the HashMap.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> recordAccess(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is invoked whenever the entry is</span></span><br><span class="line"><span class="comment">         * removed from the table.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> recordRemoval(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><p><img alt="" data-original="../images/15488919681106.png"></p><p>get（key）是通过哈希算法来判断应该映射到哪个槽位的<br>两个不同的key比如，key1 key2可能被映射到同一个槽位中，这里叫做哈希冲突<br>一种解决方法是，既然你映射到了同一个槽位中，我就把你方法同一个槽位中，可是在一个entry的数组中如何放两个entry呢？？通过entry中的next指向下一个entry</p><p>事实上HashMap的内部主要实现是数组，数组中放着entry，每个entry都是链表中的一环，链表的头部，当发生大量的hash冲突的时候蜕化成一个链表。</p><p>一般情况下HashMap不会放满，因为放满之后必然产生冲突，所以一般HashMap需要预留空间</p><h3 id="2-2-2-ConcurrentHashMap源码分析"><a href="#2-2-2-ConcurrentHashMap源码分析" class="headerlink" title="2.2.2. ConcurrentHashMap源码分析"></a>2.2.2. ConcurrentHashMap源码分析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">       Segment&lt;K,V&gt; s;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       int hash = hash(key);</span><br><span class="line">       int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">       <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">           s = ensureSegment(j);</span><br><span class="line">       <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Segment 段<br>如果大量线程进来，会一起竞争HashMap的赋值操作<br>把大的HashMap切割成若干个小的HashMap，每个线程进来的时候，先把当前的key映射到其中的一个小HashMap中去，在小HashMap中做一个普通HashMap应该做的事情，假如大的HashMap中有十六个小的HashMap，意味着大的HashMap可以同时接受十六个线程的赋值操作，相比于之前只有一个HasnMap，性能提高了十六倍。</p><p>这里的Segment就是上面说的小HashMap，通过移位操作拿到当前的偏移量如果不存在就创建一个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</span><br><span class="line">       final Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">       long u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">       Segment&lt;K,V&gt; seg;</span><br><span class="line">       <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="literal">null</span>) &#123;</span><br><span class="line">           Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">           int cap = proto.table.length;</span><br><span class="line">           float lf = proto.loadFactor;</span><br><span class="line">           int threshold = (int)(cap * lf);</span><br><span class="line">           HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">           <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">               == <span class="literal">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">               Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">               <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                      == <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="literal">null</span>, seg = s))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> seg;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>将第零个Segment作为原型将第k个Segment设置出来。</p><p><strong><font color="red">注意这里的put虽然是线程安全的但是并没有使用锁。<br></font></strong><br>上面的s.put():</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line"> <span class="comment">//这里的tryLock还是一个CAS操作tryLock不会等待，Lock才会等待</span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">            <span class="comment">//如果trylock失败，代码在线面详细解释这个函数</span></span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                int index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                槽位映射到index上，拿出index中的第一个</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="comment">//尝试将first插到entry中</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                <span class="comment">//如果有hash冲突</span></span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//有Hash冲突就将value串起来</span></span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果没有hash冲突</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        int c = count + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//就将entry set到数组中去</span></span><br><span class="line">                            setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">            HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">            HashEntry&lt;K,V&gt; node = <span class="literal">null</span>;</span><br><span class="line">            int retries = <span class="number">-1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">            <span class="comment">//不断的trylock</span></span><br><span class="line">            <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">                <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        e = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果trylock超过了一定的次数，就会挂起</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">                    lock();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                <span class="comment">//这里可能是hash进行了扩容重hash等操作，将retrues复制为-1，</span></span><br><span class="line">                <span class="comment">//再不断的进行trylock</span></span><br><span class="line">                         (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">                    e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">                    retries = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red">这里的不断的trylock，如果到达一定的次数在挂起，是concurrentHashMap的核心优化</font></strong><br>但是注意在concurrentHashMap中有一个size操作中的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">        final Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        int size;</span><br><span class="line">        boolean overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">        long sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">        long last = <span class="number">0</span>L;   <span class="comment">// previous sum</span></span><br><span class="line">        int retries = <span class="number">-1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">                &#125;</span><br><span class="line">                sum = <span class="number">0</span>L;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                overflow = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        sum += seg.modCount;</span><br><span class="line">                        int c = seg.count;</span><br><span class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                            overflow = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum == last)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                last = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的代码中重复进行了lock和unlock，因为在想要得到map的size的时候是不能够再进行修改的，所以加上锁，这里可能会有性能问题，可是size操作用的并不是很频繁，所以可以忽略。</p><p>rehash操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在put操作中</span></span><br><span class="line"><span class="comment">//如果大于了hash的阈值，就会进行rehash</span></span><br><span class="line"><span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Doubles size of table and repacks entries, also adding the</span></span><br><span class="line"><span class="comment">         * given node to new table</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> private <span class="keyword">void</span> rehash(HashEntry&lt;K,V&gt; node) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">            int oldCapacity = oldTable.length;</span><br><span class="line">            int newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">            HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">                (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">            int sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    int idx = e.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="literal">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                        newTable[idx] = e;</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                        HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                        int lastIdx = idx;</span><br><span class="line">                        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                             last != <span class="literal">null</span>;</span><br><span class="line">                             last = last.next) &#123;</span><br><span class="line">                            int k = last.hash &amp; sizeMask;</span><br><span class="line">                            <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                                lastIdx = k;</span><br><span class="line">                                lastRun = last;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        newTable[lastIdx] = lastRun;</span><br><span class="line">                        <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            V v = p.value;</span><br><span class="line">                            int h = p.hash;</span><br><span class="line">                            int k = h &amp; sizeMask;</span><br><span class="line">                            HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                            newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">            node.setNext(newTable[nodeIndex]);</span><br><span class="line">            newTable[nodeIndex] = node;</span><br><span class="line">            table = newTable;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>rehash会将空间容量翻倍，将node放进去，是一个比较耗时的操作，做了一点油画，尽量重用现有的元素，不去新建元素，也就是说在翻倍前和翻倍后，同一个元素，很可能在用一个位置</p><h2 id="2-3-BlockingQueue"><a href="#2-3-BlockingQueue" class="headerlink" title="2.3. BlockingQueue"></a>2.3. BlockingQueue</h2><p>阻塞队列</p><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。<br><img alt="" data-original="../images/15488919944790.png"></p><p>以上两段内容转自：<a href="http://ifeve.com/java-blocking-queue/" target="_blank" rel="noopener">http://ifeve.com/java-blocking-queue/</a><br><img alt="" data-original="../images/15488920002086.png"></p><p>是一个接口，不是一个实际的类，是一个并发容器，但不是一个高性能的并发容器，和concurrentHashMap（高性能）不一样，但它本身的好处是在多个线程共享数据的容器</p><p>如上图，如果队列为空，还试图往队列里面读数据，读的线程就会等待，等待有其他的线程往里面写数据的时候，才会唤醒，并且去拿到数据。如果队列已经满了，还想往队列中存数据，写的线程就会等待，等有人将数据拿掉之后才会写进去。</p><p>所以会引起线程的阻塞。</p><h3 id="ArrayBlockingQueue源码"><a href="#ArrayBlockingQueue源码" class="headerlink" title="ArrayBlockingQueue源码"></a>ArrayBlockingQueue源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Main lock guarding all access */</span></span><br><span class="line">    final ReentrantLock lock;<span class="comment">//保证线程安全</span></span><br><span class="line">    <span class="comment">/** Condition for waiting takes */</span></span><br><span class="line">    private final Condition notEmpty;<span class="comment">//提示读操作不为空</span></span><br><span class="line">    <span class="comment">/** Condition for waiting puts */</span></span><br><span class="line">    private final Condition notFull;<span class="comment">//提示写操作不为满</span></span><br><span class="line"></span><br><span class="line"> public <span class="keyword">void</span> put(E e) throws InterruptedException &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        final ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">//put操作直接加锁，所以是比较耗性能的。</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            <span class="comment">//如果是满的会进行等待，直到下面的take操作</span></span><br><span class="line">                notFull.await();</span><br><span class="line">            insert(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">        final ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//这里是为了读操作</span></span><br><span class="line">                notEmpty.await();</span><br><span class="line">                <span class="comment">//去掉写操作的锁，具体代码往下看</span></span><br><span class="line">            <span class="keyword">return</span> extract();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> private E extract() &#123;</span><br><span class="line">        final <span class="built_in">Object</span>[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        E x = <span class="keyword">this</span>.&lt;E&gt;cast(items[takeIndex]);</span><br><span class="line">        items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">        takeIndex = inc(takeIndex);</span><br><span class="line">        --count;</span><br><span class="line">        <span class="comment">//在这里讲锁打开</span></span><br><span class="line">        notFull.signal();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-ConcurrentLinkedQueue"><a href="#2-4-ConcurrentLinkedQueue" class="headerlink" title="2.4. ConcurrentLinkedQueue"></a>2.4. ConcurrentLinkedQueue</h2><p>高性能的链表队列，处理类似于concurrentHashMap，内部使用大量的无锁的算法。</p></div><div><div><div style="text-align:center;color:#555;font-size:14px">-------------The End-------------</div></div></div><div><div class="my_post_copyright"><p><span>本文标题:</span><a href="/2019-01-31-3.html">Java高并发程序设计学习笔记（五）：JDK并发包(各种同步控制工具的使用、并发容器及典型源码分析（Hashmap等）)</a></p><p><span>文章作者:</span><a href="/" title="访问 Leesin.Dong 的个人博客">Leesin.Dong</a></p><p><span>发布时间:</span>2019年01月18日 - 19:01</p><p><span>最后更新:</span>2019年03月12日 - 20:03</p><p><span>原始链接:</span><a href="/2019-01-31-3.html" title="Java高并发程序设计学习笔记（五）：JDK并发包(各种同步控制工具的使用、并发容器及典型源码分析（Hashmap等）)">http://mmmmmm.me/2019-01-31-3.html</a></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>客官客官，不可以，你要对我负责～～～</div><button id="rewardButton" disable="enable"><script>window.onload=function(){var n=document.getElementById("QR"),e=document.getElementById("rewardButton");e.onclick=function(){"none"===n.style.display?n.style.display="block":n.style.display="none"}}</script><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" alt="Leesin.Dong 微信支付" data-original="/images/wechatpay.jpg"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" alt="Leesin.Dong 支付宝" data-original="/images/alipay.jpg"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/高并发/" rel="tag"><i class="fa fa-tag"></i> 高并发</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019-01-31-2.html" rel="next" title="Java高并发程序设计学习笔记（四）：无锁"><i class="fa fa-chevron-left"></i> Java高并发程序设计学习笔记（四）：无锁</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019-02-07.html" rel="prev" title="hexo next主题深度优化(十一)，next主题中加入scrollReveal.js，让文章随着鼠标的滚动，出现点小动作。">hexo next主题深度优化(十一)，next主题中加入scrollReveal.js，让文章随着鼠标的滚动，出现点小动作。 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div id="gitalk-container"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Leesin.Dong" data-original="/images/header.jpg"><p class="site-author-name" itemprop="name">Leesin.Dong</p><p class="site-description motion-element" itemprop="description">To be a better me</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">58</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">14</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">11</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/dataiyangu" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/dataiyangu" target="_blank" title="CSDN"><i class="fa fa-fw fa-copyright"></i>CSDN</a> </span><span class="links-of-author-item"><a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=32248827@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-E-Mail"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://mobile.twitter.com/dataiyangu" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i>Twitter</a> </span><span class="links-of-author-item"><a href="https://www.facebook.com/leesin.dong.923" target="_blank" title="FB Page"><i class="fa fa-fw fa-facebook"></i>FB Page</a> </span><span class="links-of-author-item"><a href="http://wpa.qq.com/msgrd?v=3&uin=32248827&site=hupaiyule&menu=yes" target="_blank" title="QQ"><i class="fa fa-fw fa-qq"></i>QQ</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> link</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://blog.csdn.net/dataiyangu" title="我的CSDN" target="_blank">我的CSDN</a></li><li class="links-of-blogroll-item"><a href="https://yelog.org" title="叶落阁" target="_blank">叶落阁</a></li><li class="links-of-blogroll-item"><a href="http://www.bianxiaofeng.com" title="边小丰" target="_blank">边小丰</a></li><li class="links-of-blogroll-item"><a href="https://qqdie.com" title="QQ爹" target="_blank">QQ爹</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-各种同步控制工具的使用"><span class="nav-number">1.</span> <span class="nav-text">1. 各种同步控制工具的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-ReentrantLock"><span class="nav-number">1.1.</span> <span class="nav-text">1.1. ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-可重入"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1.可重入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-可中断-lockInterruptibly"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2. 可中断 lockInterruptibly()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-可限时"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.1.3. 可限时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-4-公平锁"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.1.4. 公平锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Condition"><span class="nav-number">1.2.</span> <span class="nav-text">1.2. Condition</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-概述"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1. 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-主要接口"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2. 主要接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-API详解"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3. API详解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Semaphore"><span class="nav-number">1.3.</span> <span class="nav-text">1.3. Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-概述"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1. 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-主要接口"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2. 主要接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-ReadWriteLock"><span class="nav-number">1.4.</span> <span class="nav-text">1.4. ReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-概述"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1. 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-访问情况"><span class="nav-number">1.4.2.</span> <span class="nav-text">1.4.2. 访问情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-3-主要接口"><span class="nav-number">1.4.3.</span> <span class="nav-text">1.4.3. 主要接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-CountDownLatch"><span class="nav-number">1.5.</span> <span class="nav-text">1.5. CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-概述"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.5.1. 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-主要接口"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.5.2. 主要接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-3-示意图"><span class="nav-number">1.5.3.</span> <span class="nav-text">1.5.3. 示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">1.5.4.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-CyclicBarrier"><span class="nav-number">1.6.</span> <span class="nav-text">1.6. CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-概述"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.6.1. 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-主要接口"><span class="nav-number">1.6.2.</span> <span class="nav-text">1.6.2. 主要接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-3-示意图"><span class="nav-number">1.6.3.</span> <span class="nav-text">1.6.3. 示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例子-1"><span class="nav-number">1.6.4.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-LockSupport"><span class="nav-number">1.7.</span> <span class="nav-text">1.7. LockSupport</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-1-概述"><span class="nav-number">1.7.1.</span> <span class="nav-text">1.7.1. 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-2-主要接口"><span class="nav-number">1.7.2.</span> <span class="nav-text">1.7.2. 主要接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-3-与suspend-比较"><span class="nav-number">1.7.3.</span> <span class="nav-text">1.7.3. 与suspend()比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-4-中断响应"><span class="nav-number">1.7.4.</span> <span class="nav-text">1.7.4. 中断响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例子-2"><span class="nav-number">1.7.5.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-ReentrantLock-的实现"><span class="nav-number">1.8.</span> <span class="nav-text">1.8. ReentrantLock 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-1-CAS状态"><span class="nav-number">1.8.1.</span> <span class="nav-text">1.8.1. CAS状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-2-等待队列"><span class="nav-number">1.8.2.</span> <span class="nav-text">1.8.2. 等待队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-3-park"><span class="nav-number">1.8.3.</span> <span class="nav-text">1.8.3. park()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码"><span class="nav-number">1.8.4.</span> <span class="nav-text">源码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-并发容器及典型源码分析"><span class="nav-number">2.</span> <span class="nav-text">2. 并发容器及典型源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-集合包装"><span class="nav-number">2.1.</span> <span class="nav-text">2.1. 集合包装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-HashMap"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1. HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码-1"><span class="nav-number">2.1.2.</span> <span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-List"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.2. List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-Set"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.3. Set</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-ConcurrentHashMap"><span class="nav-number">2.2.</span> <span class="nav-text">2.2. ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1HashMap源码分析"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1HashMap源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-ConcurrentHashMap源码分析"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2. ConcurrentHashMap源码分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-BlockingQueue"><span class="nav-number">2.3.</span> <span class="nav-text">2.3. BlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayBlockingQueue源码"><span class="nav-number">2.3.1.</span> <span class="nav-text">ArrayBlockingQueue源码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-ConcurrentLinkedQueue"><span class="nav-number">2.4.</span> <span class="nav-text">2.4. ConcurrentLinkedQueue</span></a></li></ol></li></ol></div></div></section></div></aside></div><script>function password(){}var div=$(".post-body"),toc=$(".post-toc-wrap");password()</script></main></div><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="heart"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Leesin.Dong</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i>总访客 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人 </span><span class="site-pv"><i class="fa fa-eye"></i>访问量 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea");document.body.appendChild(n),n.style.position="absolute",n.style.top="0px",n.style.left="0px",n.value=e,n.select(),n.focus();var o=document.execCommand("copy");document.body.removeChild(n),o?$(this).text("复制成功"):$(this).text("复制失败"),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css"><script src="/lib/algolia-instant-search/instantsearch.min.js"></script><script src="/js/src/algolia-search.js?v=5.1.4"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("6og9b7lpddMqazBCDe8z4HqL-gzGzoHsz","faKN7dalSdXLmYYJTRq98B1f")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0===e.length)return void o.find(t).text(0);for(var i=0;i<e.length;i++){var r=e[i],s=r.get("url"),l=r.get("time"),c=document.getElementById(s);$(c).find(t).text(l)}for(var i=0;i<n.length;i++){var s=n[i],c=document.getElementById(s),u=$(c).find(t);""==u.text()&&u.text(0)}}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var t=$(".leancloud_visitors"),n=t.attr("id").trim(),o=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("url",n),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("time"),i.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var r=new e,s=new AV.ACL;s.setPublicReadAccess(!0),s.setPublicWriteAccess(!0),r.setACL(s),r.set("title",o),r.set("url",n),r.set("time",1),r.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):$(".post-title-link").length>1&&showTime(e)})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script></body></html><script src="/js/src/pjax/lazyload_min.js"></script><script src="/js/src/pjax/comments/comments.gitalk.js"></script><script src="/js/src/pjax/require.js" defer async data-main="/js/src/pjax/main.js"></script><!-- rebuild by neat -->