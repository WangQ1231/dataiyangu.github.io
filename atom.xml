<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leesin&#39;s Blog</title>
  
  <subtitle>To be a better me</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mmmmmm.me/"/>
  <updated>2019-03-13T13:27:07.492Z</updated>
  <id>http://mmmmmm.me/</id>
  
  <author>
    <name>Leesin.Dong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dubbo入门到精通学习笔记（一）：Dubbo对传统工程进行改造</title>
    <link href="http://mmmmmm.me/2019-03-13-1.html"/>
    <id>http://mmmmmm.me/2019-03-13-1.html</id>
    <published>2019-03-13T02:21:01.000Z</published>
    <updated>2019-03-13T13:27:07.492Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="改造思路"><a href="#改造思路" class="headerlink" title="改造思路"></a>改造思路</h1><h2 id="样例工程：传统的单工程项目（edu-demo）"><a href="#样例工程：传统的单工程项目（edu-demo）" class="headerlink" title="样例工程：传统的单工程项目（edu-demo）"></a>样例工程：传统的单工程项目（edu-demo）</h2><p>Maven<br>J-UI<br>Struts2<br>Spring3<br>MyBatis3<br>Druid<br>MySQL5.6<br>只有一个用户信息表(增、删除、查、改)</p><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p>传统mvc action（视图层、控制层） service（业务逻辑层） dao（dao层）<br>目录结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">common包— core.dao包（dao）、entity包（entity）、exception包、page包（pagebean、pageparam）、web包(sessionCOnstant、webException、Struts2ActionSupport、Dwzparam)</span><br><span class="line"></span><br><span class="line">user包—action包（action层）、base包（action层）、biz包（pmsuserBiz service层）、dao包（dao层）、entity包（实体pmsUser）、enums包(枚举)</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果对传统的mvc架构进行改造，一般会把业务逻辑层以下的做成dubbo服务，action去调用服务，拿到数据之后，然后和页面进行交互，也就是说继承dubbo之后action中只有极少的业务逻辑，调用的接口中执行了业务逻辑操作。</p><h2 id="改成dubbo调用方式后的工程结构"><a href="#改成dubbo调用方式后的工程结构" class="headerlink" title="改成dubbo调用方式后的工程结构"></a>改成dubbo调用方式后的工程结构</h2><p>edu-common-parent(Maven父配置)<br>edu-facade-user(用户服务接口)<br>edu-service-user(用户服务实现)<br>edu-web-boss(服务消费者)</p><h2 id="部署环境规划"><a href="#部署环境规划" class="headerlink" title="部署环境规划"></a>部署环境规划</h2><p>192.168.2.61 edu-web-boss(consumer)<br>192.168.3.71 zookeeper-3.4.6(注册中心)<br>192.168.3.72 edu-service-user(provider)<br>192.168.4.201 MySQL5.6(数据库)</p><h1 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h1><h2 id="愚公移山"><a href="#愚公移山" class="headerlink" title="愚公移山"></a>愚公移山</h2><h3 id="迁移包"><a href="#迁移包" class="headerlink" title="迁移包"></a>迁移包</h3><p>将edu（传统的工程demo下面简称edu）common包下（一些公共的类和接口）的内容（除了web包、core.dao包）放到facade项目中，也就只剩下exception、page包和entity包了，因为facade工程是服务的一个接口，是需要被别人引用的，别人用他的时候他等于是服务的api，我要调用的服务肯定要先在工程里引用服务本身的接口<br>将edu common包下的web包下内容放到web项目中<br>将edu common包下的core.dao包下的内容放到sercvice项目中<br>将edu user包下的action和base包放到web项目中<br>将edu user包下的entity和enums放到facade项目中，因为服务要引用实体，消费端也要引用实体<br>将edu user包下的biz和dao放到service项目中</p><h3 id="迁移页面："><a href="#迁移页面：" class="headerlink" title="迁移页面："></a>迁移页面：</h3><p>将webapp目录下除了META-INF和WEB-INF的文件，即images、js、page、statics、index.jsp包括web.xml迁移到web项目中</p><h3 id="迁移配置相关"><a href="#迁移配置相关" class="headerlink" title="迁移配置相关"></a>迁移配置相关</h3><p>将edu项目中mybatis包、spring包下的内容和jdbc.properties、log4j.properties放到service项目中的resource中<br>将edu项目中spring、struts包下的内容放到web项目中<br>web项目中不需要mybatis配置</p><h3 id="新项目的主要作用"><a href="#新项目的主要作用" class="headerlink" title="新项目的主要作用"></a>新项目的主要作用</h3><p>facade项目放着所有工程可以共用的包和接口，其实公共的包应该再建一个项目供所有人调用的<br>service项目放着dao和业务实现<br>web项目放着action</p><h2 id="涂涂改改"><a href="#涂涂改改" class="headerlink" title="涂涂改改"></a>涂涂改改</h2><p>web项目只能去调用facade包中的内容，facade去调用service中的内容。所以在facade中再加一个包service包新建PmsUserFacade <strong><font color="red">接口 </font></strong>对应于service包中的业务逻辑，PmsUserFacade是真正的dubbo用户服务接口。<br>因为service是业务实现，service中新建service.impl包下新键PmsUserFacadeImpl，dubbo用户服务接口实现。在PmsUserFacadeImpl的class头部添加注释 <strong><font color="red">@service（PmsUserFacade）</font></strong><br>service项目中的biz下的PmsUserBiz是业务逻辑里面 <strong><font color="red">@AutoWired了PmsUserDao</font></strong>，自己也有注解<strong><font color="red">@service（“pmsUserBiz”） </font></strong>，是业务逻辑的具体实现<br>在PmsUserFacadeImpl中 <strong><font color="red">@AutoWire了pmsUserBiz </font></strong>，并且粘贴pmsUserBiz的所有方法，并做修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@service(<span class="string">"pmsUserFacade"</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PmsUserFacadeImpl</span> <span class="title">implements</span> <span class="title">PmsUserFacade</span></span>&#123;</span><br><span class="line">    @AutoWired</span><br><span class="line">    private PmsUserBiz pmsUserBiz;</span><br><span class="line">    <span class="comment">//根据id获取用户信息</span></span><br><span class="line">public PmsUser getById(Long userId)&#123;</span><br><span class="line">        <span class="keyword">return</span> pmsUserBiz.getByid</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把pmsUserBiz中的全部方法（包括getId（return pmsUserDao.findByUserNo(userNo)）等业务逻辑方法）拷贝到PmsUserFacade接口中，当然去掉方法体（希望对外提供pmsUserBiz所有的方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface PmsUserFacade&#123;</span><br><span class="line">    <span class="comment">//根据用户id获取用户信息</span></span><br><span class="line">    public PmsUser getById(Long userId);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在原来的基础上多加了一层，所以action将原来的@AutoWire pmsUserBiz 变成@AutoWire PmsUserFacade</p><h2 id="公布服务"><a href="#公布服务" class="headerlink" title="公布服务"></a>公布服务</h2><p>在service项目中新建一个spring-dubbo-provider.xml的配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;xml...&gt;</span><br><span class="line">&lt;bean&gt;</span><br><span class="line">    <span class="comment">//服务的名称，提供应用信息，用于计算依赖关系</span></span><br><span class="line">    &lt;dubbo:application name=<span class="string">"gw-sercvice-user"</span>/&gt;</span><br><span class="line">    <span class="comment">//使用zookeeper注册中心暴露服务地址</span></span><br><span class="line">    &lt;dubbo:registry protocol=<span class="string">"zookeeper"</span> address=<span class="string">"192.167.2.12:2181"</span>/&gt;</span><br><span class="line">    <span class="comment">//用dubbo协议在20880端口暴露服务</span></span><br><span class="line">&lt;dubbo:protocol name-=<span class="string">"dubbo"</span> prot=<span class="string">"20880"</span>/&gt;</span><br><span class="line">    <span class="comment">//当protocolConfig和SerciceConfig某属性没有配置时，采用此缺省值</span></span><br><span class="line">&lt;dubbo:provider timeout=<span class="string">"10000"</span> threadpool=<span class="string">"fixed"</span> threads=<span class="string">"100"</span> accepts=<span class="string">"1000"</span>/&gt;</span><br><span class="line">    <span class="comment">//将要公布的接口，权限服务接口</span></span><br><span class="line">    &lt;dubbo:service interface=<span class="string">"wusc.edu.facade.user.service.PmsUserFacade"</span> ref=<span class="string">"pmsUserFacade"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure><p>在web项目中新建一个dubbo-consumer.xml</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;xml...&gt;</span><br><span class="line">&lt;bean&gt;</span><br><span class="line">    <span class="comment">//服务的名称，提供应用信息，用于计算依赖关系</span></span><br><span class="line">    &lt;dubbo:application name=<span class="string">"gw-web-boss"</span>/&gt;</span><br><span class="line">    <span class="comment">//使用zookeeper注册中心暴露服务地址</span></span><br><span class="line">    &lt;dubbo:registry protocol=<span class="string">"zookeeper"</span> address=<span class="string">"192.167.2.12:2181"</span>/&gt;</span><br><span class="line">    <span class="comment">//用dubbo协议在20880端口暴露服务</span></span><br><span class="line">&lt;dubbo:protocol name-=<span class="string">"dubbo"</span> prot=<span class="string">"20880"</span>/&gt;</span><br><span class="line">    <span class="comment">//当protocolConfig和SerciceConfig某属性没有配置时，采用此缺省值</span></span><br><span class="line">&lt;dubbo:provider timeout=<span class="string">"10000"</span> threadpool=<span class="string">"fixed"</span> threads=<span class="string">"100"</span> accepts=<span class="string">"1000"</span>/&gt;</span><br><span class="line">    <span class="comment">//将要公布的接口，权限服务接口,check=false的作用是当服务端没启动的时候，消费端也能启动，否则检查</span></span><br><span class="line">    <span class="comment">//的话消费端会报错。</span></span><br><span class="line">    &lt;dubbo:reference interface=<span class="string">"wusc.edu.facade.user.service.PmsUserFacade"</span> ref=<span class="string">"pmsUserFacade"</span> check=<span class="string">"false"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure><p>将上面的两个配置文件分别引入到各自项目的spring配置文件中（import）</p><h1 id="Dubbo架构说明"><a href="#Dubbo架构说明" class="headerlink" title="Dubbo架构说明"></a>Dubbo架构说明</h1><p><img alt="image-20190313071954339" data-original="../images/image-20190313071954339.png"></p><p>节点角色说明:<br>•Provider: 暴露服务的服务提供方 （对应上面service项目）<br>•Consumer: 调用远程服务的服务消费方（对应于上面的web项目）<br>•Registry: 服务注册与发现的注册中心（将rovider的接口注册到注册中心，然后consuser去注册中心拿到provider的地址，调用的时候不需要在经过注册中心了。）<br>•Monitor: 统计服务的调用次数和调用时间的监控中心<br>•Container: 服务运行容器</p><p>调用关系说明:</p><ol><li><p>服务容器负责启动，加载，运行服务提供者。</p></li><li><p>服务提供者在启动时，向注册中心注册自己提供的服务。</p></li><li><p>服务消费者在启动时，向注册中心订阅自己所需的服务。</p></li><li><p>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p></li><li><p>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，</p><p>再选另一台调用。</p></li><li><p>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p></li></ol><p>注册中心可选方案:zookeeper、Redis</p><p>1、建议使用dubbo-2.3.3以上版本的使用zookeeper注册中心客户端</p><p>2、Zookeeper是Apache Hadoop的子项目，强度相对较好，建议生产环境使用该注册中心。</p><p>3、Dubbo未对Zookeeper服务器端做任何侵入修改，只需安装原生的Zookeeper服务器即可， 所有注册中心逻辑适配都在调用Zookeeper客户端时完成。</p><h1 id="注册中心安装-Zookeeper-3-4-6"><a href="#注册中心安装-Zookeeper-3-4-6" class="headerlink" title="注册中心安装(Zookeeper-3.4.6)"></a>注册中心安装(Zookeeper-3.4.6)</h1><p>Dubbo 建议使用 Zookeeper 作为服务的注册中心。</p><p>注册中心服务器(192.168.3.71)配置，安装 Zookeeper:<br>1、 修改操作系统的/etc/hosts 文件中添加映射ip:</p><pre><code># zookeeper servers</code></pre><p>​ 192.168.3.71 edu-provider-01</p><p>2、 到 <a href="http://apache.fayea.com/zookeeper/下载" target="_blank" rel="noopener">http://apache.fayea.com/zookeeper/下载</a> zookeeper-3.4.6:</p><p>$ wget <a href="http://apache.fayea.com/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz" target="_blank" rel="noopener">http://apache.fayea.com/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz</a></p><p>3、 解压 zookeeper 安装包:</p><p>$ tar -zxvf zookeeper-3.4.6.tar.gz</p><p>4、 在/home/wusc/zookeeper-3.4.6 目录下创建以下目录:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/wusc/zookeeper<span class="number">-3.4</span><span class="number">.6</span></span><br><span class="line">$ mkdir data</span><br><span class="line">$ mkdir logs</span><br></pre></td></tr></table></figure><p></p><p>5、将 zookeeper-3.4.6/conf 目录下的 zoo_sample.cfg 文件拷贝一份，命名为为zoo.cfg<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure><p></p><p>6、 修改 zoo.cfg 配置文件:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi zoo.cfg</span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">   tickTime=<span class="number">2000</span></span><br><span class="line">   # The number of ticks that the initial</span><br><span class="line">   # synchronization phase can take</span><br><span class="line">   initLimit=<span class="number">10</span></span><br><span class="line">   # The number of ticks that can pass between</span><br><span class="line">   # sending a request and getting an acknowledgement</span><br><span class="line">   syncLimit=<span class="number">5</span></span><br><span class="line">   # the directory where the snapshot is stored.</span><br><span class="line">   # do not use /tmp for storage, /tmp here is just</span><br><span class="line">   # example sakes.</span><br><span class="line">   dataDir=<span class="regexp">/home/</span>wusc/zookeeper<span class="number">-3.4</span><span class="number">.6</span>/data</span><br><span class="line">   dataLogDir=<span class="regexp">/home/</span>wusc/zookeeper<span class="number">-3.4</span><span class="number">.6</span>/logs</span><br><span class="line">   # the port at which the clients will connect</span><br><span class="line">   clientPort=<span class="number">2181</span></span><br><span class="line">   #2888,3888 are election port</span><br><span class="line">server<span class="number">.1</span>=edu-provider<span class="number">-01</span>:<span class="number">2888</span>:<span class="number">3888</span></span><br></pre></td></tr></table></figure><p>上面的配置找到example sakes，将下面那行删除掉，替换成我们上面的那两行。</p><p>找到the port at which the clients will connect，配置端口clientPort=2181，不论是provider还是consumer将来都连接这个端口。</p><p>找到 #2888,3888 are election port，修改#2888,3888 are election port</p><p>其中，</p><p>2888 端口号是 zookeeper 服务之间通信的端口。<br>3888 是 zookeeper 与其他应用程序通信的端口。</p><p>edu-provider-01是在 hosts 中已映射了 IP 的主机名。<br>initLimit:这个配置项是用来配置 Zookeeper 接受客户端(这里所说的客户端不 是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器)初始化连接时最长能忍受多少个心跳时间间隔数。 当已经超过 10 个心跳的时间(也就是 tickTime)长度后 Zookeeper 服务器还没 有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是<br>5<em>2000=10 秒。<br>syncLimit:这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时 间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2</em>2000=4 秒。<br>server.A=B:C:D:其中 A 是一个数字，表示这个是第几号服务器;B 是这个服务 器的 IP 地址或/etc/hosts 文件中映射了 IP 的主机名;C 表示的是这个服务器与 集群中的 Leader 服务器交换信息的端口;D 表示的是万一集群中的 Leader 服务 器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是 用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是 一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同 的端口号。<br>7、 在 dataDir=/home/wusc/zookeeper-3.4.6/data 下创建 myid 文件<br>编辑 myid 文件，并在对应的 IP 的机器上输入对应的编号。如在 zookeeper 上，myid 文件内容就是 1。如果只在单点上进行安装配置，那么只有一个 server.1。指的就是上面的zoo.cfg中server.1=edu-provider-01:2888:3888的 server.1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi myid </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>8、 wusc 用户下修改 vi /home/wusc/.bash_profile，增加 zookeeper 配置，类似于配置jdk的环境变量:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># zookeeper env</span><br><span class="line"><span class="keyword">export</span> ZOOKEEPER_HOME=<span class="regexp">/home/</span>wusc/zookeeper<span class="number">-3.4</span><span class="number">.6</span></span><br><span class="line"><span class="keyword">export</span> PATH=$ZOOKEEPER_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p></p><p>使配置文件生效<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source /home/wusc/.bash_profile</span><br></pre></td></tr></table></figure><p></p><p>9、 在防火墙中打开要用到的端口 2181、2888、3888<br>切换到 root 用户权限，执行以下命令:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># chkconfig iptables on</span><br><span class="line"># service iptables start</span><br><span class="line">编辑/etc/sysconfig/iptables</span><br><span class="line"># vi /etc/sysconfig/iptables</span><br><span class="line">增加以下 <span class="number">3</span> 行:</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport <span class="number">2181</span> -j ACCEPT </span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport <span class="number">2888</span> -j ACCEPT </span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport <span class="number">3888</span> -j ACCEPT</span><br></pre></td></tr></table></figure><p></p><p>重启防火墙:<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service iptables restart</span><br></pre></td></tr></table></figure><p></p><p>查看防火墙端口状态:<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service iptables status</span><br></pre></td></tr></table></figure><p></p><p><img alt="image-20190313073322364" data-original="../images/image-20190313073322364.png"><br>10、 启动并测试 zookeeper(要用 wusc 用户启动，不要用 root):<br>(1) 使用 wusc 用户到/home/wusc/zookeeper-3.4.6/bin 目录中执行:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zkServer.sh start</span><br></pre></td></tr></table></figure><p></p><p>(2)输入 jps 命令查看进程:<br>$ jps<br>1456 QuorumPeerMain<br>1475 Jps<br>其中，QuorumPeerMain 是 zookeeper 进程启动正常</p><p>(3) 查看状态:<br>$ zkServer.sh status<br>(4) 查看 zookeeper 服务输出信息:<br>由于服务信息输出文件在/home/wusc/zookeeper-3.4.6/bin/zookeeper.out<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail <span class="number">-500</span>f zookeeper.out</span><br></pre></td></tr></table></figure><p></p><p>11、停止 zookeeper 进程:<br>$ zkServer.sh stop<br>12、 配置 zookeeper 开机使用 wusc 用户启动:<br>编辑/etc/rc.local 文件，加入:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - wusc -c <span class="string">'/home/wusc/zookeeper-3.4.6/bin/zkServer.sh start'</span></span><br></pre></td></tr></table></figure><p></p><p>su - wusc的意思是： 通过wusc用户执行后面的命令</p><h1 id="改造后的服务调用测试"><a href="#改造后的服务调用测试" class="headerlink" title="改造后的服务调用测试"></a>改造后的服务调用测试</h1><p>通过tomcat分别启动provider话consumer，查看zookeeper.out的日志。</p><p>provider也可以通过jar的方式启动</p><p>在service项目下新建test包，包下新建main的类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package dubbo.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @描述: 启动Dubbo服务用的MainClass.</span></span><br><span class="line"><span class="comment"> * @作者: WuShuicheng .</span></span><br><span class="line"><span class="comment"> * @创建时间: 2013-11-5,下午9:47:55 .</span></span><br><span class="line"><span class="comment"> * @版本: 1.0 .</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DubboProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> final Log log = LogFactory.getLog(DubboProvider.class);</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:spring/spring-context.xml"</span>);</span><br><span class="line">context.start();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">"== DubboProvider context start error:"</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">synchronized (DubboProvider.class) &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">DubboProvider.class.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">log.error(<span class="string">"== synchronized error:"</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样zookeeper.out有日志输出</p><p>浏览器入口原来是localhost:88/edu-demo<br>切换为dubbo的地址localhost:88/edu-web-boss<br>发现同样可以正常启动，并且功能完善。</p><h1 id="使用Dubbo进行规模服务化前的工程结构优化"><a href="#使用Dubbo进行规模服务化前的工程结构优化" class="headerlink" title="使用Dubbo进行规模服务化前的工程结构优化"></a>使用Dubbo进行规模服务化前的工程结构优化</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一、使用Dubbo是为了实现系统的分布式服务化<br>二、做成分布式服务架构的项目特点:<br>1、多个服务<br>2、多种类型的工程<br>3、工程间需要相互调用 4、如何实现工程间解耦?(高内聚、低耦合) 5、工程该怎样拆分? 6、如何对大量的工程进行合理有效管理?(高级篇:持续集成)</p><h2 id="修改项目结构"><a href="#修改项目结构" class="headerlink" title="修改项目结构"></a>修改项目结构</h2><p>edu-common-parent(Maven父配置)<br>edu-common (公共工程)<br>edu-common-config (公共配置工程)<br>edu-common-core (公共core工程)<br>edu-common-web (公共web工程)<br>edu-facade-user(用户服务接口)<br>edu-service-user(用户服务实现)<br>edu-web-boss(服务消费者)</p><p>之前的项目结构是有问题的，通过service和facade构建了一个服务provider，将公共的包，放在了facade里面，可是当出现多个服务的时候，比如Base.java这个类所有的工程都需要，同样BaseDao.java，所有的工程都需要访问数据库。当然可能有多个web项目，即consumer，像struts2的一些支持类,自定义的一些公共类也需要抽取出来。<br>包括Dubbo中的配置文件中的zookeeper地址等信息也可以抽取成配置</p><h3 id="抽取"><a href="#抽取" class="headerlink" title="抽取"></a>抽取</h3><p>edu-common (公共工程)，像异常、枚举类，任何工程需要的类都可以放在这里<br>edu-common-config (公共配置工程)dubbo的配置<br>edu-common-core (公共core工程)BaseDao.java、数据库等<br>edu-common-web (公共web工程) 消费者公共的部分</p><p>facade项目中的common包（entity、exception、page（分页））移到 edu-common 中，这些肯定是都需要用的。<br>service项目中的core.dao包下的内容（dao，对数据库的一些操作）迁移到edu-common-core<br>web项目中的common（struts2支持包）迁移到edu-common-web<br>项目中的数据路配置文件jdbc.properties和dubbo的注册地址（抽象到service.properties）,放到 edu-common-config 项目中</p><p>修改parent项目的pom.xml,将上面的几个新的工程加进去（properties节点）。<br>修改facade、service、web工程的pom.xml，添加dependencies（common等，引入需要的工程，ps需要什么里面的代码会报错的）重新导包。<br>修改spring配置文件，引入servic.peroperties(前提是已经在ma<br>ven中引入了项目)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-playceholder location=<span class="string">"classpath:jdbc.proerties,classpath:service.properties"</span>/&gt;</span><br></pre></td></tr></table></figure><p>修改dubbo-provider.xml、dubbo-consumer.xml</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dubbo.registory.address是service.properties文件中内容</span></span><br><span class="line">&lt;dubbo:registry protocol=<span class="string">"zookeeper"</span> address=<span class="string">"$&#123;dubbo.registory.address&#125;"</span>/&gt;</span><br></pre></td></tr></table></figure><p>剩下需要抽取的配置都可以通过这个方法来配置。</p><p>最后发现web项目中只剩下了最简单的和前端交互的恭喜，service项目中是业务的实现。<br>架构上其实还是有点类似mvc。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;改造思路&quot;&gt;&lt;a href=&quot;#改造思路&quot; class=&quot;headerlink&quot; title=&quot;改造思路&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Dubbo入门到精通学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Dubbo%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Dubbo" scheme="http://mmmmmm.me/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo入门到精通学习笔记（二）：Dubbo对传统工程进行改造</title>
    <link href="http://mmmmmm.me/2019-03-13-2.html"/>
    <id>http://mmmmmm.me/2019-03-13-2.html</id>
    <published>2019-03-13T02:21:01.000Z</published>
    <updated>2019-03-17T12:29:45.786Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="sdf"><a href="#sdf" class="headerlink" title="sdf"></a><a href=""></a>sdf</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;sdf&quot;&gt;&lt;a href=&quot;#sdf&quot; class=&quot;headerlink&quot; title=&quot;sdf&quot;&gt;&lt;/a&gt;&lt;a
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Dubbo入门到精通学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Dubbo%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Dubbo" scheme="http://mmmmmm.me/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>git分布式版本控制系统权威指南学习笔记（六）：git reset、get stash、git checkout总结</title>
    <link href="http://mmmmmm.me/2019-03-12-6.html"/>
    <id>http://mmmmmm.me/2019-03-12-6.html</id>
    <published>2019-03-12T02:21:06.000Z</published>
    <updated>2019-03-15T01:40:13.146Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><p>因为学习资料中讲的是在没听懂，自己从网上找了一个写的挺好的文章：<a href="https://blog.csdn.net/flysqrlboy/article/details/79250150" target="_blank" rel="noopener">https://blog.csdn.net/flysqrlboy/article/details/79250150</a></p><p>感谢！</p><p>Git快速入门系列文章<br>- <a href="http://blog.csdn.net/flysqrlboy/article/details/79223730" target="_blank" rel="noopener">Git快速入门-安装配置篇</a><br>- <a href="http://blog.csdn.net/flysqrlboy/article/details/79230835" target="_blank" rel="noopener">Git快速入门-常用命令之独奏篇</a><br>- <a href="http://blog.csdn.net/flysqrlboy/article/details/79237371" target="_blank" rel="noopener">Git快速入门-常用命令之交响乐篇</a><br>- <a href="http://blog.csdn.net/flysqrlboy/article/details/79250150" target="_blank" rel="noopener">Git快速入门-git stash 暂存变更，git reset 撤销commit，git revert 回退远程版本库</a></p><blockquote><p>注：本文基于git version 2.13.5 版本进行演示</p></blockquote><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>Git入门系列第四篇，基于场景，介绍一些非常实用的Git命令，也许这些命令会让你产生“还有这种操作”的感叹。例如如何把修改暂存起来，留着以后使用？想撤销已提交（commit）到本地版本库的代码该怎么办？撤销已push到远程代码库的代码呢？</p><h1 id="2-如何把修改暂存起来，留着以后使用？"><a href="#2-如何把修改暂存起来，留着以后使用？" class="headerlink" title="2. 如何把修改暂存起来，留着以后使用？"></a>2. 如何把修改暂存起来，留着以后使用？</h1><h2 id="2-1-使用场景"><a href="#2-1-使用场景" class="headerlink" title="2.1 使用场景"></a>2.1 使用场景</h2><p>实际开发过程中，我们经常会遇到这样的问题，当我们想把远程仓库的最新代码拉下来时，发现git会提示说我们本地做的修改会被覆盖，建议先commit代码或者stash（暂存）代码。你一定遇到过类似下面这样的提示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br><span class="line">remote: Counting objects: <span class="number">4</span>, done.</span><br><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span><br><span class="line">remote: Total <span class="number">4</span> (delta <span class="number">1</span>), reused <span class="number">3</span> (delta <span class="number">1</span>), pack-reused <span class="number">0</span></span><br><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">4</span>/<span class="number">4</span>), done.</span><br><span class="line">From github.com:flysqrlboy/git-command-tutorials</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">   <span class="number">7</span>dd2e09..d7e1e19  master     -&gt; origin/master</span><br><span class="line">Updating <span class="number">7</span>dd2e09..d7e1e19</span><br><span class="line">error: Your local changes to the following files would be overwritten by merge:</span><br><span class="line">    b.txt</span><br><span class="line">Please commit your changes or stash them before you merge.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure><p>留意下面两句提示，我们可以有两个选择：commit或stash。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; error: Your local changes to the following files would be overwritten by merge:  </span><br><span class="line">&gt; b.txt  </span><br><span class="line">&gt; Please commit your changes or stash them before you merge.</span><br></pre></td></tr></table></figure><p>如果我们本地的代码修改得差不多了，可以选择commit到本地版本库。但如果我们的修改只是个半成品，我们不想把这样的代码留在提交历史里的话。git stash就能派上用场了。</p><h2 id="2-2-git-stash-暂存进度"><a href="#2-2-git-stash-暂存进度" class="headerlink" title="2.2 git stash 暂存进度"></a>2.2 git stash 暂存进度</h2><p>先来看下当前的工作区和暂存区状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">  On branch master</span><br><span class="line">  Changes to be committed:</span><br><span class="line">    (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line">  </span><br><span class="line">      modified:   a.txt</span><br><span class="line">  </span><br><span class="line">  Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">    (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">    (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">  </span><br><span class="line">      modified:   b.txt</span><br></pre></td></tr></table></figure><p>如果想要切换分支，必须保证当前的分支是noting to commit的，或者commit或者stash下<br>git status 输出中告诉我们，a.txt 和 b.txt 都有修改，a.txt 已加入到暂存区（在Changes to be committed下面），b.txt 的修改则还在工作区中（在Changes not staged for commit下面）。正是因为远程代码库有人更改了b.txt ，才导致本地拉取代码时提示会被覆盖。这里，用git stash 命令保存当前工作进度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">   Saved working directory and index state WIP on master: <span class="number">7</span>dd2e09 add two files a.txt b.txt</span><br></pre></td></tr></table></figure><p>运行git stash 之后，再查看工作区状态，会发现之前工作区和暂存区的修改都不见了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h2 id="2-3-查看进度"><a href="#2-3-查看进度" class="headerlink" title="2.3 查看进度"></a>2.3 查看进度</h2><p>查看stash进度用命令git stash list</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">  stash@&#123;<span class="number">0</span>&#125;: WIP on master: <span class="number">7</span>dd2e09 add two files a.txt b.txt</span><br></pre></td></tr></table></figure><p>可以看到刚刚暂存的进度有个标识 stash@{0}。如果想查看某个进度具体修改的文件可以用命令git stash show</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git stash show stash@&#123;<span class="number">0</span>&#125;</span><br><span class="line">    a.txt | <span class="number">1</span> +</span><br><span class="line">    b.txt | <span class="number">1</span> +</span><br><span class="line">    <span class="number">2</span> files changed, <span class="number">2</span> insertions(+)</span><br></pre></td></tr></table></figure><h2 id="2-4-恢复进度"><a href="#2-4-恢复进度" class="headerlink" title="2.4 恢复进度"></a>2.4 恢复进度</h2><p>使用 git stash pop 从最近保存的进度进行恢复。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line"> On branch master</span><br><span class="line"> Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">   (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">   (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"> </span><br><span class="line"> modified:   a.txt</span><br><span class="line"> modified:   b.txt</span><br><span class="line"> </span><br><span class="line"> no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"> Dropped refs/stash@&#123;<span class="number">0</span>&#125; (ddc97ea74d33f3417f5ddab429a1dfeb3c08ca19)</span><br></pre></td></tr></table></figure><p>通过git status查看工作区状态，可以看到之前的修改又回来了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"> On branch master</span><br><span class="line"> Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">   (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">   (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"> </span><br><span class="line">     modified:   a.txt</span><br><span class="line">     modified:   b.txt</span><br><span class="line"> </span><br><span class="line"> no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>不过可能你也发现了一个小瑕疵，原来的a.txt 的修改已经添加到暂存区的，但现在用git stash pop 恢复进度后，a.txt 的修改却还在工作区，暂存区的修改被撤销了。这里其实可以在运行git stash pop命令时带上一个 –index 的选项来告诉git重新应用被暂存的变更。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">git stash pop --index</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   a.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   b.txt</span><br><span class="line"></span><br><span class="line">Dropped refs/stash@&#123;<span class="number">0</span>&#125; (c62afccafe9aaec2b44abe85b4206728479b9902)</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   a.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   b.txt</span><br></pre></td></tr></table></figure><h1 id="3-如何撤销工作区的修改？"><a href="#3-如何撤销工作区的修改？" class="headerlink" title="3. 如何撤销工作区的修改？"></a>3. 如何撤销工作区的修改？</h1><p>如果觉得对b.txt这个文件的修改是没有必要的，该如何撤消修改，回到之前的状态（也就是回到没有修改前的状态）？git status 命令输出是有告诉我们怎么做的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">   On branch master</span><br><span class="line">   Changes to be committed:</span><br><span class="line">     (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line">   </span><br><span class="line">       modified:   a.txt</span><br><span class="line">   </span><br><span class="line">   Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">     (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">     (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">   </span><br><span class="line">       modified:   b.txt</span><br></pre></td></tr></table></figure><p>就在“Changes not staged for commit”下面第二个括号内，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; (use “git checkout – &lt; file &gt;…” to discard changes <span class="keyword">in</span> working directory)</span><br></pre></td></tr></table></figure><p>git checkout – filename 可以丢弃某个文件在工作区的改动。我们试试看。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- b.txt</span><br><span class="line"> $ git status</span><br><span class="line"> On branch master</span><br><span class="line"> Changes to be committed:</span><br><span class="line">   (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"> </span><br><span class="line">     modified:   a.txt</span><br></pre></td></tr></table></figure><p>git status 已经没有b.txt 的信息，说明b.txt的修改已经撤出工作区，恢复到修改前的版本了。这里提醒一下：git checkout – filename 这个命令是有点危险的，因为它会丢弃掉之前做的改动，这是找不回来的。只有在确定某个文件是真的不需要改动才撤销。一般情况下，如果只是想回到没修改前的版本，但仍然想保留修改的内容，可以用git stash命令把改动暂存起来。</p><h1 id="4-如何把暂存区的修改撤回到工作区"><a href="#4-如何把暂存区的修改撤回到工作区" class="headerlink" title="4. 如何把暂存区的修改撤回到工作区"></a>4. 如何把暂存区的修改撤回到工作区</h1><p>如果我们不小心把一些还不想提交的修改添加到了暂存区（例如不小心用了 git add . 命令把所有改动都add 到暂存区），我们怎么把某些文件撤回工作区呢？实际上git status命令也有告诉我们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">   On branch master</span><br><span class="line">   Changes to be committed:</span><br><span class="line">     (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line">   </span><br><span class="line">       modified:   a.txt</span><br><span class="line">   </span><br><span class="line">   Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">     (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">     (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">   </span><br><span class="line">       modified:   b.txt</span><br></pre></td></tr></table></figure><p>在 “Changes to be committed” 下面，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; (use “git reset HEAD &lt; file &gt;…” to unstage)</span><br></pre></td></tr></table></figure><p>用 git reset HEAD filename（git checkout filename也可以） 命令把暂存区的改动撤回到工作区，我们试试。</p><figure class="highlight js"><figcaption><span>$ git reset HEAD a.txt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Unstaged changes after reset:</span><br><span class="line">M   a.txt</span><br><span class="line">M   b.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   a.txt</span><br><span class="line">    modified:   b.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>git status 输出可以看到，a.txt 的改动已经被撤出暂存区了。</p><h1 id="5-如何把最近的一次commit撤回到暂存区"><a href="#5-如何把最近的一次commit撤回到暂存区" class="headerlink" title="5. 如何把最近的一次commit撤回到暂存区"></a>5. 如何把最近的一次commit撤回到暂存区</h1><p>如果我们对最近的一次commit感到不满意，想把它从本地版本库撤回到暂存区，该怎么做呢？让我们先做一次commit：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">  On branch master</span><br><span class="line">  Changes to be committed:</span><br><span class="line">    (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line">  </span><br><span class="line">      modified:   a.txt</span><br><span class="line">      modified:   b.txt</span><br><span class="line">  </span><br><span class="line">  $ git commit -m <span class="string">'modify a.txt b.txt'</span></span><br><span class="line">  [master c80c16c] modify a.txt b.txt</span><br><span class="line">   <span class="number">2</span> files changed, <span class="number">2</span> insertions(+)</span><br><span class="line">  </span><br><span class="line">  $ git log --oneline</span><br><span class="line">  c80c16c (HEAD -&gt; master) modify a.txt b.txt</span><br><span class="line">  <span class="number">7</span>dd2e09 add two files a.txt b.txt</span><br><span class="line">  e6e0035 <span class="number">1.</span>oneline <span class="number">2.</span>second line</span><br></pre></td></tr></table></figure><p>提交已经成功，commitid 为 <strong>c80c16c</strong> 。现在要撤销这次提交，把改动撤回到暂存区。同样是使用命令 git reset，只不过这次要加上 –soft 选项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD^</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   a.txt</span><br><span class="line">    modified:   b.txt</span><br></pre></td></tr></table></figure><p>git status 输出告诉我们，a.txt 和 b.txt的改动又回到暂存区了。再查看提交历史。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline</span><br><span class="line"><span class="number">7</span>dd2e09 (HEAD -&gt; master) add two files a.txt b.txt</span><br><span class="line">e6e0035 <span class="number">1.</span>oneline <span class="number">2.</span>second line</span><br></pre></td></tr></table></figure><p>commitid 为 <strong>c80c16c</strong> 的那次提交已经没有了。现在来解释下 git reset –soft HEAD^ 的含义。先说一下”HEAD^”,它代表最新的一次提交的前一次提交。“HEAD”在Git中就是一个引用，它总是指向（当前分支中）最新的那一次提交。所以上面的命令意思是把头部引用（HEAD）向前回退一次。而选项–soft 的作用就是把最新那次提交的所有改动撤回到暂存区。</p><h1 id="6-如何回退已经push到远程版本库的提交"><a href="#6-如何回退已经push到远程版本库的提交" class="headerlink" title="6. 如何回退已经push到远程版本库的提交"></a>6. 如何回退已经push到远程版本库的提交</h1><p>上面我们讨论的只是撤销本地做的提交，那如果提交已经push到远程代码库。要怎么回退呢？我们先把上面对a.txt ， b.txt的修改push到远程代码库。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">  Counting objects: <span class="number">4</span>, done.</span><br><span class="line">  Delta compression using up to <span class="number">8</span> threads.</span><br><span class="line">  Compressing objects: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span><br><span class="line">  Writing objects: <span class="number">100</span>% (<span class="number">4</span>/<span class="number">4</span>), <span class="number">373</span> bytes | <span class="number">373.00</span> KiB/s, done.</span><br><span class="line">  Total <span class="number">4</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">  To github.com:flysqrlboy/git-command-tutorials.git</span><br><span class="line">     d7e1e19..f0e0628  master -&gt; master</span><br></pre></td></tr></table></figure><p>已push成功，看下提交历史</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline</span><br><span class="line">  f0e0628 (HEAD -&gt; master, origin/master) modify a.txt b.txt</span><br><span class="line">  d7e1e19 Merge pull request #1 from imflysquirrel/master</span><br><span class="line">  <span class="number">0</span>c550df modify b.txt by imflysquirrel</span><br><span class="line">  <span class="number">7</span>dd2e09 add two files a.txt b.txt</span><br></pre></td></tr></table></figure><p>commitid 为 f0e0628的这次提交已经push到远程。现在想回退远程的这次提交，可能你会想到，先在本地用git reset命令撤销f0e0628 ，再push到远程，这种方案可行吗？试试看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD^</span><br><span class="line"> $ git log --oneline</span><br><span class="line"> d7e1e19 (HEAD -&gt; master) Merge pull request #1 from imflysquirrel/master</span><br><span class="line"> <span class="number">0</span>c550df modify b.txt by imflysquirrel</span><br><span class="line"> <span class="number">7</span>dd2e09 add two files a.txt b.txt</span><br></pre></td></tr></table></figure><p>执行git reset后本地已经回退到上一次提交，这时我们使用git push推送到远程看看能否成功。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line"> To github.com:flysqrlboy/git-command-tutorials.git</span><br><span class="line">  ! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line"> error: failed to push some refs to <span class="string">'git@github.com:flysqrlboy/git-command-tutorials.git'</span></span><br><span class="line"> hint: Updates were rejected because the tip <span class="keyword">of</span> your current branch is behind</span><br><span class="line"> hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line"> hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line"> hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>推送失败了，reject的原因是说本地当前分支落后于远程代码库，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; hint: Updates were rejected because the tip <span class="keyword">of</span> your current branch is behind</span><br></pre></td></tr></table></figure><p>因为我们本地的HEAD引用当前指向的提交是 <strong>d7e1e19</strong>，而远程的HEAD指向的是<strong>f0e0628</strong>。d7e1e19落后于f0e0628。其实不应该用git reset来回退远程仓库的提交，<a href="https://www.baidu.com/s?wd=%E5%8F%96%E8%80%8C%E4%BB%A3%E4%B9%8B&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">取而代之</a>的是用git revert。git revert 这个命令也会创建一次提交，只不过这个提交相当于被回退的那次提交的一个反向提交。比如在<strong>f0e0628</strong> 这次提交提交中，b.txt增加了一行“Hello World！”，git diff 如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/b.txt b/b.txt</span><br><span class="line">  index <span class="number">696</span>ac20.<span class="number">.0</span>f47c73 <span class="number">100644</span></span><br><span class="line">  --- a/b.txt</span><br><span class="line">  +++ b/b.txt</span><br><span class="line">  @@ <span class="number">-1</span> +<span class="number">1</span>,<span class="number">2</span> @@</span><br><span class="line">   add by imflysquirrel</span><br><span class="line">  +Hello World!</span><br></pre></td></tr></table></figure><p>那么反向提交的话就会删掉这行“Hello World!”, 下面用git revert 演示下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git revert HEAD</span><br><span class="line">  [master <span class="number">9086</span>b68] Revert <span class="string">"modify a.txt b.txt"</span></span><br><span class="line">   <span class="number">2</span> files changed, <span class="number">2</span> deletions(-)</span><br></pre></td></tr></table></figure><p>git revert HEAD 表示revert HEAD指向的那次提交，也就是最新的那一次提交f0e0628。用git log看下提交历史：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br><span class="line">   <span class="number">9086</span>b68 (HEAD -&gt; master) Revert <span class="string">"modify a.txt b.txt"</span></span><br><span class="line">   f0e0628 (origin/master) modify a.txt b.txt</span><br><span class="line">   d7e1e19 Merge pull request #1 from imflysquirrel/master</span><br><span class="line">   <span class="number">0</span>c550df modify b.txt by imflysquirrel</span><br><span class="line">   <span class="number">7</span>dd2e09 add two files a.txt b.txt</span><br></pre></td></tr></table></figure><p>新增了一个提交<strong>9086b68</strong> ，原来的<strong>f0e0628</strong> 是还存在的。看下这时的b.txt，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat b.txt</span><br><span class="line"> add by imflysquirrel</span><br></pre></td></tr></table></figure><p>“Hello World!” 那行已经被删除掉了。那么现在可以push了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git push origin master</span><br><span class="line">Counting objects: <span class="number">3</span>, done.</span><br><span class="line">Delta compression using up to <span class="number">8</span> threads.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">316</span> bytes | <span class="number">316.00</span> KiB/s, done.</span><br><span class="line">Total <span class="number">3</span> (delta <span class="number">1</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">remote: Resolving deltas: <span class="number">100</span>% (<span class="number">1</span>/<span class="number">1</span>), completed <span class="keyword">with</span> <span class="number">1</span> local object.</span><br><span class="line">To github.com:flysqrlboy/git-command-tutorials.git</span><br><span class="line">   f0e0628.<span class="number">.9086</span>b68  master -&gt; master</span><br></pre></td></tr></table></figure><p>Ok! 成功push 到远程。</p><h1 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h1><p>本文介绍了几个使用的git 命令。git stash 暂存代码。git reset 撤销本地提交。git revert 回退远程代码库。希望对你在使用git时有所帮助。如果觉得本文写的还行，请点个赞吧！也欢迎在讨论区留言做进一步交流。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;因为学习资料中讲的是在没听懂，自己从网上找了一个写的挺好的文章：&lt;a href=&quot;https://blog.csdn.net
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="git分布式版本控制系统权威指南学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="http://mmmmmm.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git分布式版本控制系统权威指南学习笔记（五）：git checkout</title>
    <link href="http://mmmmmm.me/2019-03-12-5.html"/>
    <id>http://mmmmmm.me/2019-03-12-5.html</id>
    <published>2019-03-12T02:21:05.000Z</published>
    <updated>2019-03-12T11:14:20.768Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h1><p>涉及到的命令<br>cat .git/head<br>git branch<br>git checkout commitId<br>git reflog</p><h2 id="通过cat可以查看当前的分支"><a href="#通过cat可以查看当前的分支" class="headerlink" title="通过cat可以查看当前的分支"></a>通过cat可以查看当前的分支</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) cat .git/HEAD</span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><h2 id="通过branch查看当前分支"><a href="#通过branch查看当前分支" class="headerlink" title="通过branch查看当前分支"></a>通过branch查看当前分支</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) git branch -v</span><br><span class="line">  b      <span class="number">81</span>b09ec add</span><br><span class="line">* master <span class="number">1e20</span>fe7 a</span><br></pre></td></tr></table></figure><h2 id="checkout-commitId（真正的🌰-挽救分离头指针）"><a href="#checkout-commitId（真正的🌰-挽救分离头指针）" class="headerlink" title="checkout commitId（真正的🌰,挽救分离头指针）"></a>checkout commitId（真正的🌰,挽救分离头指针）</h2><p>经过checkout commitId之后，当前的头指针是游离状态的。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ed97a5e3d4a是某次提交的hash值</span></span><br><span class="line">➜  demo git:(<span class="number">8e0</span>f16b) git checkout ed97a5e3d4a</span><br><span class="line"><span class="comment">//会有一个警告，当前在一个游离的头指针上</span></span><br><span class="line">Warning: you are leaving <span class="number">1</span> commit behind, not connected to</span><br><span class="line">any <span class="keyword">of</span> your branches:</span><br><span class="line"></span><br><span class="line">  <span class="number">8e0</span>f16b dfg</span><br><span class="line"></span><br><span class="line">If you want to keep it by creating a <span class="keyword">new</span> branch, <span class="keyword">this</span> may be a good time</span><br><span class="line">to <span class="keyword">do</span> so <span class="keyword">with</span>:</span><br><span class="line"> git branch &lt;<span class="keyword">new</span>-branch-name&gt; <span class="number">8e0</span>f16b</span><br><span class="line">➜  demo git:(ed97a5e) git branch</span><br><span class="line"><span class="comment">//在例子中这里是*（no branch）但是没有复现。</span></span><br><span class="line">* (HEAD detached at ed97a5e)</span><br><span class="line">  b</span><br><span class="line">  master</span><br><span class="line"> <span class="comment">//查看第一条reflog</span></span><br><span class="line">➜  demo git:(ed97a5e) git reflog <span class="number">-1</span></span><br><span class="line">ed97a5e (HEAD) HEAD@&#123;<span class="number">0</span>&#125;: checkout: moving <span class="keyword">from</span> master to ed97aa</span><br><span class="line">➜  demo git:(ed97a5e) git checkout master</span><br><span class="line"><span class="comment">//大概意思是，你已经有了一个commit 但是不隶属于任何一个分支，假如想要</span></span><br><span class="line"><span class="comment">//这次提交的话，可以采用git branch new_branch_name 4700da(此处省略hash值)的方式。</span></span><br><span class="line">Warning: you are leaving <span class="number">1</span> commit behind, not connected to</span><br><span class="line">any <span class="keyword">of</span> your branches:</span><br><span class="line"></span><br><span class="line">  <span class="number">91</span>a80cc dsaf</span><br><span class="line"></span><br><span class="line">If you want to keep it by creating a <span class="keyword">new</span> branch, <span class="keyword">this</span> may be a good time</span><br><span class="line">to <span class="keyword">do</span> so <span class="keyword">with</span>:</span><br><span class="line"></span><br><span class="line"> git branch &lt;<span class="keyword">new</span>-branch-name&gt; <span class="number">91</span>a80cc</span><br><span class="line"></span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line"><span class="comment">//上面是希望通过checkout改变commit历史的，这里直接gitmerge回来</span></span><br><span class="line">➜  demo git:(master) git merge <span class="number">91</span>a80cc（这里是刚才checkout的commit的id）</span><br><span class="line">Already up to date.</span><br><span class="line">➜  demo git:(master) git cat-file -p HEAD</span><br><span class="line">tree acefb39d45e5cc33c3f4889b0d150c3bb6983f56</span><br><span class="line"><span class="comment">//看到这里有两个parent</span></span><br><span class="line">parent <span class="number">1e20</span>fe7563a4b4bf8a091fe6c55ca9f32786224c</span><br><span class="line">parent <span class="number">91</span>a80cc6cc69cf2c2438b667964ff81b8e99587b</span><br><span class="line">author dataiyangu &lt;<span class="number">32248827</span>@qq.com&gt; <span class="number">1552348529</span> +<span class="number">0800</span></span><br><span class="line">committer dataiyangu &lt;<span class="number">32248827</span>@qq.com&gt; <span class="number">1552348529</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">sdf</span><br></pre></td></tr></table></figure><p></p><h1 id="git-checkout-用法"><a href="#git-checkout-用法" class="headerlink" title="git checkout 用法"></a>git checkout 用法</h1><p>撤销本地工作区的修改，前提是没有被<code>git add.</code><br>gitcheckout .<br>gitcheckout fiel<br>gitcheckout 目录</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;分离头指针&quot;&gt;&lt;a href=&quot;#分离头指针&quot; class=&quot;headerlink&quot; title=&quot;分离头指针&quot;&gt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="git分布式版本控制系统权威指南学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="http://mmmmmm.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git分布式版本控制系统权威指南学习笔记（四）：git reset</title>
    <link href="http://mmmmmm.me/2019-03-12-4.html"/>
    <id>http://mmmmmm.me/2019-03-12-4.html</id>
    <published>2019-03-12T02:21:04.000Z</published>
    <updated>2019-03-12T11:14:18.007Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h2 id="git-reset目录树重写"><a href="#git-reset目录树重写" class="headerlink" title="git reset目录树重写"></a>git reset目录树重写</h2><p>git reset –soft 暂存区工作区不变<br>git reset –hard<br>git reset file bane</p><p>如果修改某一个文件（没有<code>git add</code>，已被提交过），想撤销这次修改（确定没任何用处）？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout a.txt 或者 /src/ (撤销某个文件下的所有)</span><br></pre></td></tr></table></figure><p>如果修改某一个文件（<code>git add</code>已在暂存区），想撤销这次修改（确定没任何用处）？，执行完下面的命令就会回到上面的哪个状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset a.txt</span><br></pre></td></tr></table></figure><p><strong><font color="red">注意如果不指定reset的路径的话，就会把所有在暂存区的都撤销<br></font></strong></p><p>如果已修改某几个文件，但是想撤销到某个commit提交之前，但是当前暂存区、工作区不想撤销？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft commitId</span><br><span class="line"><span class="comment">//HEAD^最近一次的</span></span><br><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure><p>🌰<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个🌰：原文：https://blog.csdn.net/flysqrlboy/article/details/79250150 </span></span><br><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line">    modified:   a.txt</span><br><span class="line">    modified:   b.txt</span><br><span class="line">$ git log --oneline</span><br><span class="line">c80c16c (HEAD -&gt; master) modify a.txt b.txt</span><br><span class="line"><span class="number">7</span>dd2e09 add two files a.txt b.txt</span><br><span class="line">e6e0035 <span class="number">1.</span>oneline <span class="number">2.</span>second line</span><br><span class="line">$ git reset --soft HEAD^</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line">    modified:   a.txt</span><br><span class="line">    modified:   b.txt</span><br><span class="line">$ git log --oneline</span><br><span class="line"><span class="number">7</span>dd2e09 (HEAD -&gt; master) add two files a.txt b.txt</span><br><span class="line">e6e0035 <span class="number">1.</span>oneline <span class="number">2.</span>second line</span><br></pre></td></tr></table></figure><p></p><p>如果修改了某个文件也提交暂存区了，想撤销到某个commit（确定都不要了），其实还可以找回！！！那应该如何找回呢？看下小节</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commitId</span><br></pre></td></tr></table></figure><h2 id="git-reset-重置"><a href="#git-reset-重置" class="headerlink" title="git reset 重置"></a>git reset 重置</h2><p>git reflog<br>git reflog show master | head 5</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过hard（粗鲁的）切换到其他的commit（里面文件被修改的内容回退了）</span></span><br><span class="line">➜  demo git:(master) ✗ git reset --hard  <span class="number">81</span>b09ecc5f2f0222ede2b474efb1d8da9b04714</span><br><span class="line">HEAD is now at <span class="number">81</span>b09ec add</span><br><span class="line"><span class="comment">//通过这个命令查看可以切换的commit</span></span><br><span class="line">➜  demo git:(master) git reflog </span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) HEAD@&#123;<span class="number">0</span>&#125;: reset: moving to <span class="number">81</span>b09ecc5f2f0222ede2b474efb1d8da9b04714</span><br><span class="line"><span class="number">50</span>bceb7 HEAD@&#123;<span class="number">1</span>&#125;: commit: a</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) HEAD@&#123;<span class="number">2</span>&#125;: checkout: moving <span class="keyword">from</span> b to master</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) HEAD@&#123;<span class="number">3</span>&#125;: checkout: moving <span class="keyword">from</span> master to b</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) HEAD@&#123;<span class="number">4</span>&#125;: reset: moving to HEAD</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) HEAD@&#123;<span class="number">5</span>&#125;: checkout: moving <span class="keyword">from</span> b to master</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) HEAD@&#123;<span class="number">6</span>&#125;: checkout: moving <span class="keyword">from</span> master to b</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) HEAD@&#123;<span class="number">7</span>&#125;: checkout: moving <span class="keyword">from</span> b to master</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) HEAD@&#123;<span class="number">8</span>&#125;: checkout: moving <span class="keyword">from</span> master to b</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) HEAD@&#123;<span class="number">9</span>&#125;: checkout: moving <span class="keyword">from</span> b to master</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) HEAD@&#123;<span class="number">10</span>&#125;: checkout: moving <span class="keyword">from</span> master to b</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) HEAD@&#123;<span class="number">11</span>&#125;: reset: moving to HEAD</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) HEAD@&#123;<span class="number">12</span>&#125;: checkout: moving <span class="keyword">from</span> b to master</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) HEAD@&#123;<span class="number">13</span>&#125;: reset: moving to HEAD</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) HEAD@&#123;<span class="number">14</span>&#125;: checkout: moving <span class="keyword">from</span> master to b</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) HEAD@&#123;<span class="number">15</span>&#125;: commit: add</span><br><span class="line"><span class="number">1e20</span>fe7 HEAD@&#123;<span class="number">16</span>&#125;: commit: a</span><br><span class="line">ed97a5e HEAD@&#123;<span class="number">17</span>&#125;: commit (initial): my once</span><br><span class="line"><span class="comment">//查看master分支可以切换的commit</span></span><br><span class="line">➜  demo git:(master) git reflog show master</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) master@&#123;<span class="number">0</span>&#125;: reset: moving to <span class="number">81</span>b09ecc5f2f0222ede2b474efb1d8da9b04714</span><br><span class="line"><span class="number">50</span>bceb7 master@&#123;<span class="number">1</span>&#125;: commit: a</span><br><span class="line"><span class="number">81</span>b09ec (HEAD -&gt; master, b) master@&#123;<span class="number">2</span>&#125;: commit: add</span><br><span class="line"><span class="number">1e20</span>fe7 master@&#123;<span class="number">3</span>&#125;: commit: a</span><br><span class="line">ed97a5e master@&#123;<span class="number">4</span>&#125;: commit (initial): my once</span><br><span class="line"><span class="comment">//粗鲁的切换回去，后缀是上面命令中（git reflog）得到的，注意里面被修改的内容被回退了</span></span><br><span class="line">➜  demo git:(master) git reset --hard master@&#123;<span class="number">3</span>&#125;</span><br><span class="line">HEAD is now at <span class="number">1e20</span>fe7 a</span><br></pre></td></tr></table></figure><p><strong><font color="red">切换回去后，注意里面被修改的内容被回退了</font></strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;git-reset目录树重写&quot;&gt;&lt;a href=&quot;#git-reset目录树重写&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="git分布式版本控制系统权威指南学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="http://mmmmmm.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git分布式版本控制系统权威指南学习笔记（三）：简单了解git对象、head以及sha1sum</title>
    <link href="http://mmmmmm.me/2019-03-12-3.html"/>
    <id>http://mmmmmm.me/2019-03-12-3.html</id>
    <published>2019-03-12T02:21:03.000Z</published>
    <updated>2019-03-12T11:14:15.591Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="git对象（简单了解）"><a href="#git对象（简单了解）" class="headerlink" title="git对象（简单了解）"></a>git对象（简单了解）</h1><p>每次提交都有tree、parent、author、committer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) ✗ git log --pretty=raw --graph <span class="number">50</span>bceb7c6f5</span><br><span class="line">* commit <span class="number">50</span>bceb7c6f598c258a1502f25f7bc08220635aea</span><br><span class="line">| tree <span class="number">9</span>d1cf4f29cf360391811eb69f8eeb6859a029c11</span><br><span class="line">| parent <span class="number">81</span>b09ecc5f2f0222ede2b474efb1d8da9b04714e</span><br><span class="line">| author dataiyangu &lt;<span class="number">32248827</span>@qq.com&gt; <span class="number">1552315059</span> +<span class="number">0800</span></span><br><span class="line">| committer dataiyangu &lt;<span class="number">32248827</span>@qq.com&gt; <span class="number">1552315059</span> +<span class="number">0800</span></span><br><span class="line">|</span><br><span class="line">|     a</span><br><span class="line">|</span><br><span class="line">* commit <span class="number">81</span>b09ecc5f2f0222ede2b474efb1d8da9b04714e</span><br><span class="line">| tree <span class="number">86761909e740889</span>c54721914f2e942218982991f</span><br><span class="line">| parent <span class="number">1e20</span>fe7563a4b4bf8a091fe6c55ca9f32786224c</span><br><span class="line">| author dataiyangu &lt;<span class="number">32248827</span>@qq.com&gt; <span class="number">1552277904</span> +<span class="number">0800</span></span><br><span class="line">| committer dataiyangu &lt;<span class="number">32248827</span>@qq.com&gt; <span class="number">1552277904</span> +<span class="number">0800</span></span><br><span class="line">|</span><br><span class="line">|     add</span><br><span class="line">|</span><br><span class="line">* commit <span class="number">1e20</span>fe7563a4b4bf8a091fe6c55ca9f32786224c</span><br><span class="line">| tree <span class="number">529</span>ca55c0571956f6e1b1290a77675ba72a64938</span><br><span class="line">| parent ed97a5e3d4ae753183e6a796625dfca1f83c1f61</span><br><span class="line">| author dataiyangu &lt;<span class="number">32248827</span>@qq.com&gt; <span class="number">1552277753</span> +<span class="number">0800</span></span><br><span class="line">| committer dataiyangu &lt;<span class="number">32248827</span>@qq.com&gt; <span class="number">1552277753</span> +<span class="number">0800</span></span><br><span class="line">|</span><br><span class="line">|     a</span><br></pre></td></tr></table></figure><p>–pretty=raw没有加任何加工的，原先是什么就是什么，参数还可以指定为oneline、short、full、fuller、emial、raw、farmat等<br>–graph 50bceb7c6f5展现对象之间的关系<br>左边的竖线表示这里是一个链表的关系，通过parent来连接，可以看到上面代码中第一个parent的号就是第二个的commit号，最早的那次提交是没有parent的，这也就是为什么git切换分支特别快。</p><p>tree类似于目录a文件夹下有b和c，c下有d和e，a和c都是tree，有点递归的感觉。</p><h2 id="对象是存在哪里的？"><a href="#对象是存在哪里的？" class="headerlink" title="对象是存在哪里的？"></a>对象是存在哪里的？</h2><p>就是存在版本库的objects目录中，通过hash值前两位作为文件夹，后几位作为具体的对象名</p><h1 id="head和master分支"><a href="#head和master分支" class="headerlink" title="head和master分支"></a>head和master分支</h1><p>head就是一个类似指针的概念，指向master，head就是master，指向dev，head就是dev，就是<code>git branch</code>前面的<code>*</code>号</p><p>简而言之head就是当前分支，当前分支是哪个分支，head就指向哪个分支。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) ✗ git branch</span><br><span class="line">  b</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h1 id="上面的hash值怎么来的？"><a href="#上面的hash值怎么来的？" class="headerlink" title="上面的hash值怎么来的？"></a>上面的hash值怎么来的？</h1><p>sha1sum（这个算法能得到全球唯一的一个值）<br>例如：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) ✗ printf git | sha1sum</span><br></pre></td></tr></table></figure><p></p><p>输出git的sha1sum算法的值</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;git对象（简单了解）&quot;&gt;&lt;a href=&quot;#git对象（简单了解）&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="git分布式版本控制系统权威指南学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="http://mmmmmm.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git分布式版本控制系统权威指南学习笔记（二）：git add暂存区的三个状态以及暂存区的理解</title>
    <link href="http://mmmmmm.me/2019-03-12-2.html"/>
    <id>http://mmmmmm.me/2019-03-12-2.html</id>
    <published>2019-03-12T02:21:02.000Z</published>
    <updated>2019-03-12T11:36:53.244Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="不经过git-add（到暂存区），能直接进行commit吗？"><a href="#不经过git-add（到暂存区），能直接进行commit吗？" class="headerlink" title="不经过git add（到暂存区），能直接进行commit吗？"></a>不经过git add（到暂存区），能直接进行commit吗？</h1><p>不能，有一种方法，建议忘掉。</p><h2 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) vi a.txt</span><br><span class="line">➜  demo git:(master) ✗ git commit -m <span class="string">"a"</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">modified:   a.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit</span><br><span class="line">➜  demo git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   a.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>代码中modified: a.txt是红色的，提交失败了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) ✗ git add .</span><br><span class="line">➜  demo git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">modified:   a.txt</span><br><span class="line">➜  demo git:(master) ✗ git commit -m <span class="string">"add "</span></span><br><span class="line">[master <span class="number">81</span>b09ec] add</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure><p>代码中modified: a.txt是绿色的，提交成功了</p><p>通过上面的例子说明modified:<br><strong><font color="red">a.txt是红色的代表没有git add，是绿色的代表，进行了git add 操作。<br></font></strong><br>当然可以通过</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) ✗ git commit -a -m ”add“</span><br></pre></td></tr></table></figure><p>便可以省去git add的操作，但是 <strong><font color="red">不建议，建议直接忘记 </font></strong>，因为直接略过了git add 操作，少了很多操作的可能，而且没有了git add的操作，像操作回溯就无法实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) ✗ git log</span><br><span class="line">commit <span class="number">81</span>b09ecc5f2f0222ede2b474efb1d8da9b04714e (HEAD -&gt; master)</span><br><span class="line">Author: dataiyangu &lt;<span class="number">32248827</span>@qq.com&gt;</span><br><span class="line"><span class="built_in">Date</span>:   Mon Mar <span class="number">11</span> <span class="number">12</span>:<span class="number">18</span>:<span class="number">24</span> <span class="number">2019</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    add</span><br><span class="line"></span><br><span class="line">commit <span class="number">1e20</span>fe7563a4b4bf8a091fe6c55ca9f32786224c</span><br><span class="line">Author: dataiyangu &lt;<span class="number">32248827</span>@qq.com&gt;</span><br><span class="line"><span class="built_in">Date</span>:   Mon Mar <span class="number">11</span> <span class="number">12</span>:<span class="number">15</span>:<span class="number">53</span> <span class="number">2019</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    a</span><br><span class="line"></span><br><span class="line">commit ed97a5e3d4ae753183e6a796625dfca1f83c1f61</span><br><span class="line">Author: dataiyangu &lt;<span class="number">32248827</span>@qq.com&gt;</span><br><span class="line"><span class="built_in">Date</span>:   Mon Mar <span class="number">11</span> <span class="number">08</span>:<span class="number">33</span>:<span class="number">11</span> <span class="number">2019</span> +<span class="number">0800</span></span><br></pre></td></tr></table></figure><p>通过git log查看三次commit的提交</p><h1 id="什么是head"><a href="#什么是head" class="headerlink" title="什么是head"></a>什么是head</h1><p>当前版本库的最后一次commit，默认master分支。</p><h1 id="git-add暂存区的三个状态"><a href="#git-add暂存区的三个状态" class="headerlink" title="git add暂存区的三个状态"></a>git add暂存区的三个状态</h1><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) vi a.txt</span><br><span class="line">➜  demo git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   a.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">➜  demo git:(master) ✗ git diff</span><br><span class="line">diff --git a/a.txt b/a.txt</span><br><span class="line">index <span class="number">9</span>c3645e..d16f5ff <span class="number">100644</span></span><br><span class="line">--- a/a.txt</span><br><span class="line">+++ b/a.txt</span><br><span class="line">@@ <span class="number">-1</span> +<span class="number">1</span> @@</span><br><span class="line">-dfasff:</span><br><span class="line">+dsdf:fasff:</span><br></pre></td></tr></table></figure><p>修改了a.txt后执行git diff，可以看到是在比较差异。<br>作者认为，上次提交之后，当前的工作区是干净的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) git checkout .</span><br><span class="line">➜  demo git:(master) git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">➜  demo git:(master) git diff</span><br></pre></td></tr></table></figure><p>git checkout . 撤销了上次修改文件的操作，回去刷新自己的a.txt文件，发现刚才做的改变没有了，然后执行git diff发现什么也没有</p><p>这里认为git diff就是已经被修改了的文件，但是没有被加到暂存区中文件内容的对比。</p><h2 id="git-diff-head"><a href="#git-diff-head" class="headerlink" title="git diff head"></a>git diff head</h2><p>workspace里面的文件和版本库里面是一样的，拿当前的改和版本库里面改和刚才的workspace和当前的修改对比其实是一样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master)  vi a.txt</span><br><span class="line">➜  demo git:(master) ✗ git diff head</span><br><span class="line">dfasff:</span><br><span class="line">diff --git a/a.txt b/a.txt</span><br><span class="line">index <span class="number">9</span>c3645e.<span class="number">.021</span>fcac <span class="number">100644</span></span><br><span class="line">--- a/a.txt</span><br><span class="line">+++ b/a.txt</span><br><span class="line">@@ <span class="number">-1</span> +<span class="number">1</span>,<span class="number">3</span> @@</span><br><span class="line"> dfasff:</span><br><span class="line">+</span><br><span class="line">+aaa</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>head是当前的一个游标，你切换到哪个分支，head就指向哪个分支，所以就是和head这个分支做对比<br>说实话上面讲的我自己都没有听懂，一篇写的不错的问章：<a href="https://blog.csdn.net/u013485584/article/details/53303858" target="_blank" rel="noopener">https://blog.csdn.net/u013485584/article/details/53303858</a></p><h2 id="git-diff-–cached"><a href="#git-diff-–cached" class="headerlink" title="git diff –cached"></a>git diff –cached</h2><p>暂存区和head对比</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>git diff head</td><td>工作区和head对比</td></tr><tr><td>git diff –cached</td><td>暂存区和head对比</td></tr></tbody></table><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout ."></a>git checkout .</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure><p>在当前的状态下做了一些修改，想回退回去， <strong><font color="red">前提是没有进行git add 操作</font></strong></p><h2 id="M在第一列和第二列不同的含义"><a href="#M在第一列和第二列不同的含义" class="headerlink" title="M在第一列和第二列不同的含义"></a>M在第一列和第二列不同的含义</h2><table><thead><tr><th>第n列</th><th>含义</th></tr></thead><tbody><tr><td>M 第一列字符含义</td><td>版本库和处理中间状态有差异</td></tr><tr><td>M 第二列字符含义</td><td>工作区和当前文件有差异</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) ✗ vi a.txt</span><br><span class="line">➜  demo git:(master) ✗ git add .</span><br><span class="line">➜  demo git:(master) ✗ vi a.txt</span><br><span class="line">➜  demo git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">modified:   a.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   a.txt</span><br><span class="line"></span><br><span class="line">➜  demo git:(master) ✗ git status -s</span><br><span class="line">MM a.txt</span><br><span class="line">➜  demo git:(master) ✗</span><br></pre></td></tr></table></figure><p>上述代码中的git status 第一个modified: a.txt 绿色，第二个modified: a.txt 红色<br>git status -s 第一列M是绿色，第二列M是红色</p><p>两次修改a.txt，第一次git add ，第二次没有进行git add</p><p>利用上面的这个特性可以：<br>开发代码完了之后<code>git add .</code> ，之后希望加一些log日志进行test，但是不希望最后把这些log日志的语句加到最后的项目中，所以可以<code>git chckout .</code> ，就回退到了<code>git add .</code>完了的时候，即往代码中加log的时候。</p><h2 id="git-reset-head-a-txt"><a href="#git-reset-head-a-txt" class="headerlink" title="git reset head a.txt"></a>git reset head a.txt</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) ✗ vi a.txt</span><br><span class="line">➜  demo git:(master) ✗ git add .</span><br><span class="line">➜  demo git:(master) ✗ git reset head a.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">Ma.txt</span><br><span class="line">➜  demo git:(master) ✗ git st</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   a.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">➜  demo git:(master) ✗</span><br><span class="line">➜  demo git:(master) ✗ git checkout a.txt</span><br><span class="line">➜  demo git:(master) git st</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">➜  demo git:(master)</span><br></pre></td></tr></table></figure><p>上面说到如果代码没有被<code>git add .</code>可以通过 <code>git checkout .</code>进行回退，将修改的文件从workspace<br>如果代码已经被<code>git add .</code>可，可以通过<code>git reset head filename</code>回退，将修改的文件从缓存区中回退<br>完了之后再运行<code>git chekcout a.txt</code>，文件最终回退到没有被修改的过程，将文件从workspace回退</p><h1 id="理解暂存区"><a href="#理解暂存区" class="headerlink" title="理解暂存区"></a>理解暂存区</h1><h2 id="举个🌰-git-stash、git-stash-pop"><a href="#举个🌰-git-stash、git-stash-pop" class="headerlink" title="举个🌰(git stash、git stash pop)"></a>举个🌰(git stash、git stash pop)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) vi a.txt</span><br><span class="line">➜  demo git:(master) ✗ git checkout -b b</span><br><span class="line">Ma.txt</span><br><span class="line">Switched to a <span class="keyword">new</span> branch <span class="string">'b'</span></span><br><span class="line">➜  demo git:(b) ✗ ls</span><br><span class="line">a.txt</span><br><span class="line">➜  demo git:(b) ✗ git status</span><br><span class="line">On branch b</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   a.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>一个经常犯的错误<br>加入当前在dev分支修改了a.txt但是没有<code>git add</code>，这个时候checkout到了master分支， <strong><font color="red">这个时候发现在master分支也有了a.txt，并且里面做的改变也跟着过去， </font></strong>并且没有提交，刚才的这个a.txt现在就是一个游离的状态，谁也不属于谁，可是你又不想提交，又不想切换，这个时候就需要<code>git stash</code>这个命令，会将当前做的修改做一个临时的存储，就像看电影一样，看了一会，先暂停一下，去上个厕所，回来接着看。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) ✗ vi a.txt</span><br><span class="line">➜  demo git:(master) ✗ git stash</span><br><span class="line">Saved working directory and index state WIP on master: <span class="number">81</span>b09ec add</span><br><span class="line">➜  demo git:(master) git co b</span><br><span class="line">Switched to branch <span class="string">'b'</span></span><br><span class="line">➜  demo git:(b) cat a.txt</span><br><span class="line">dfasff:</span><br><span class="line">➜  demo git:(b) git co master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">➜  demo git:(master) git stash pop</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   a.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">Dropped refs/stash@&#123;<span class="number">0</span>&#125; (f56b964ed9dd46735f383a6c3c93e289cad6bb00)</span><br><span class="line">➜  demo git:(master) ✗ cat a.txt</span><br><span class="line">sdaf</span><br><span class="line">dasf</span><br><span class="line">sdaf:</span><br></pre></td></tr></table></figure><p>git stash就是在即将切换到另一个分支的时候不想git add，但是不希望自己的改变跟着到了另一个分支 ，<strong><font color="red"> 注意:git stash 后文件还是会跟着过去，但是里面做的修改是没有跟着过去的</font></strong>，这个时候到了另一个分支，做自己的事情，做完之后，切换回刚才的分支，通过 git stash pop 就能切换回，切换分支前没有提交而保存了的那个状态了，就像看电影的暂停。</p><h2 id="理解暂存区-1"><a href="#理解暂存区-1" class="headerlink" title="理解暂存区"></a>理解暂存区</h2><p>像git status等一些其他的命令就是通过扫描文件改变的时间戳长度等信息来判断是否被修改了，而不是通过传统的查看文件是否被修改，这样肯定比传统的方式速度有一定的提升。<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312192313400.png"><br>左侧是工作区，右侧是版本库<br>右侧中的index是暂存区也叫stage，master是目录树，objects所有被修改的对象</p><p>当工作区的文件进行了修改，做<code>git add</code>命令时，暂存区的目录树被更新了，所有被<code>git add</code>的文件都会被写入到object对象库中，这时候对象也是一个游离的对象，不能确定是属于index还是master，因为没有被提交所以不是隶属于master，也不一定会在index中，因为可能会被撤销，当执行提交的时候，暂存区中的目录树会被写入到对象库中，master分支会做一个相应的更新，master最新的目录树就会指向暂存区里面的目录树。</p><p>如果已经加入了暂存区中，但是不想要这个修改，可以执行<code>git reset head filename</code>命令，暂存区的目录树会被重写，重写的依据会被master分支的目录所替换，这个时候工作区并不受影响，包括 <code>git rm --cached file</code>会将文件从暂存区里面删除掉，删除的时候只是在暂存区中删的，并没有将工作区的文件删掉。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;不经过git-add（到暂存区），能直接进行commit吗？&quot;&gt;&lt;a href=&quot;#不经过git-add（到暂存区
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="git分布式版本控制系统权威指南学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="http://mmmmmm.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git分布式版本控制系统权威指南学习笔记（一）：配置文件、简单流程和小问题</title>
    <link href="http://mmmmmm.me/2019-03-12-1.html"/>
    <id>http://mmmmmm.me/2019-03-12-1.html</id>
    <published>2019-03-12T02:21:01.000Z</published>
    <updated>2019-03-12T13:40:15.140Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="git配置文件简介"><a href="#git配置文件简介" class="headerlink" title="git配置文件简介"></a>git配置文件简介</h1><p>一. 配置文件的存储位置<br>Git相关的配置文件有三个</p><ol><li><p>/etc/gitconfig：包含了适用于系统所有用户和所有项目的值。</p></li><li><p>~/.gitconfig：只适用于当前登录用户的配置。</p></li><li><p>位于git项目目录中的.git/config：适用于特定git项目的配置。</p></li></ol><p>对于同一配置项，三个配置文件的优先级是1&lt;2&lt;3</p><p>~/.gitconfig:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户信息</span></span><br><span class="line">[user]</span><br><span class="line">name = xxx</span><br><span class="line">email  = xxx</span><br><span class="line"><span class="comment">//为git输出着色</span></span><br><span class="line">[color]</span><br><span class="line">diff = auto</span><br><span class="line">status = auto</span><br><span class="line">branch = auto </span><br><span class="line">interactive = <span class="literal">true</span></span><br><span class="line">ui = <span class="literal">true</span></span><br><span class="line"><span class="comment">//为git命令配置别名</span></span><br><span class="line">[alias]  </span><br><span class="line">    st = status  </span><br><span class="line">    ci = commit  </span><br><span class="line">    br = branch   </span><br><span class="line"><span class="comment">//core.filemode 让git忽略对文件权限的修改</span></span><br><span class="line">[core]  </span><br><span class="line">    filemode = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p></p><h2 id="git-config各种命令"><a href="#git-config各种命令" class="headerlink" title="git config各种命令"></a>git config各种命令</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) git config</span><br><span class="line">usage: git config [<span class="xml"><span class="tag">&lt;<span class="name">options</span>&gt;</span>]</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">Config file location</span></span><br><span class="line"><span class="xml">    --global              use global config file</span></span><br><span class="line"><span class="xml">    --system              use system config file</span></span><br><span class="line"><span class="xml">    --local               use repository config file</span></span><br><span class="line"><span class="xml">    --worktree            use per-worktree config file</span></span><br><span class="line">    -f, --file &lt;file&gt;     use given config file</span><br><span class="line">    --blob &lt;blob-id&gt;      read config from given blob object</span><br><span class="line"></span><br><span class="line">Action</span><br><span class="line">    --get                 get value: name [value-regex]</span><br><span class="line">    --get-all             get all values: key [value-regex]</span><br><span class="line">    --get-regexp          get values for regexp: name-regex [value-regex]</span><br><span class="line">    --get-urlmatch        get value specific for the URL: section[.var] URL</span><br><span class="line">    --replace-all         replace all matching variables: name value [value_regex]</span><br><span class="line">    --add                 add a new variable: name value</span><br><span class="line">    --unset               remove a variable: name [value-regex]</span><br><span class="line">    --unset-all           remove all matches: name [value-regex]</span><br><span class="line">    --rename-section      rename section: old-name new-name</span><br><span class="line">    --remove-section      remove a section: name</span><br><span class="line">    -l, --list            list all</span><br><span class="line">    -e, --edit            open an editor</span><br><span class="line">    --get-color           find the color configured: slot [default]</span><br><span class="line">    --get-colorbool       find the color setting: slot [stdout-is-tty]</span><br><span class="line"></span><br><span class="line">Type</span><br><span class="line">    -t, --type &lt;&gt;         value is given this type</span><br><span class="line">    --bool                value is "true" or "false"</span><br><span class="line">    --int                 value is decimal number</span><br><span class="line">    --bool-or-int         value is --bool or --int</span><br><span class="line">    --path                value is a path (file or directory name)</span><br><span class="line">    --expiry-date         value is an expiry date</span><br><span class="line"></span><br><span class="line">Other</span><br><span class="line">    -z, --null            terminate values with NUL byte</span><br><span class="line">    --name-only           show variable names only</span><br><span class="line">    --includes            respect include directives on lookup</span><br><span class="line">    --show-origin         show origin of config (file, standard input, blob, command line)</span><br><span class="line">    --default &lt;value&gt;     with --get, use default value when missing entry</span><br></pre></td></tr></table></figure><h3 id="配置级别："><a href="#配置级别：" class="headerlink" title="配置级别："></a>配置级别：</h3><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>–global</td><td>use global config file 全局级别，用户级别</td></tr><tr><td>–system</td><td>use system config file 系统级别</td></tr><tr><td>–local</td><td>use repository config file 当前项目级别</td></tr></tbody></table><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"John Doe"</span></span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure><p>如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>接下来要设置的是默认使用的文本编辑器。Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.editor emacs</span><br></pre></td></tr></table></figure><h4 id="差异分析工具"><a href="#差异分析工具" class="headerlink" title="差异分析工具"></a>差异分析工具</h4><p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global merge.tool vimdiff</span><br></pre></td></tr></table></figure><p>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。当然，你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章。</p><h3 id="配置命令别名"><a href="#配置命令别名" class="headerlink" title="配置命令别名"></a>配置命令别名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure><h1 id="公钥"><a href="#公钥" class="headerlink" title="公钥"></a>公钥</h1><p>每次提交代码都是通过公钥提交的<br>.ssh/id_ras<br>公钥最好备份一份，避免每次换操作系统都要去生成，人户在git上更新。</p><h1 id="git协同流程"><a href="#git协同流程" class="headerlink" title="git协同流程"></a>git协同流程</h1><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-2389695.png"><br>上图中右边为公司内网的仓库，左边是三个开发人员对应的本地环境，每个环境对应两条线，上面的线是本地分支，下面的线是master远程分支。<br>每个人从远端拉取配置下来进行开发，D1先开发完之后push到远端，D1的本地分支和远端分支长度变为了2，这时候D2、D3对应的master分支还只有长度1，所以D2想要push代码的时候应该首先让自己的master分支变为长度变为2，然后进行merge，merge之后master变成了长度3，再进行push。</p><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312192135422.png"><br>home dev是个人开发环境<br>dev repo是本地开发环境 ：master分支开发完之后，开一个测试分支test，供测试人员测试，测试完之后交给产品分支pro，每次提交给产品分支后会自动同步到上图中的remote repo 远程生产环境<br>remote repo是远程生产环境：远程的linux服务器，首次通过git clone 将代码clone到本地，之后可以通过git fetch/git merge操作，然后运行mvn war：war，将项目打包，之后通过shell脚本直接推送到tomcat服务器上面</p><p>尚存在的问题：<br>如果出现紧急bug怎么办呢？不能从右边起手，开发==》测试==》产品吧？应该直接去生产环境修改代码，运行，之后怎样让开发环境同步代码和生产环境一样呢？将生产环境代码同步到pro产品分支，之后通过产品分支merge给master和test分支。</p><h1 id="简单流程"><a href="#简单流程" class="headerlink" title="简单流程"></a>简单流程</h1><h2 id="初始化版本库"><a href="#初始化版本库" class="headerlink" title="初始化版本库"></a>初始化版本库</h2><p>在1.5.x之前是需要初始化版本库的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  test git init demo</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/leesin/Desktop/test/demo/.git/</span><br><span class="line"><span class="comment">//以后所有的版本就在.git目录里面存着</span></span><br><span class="line">➜  demo git:(master) ls -a</span><br><span class="line">.    ..   .git</span><br><span class="line">➜  demo git:(master) cd .git</span><br><span class="line">➜  .git git:(master) ls -a</span><br><span class="line">.           ..          HEAD        config      description hooks       info        objects     refs</span><br></pre></td></tr></table></figure><h2 id="提交至缓存区"><a href="#提交至缓存区" class="headerlink" title="提交至缓存区"></a>提交至缓存区</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:git add xxx</span><br></pre></td></tr></table></figure><h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git rm --cached &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> file:   a.txt</span><br></pre></td></tr></table></figure><h2 id="提交分支"><a href="#提交分支" class="headerlink" title="提交分支"></a>提交分支</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) ✗ git commit -m <span class="string">"my once"</span></span><br><span class="line">[master (root-commit) ed97a5e] my once</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span><br><span class="line"> create mode <span class="number">100644</span> a.txt</span><br></pre></td></tr></table></figure><h2 id="查看状态-1"><a href="#查看状态-1" class="headerlink" title="查看状态"></a>查看状态</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h1 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h1><h2 id="git是如何找到自己的-git文件的"><a href="#git是如何找到自己的-git文件的" class="headerlink" title="git是如何找到自己的.git文件的"></a>git是如何找到自己的.git文件的</h2><p>发现加入我的目录是<br>/~/Desktop/test/gitDemo<br>首先在gitDemo中git init 出现了.git文件，进入gitDemo中的某个文件b，执行git status，显示的都是gitDemo的这个版本库的信息<br>在gitDemo的外层（test）目录执行git init，在test目录下也会出现一个.git文件，哪个同样进入gitDemo的某个文件b，这个时候现实的还是gitDemo这个版本库的信息</p><p>因为寻找.git的方法是通过递归往上寻找离自己最近的版本库信息。</p><h2 id="git随意设置并提交名是否安全"><a href="#git随意设置并提交名是否安全" class="headerlink" title="git随意设置并提交名是否安全"></a>git随意设置并提交名是否安全</h2><p>安全，可以，但是如果是开发环境的话，因为公钥是通过提交名邮箱设置的，随意设置可能提交不上去。</p><h2 id="命令别名的作用"><a href="#命令别名的作用" class="headerlink" title="命令别名的作用"></a>命令别名的作用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git st</span><br></pre></td></tr></table></figure><p>配置了之后，上面是等价的</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;git配置文件简介&quot;&gt;&lt;a href=&quot;#git配置文件简介&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="git分布式版本控制系统权威指南学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="http://mmmmmm.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>基于Netty的RPC架构学习笔记（十二）：借助spring实现业务分离、聊天室小项目、netty3和4、5的不同、业务线程池以及消息串行化</title>
    <link href="http://mmmmmm.me/2019-03-10-12.html"/>
    <id>http://mmmmmm.me/2019-03-10-12.html</id>
    <published>2019-03-10T02:21:12.000Z</published>
    <updated>2019-03-12T12:37:53.465Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="借助spring实现业务分离（🌰）"><a href="#借助spring实现业务分离（🌰）" class="headerlink" title="借助spring实现业务分离（🌰）"></a>借助spring实现业务分离（🌰）</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>之前的文章中的handler每次都需要判断如果是moudle=？然后如果cmd=？，才进行我们的业务，这里希望能够通过某种方法实现自动执行moudle=？cmd=？时候的方法，从而实现业务分离。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;</span><br><span class="line"><span class="comment">//修改为response对象</span></span><br><span class="line">Response message = (Response)e.getMessage();</span><br><span class="line"><span class="keyword">if</span>(message.getModule() == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(message.getCmd() == <span class="number">1</span>)&#123;</span><br><span class="line">。。。</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(message.getCmd() == <span class="number">2</span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (message.getModule() == <span class="number">1</span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>下面是一个通过spring实现业务分离的🌰</p><h2 id="SocketMoudle-interface"><a href="#SocketMoudle-interface" class="headerlink" title="SocketMoudle(interface)"></a>SocketMoudle(interface)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SocketMoudle(moudle=<span class="number">1</span>)</span><br><span class="line">public interface UserService &#123;</span><br><span class="line">@SocketCmd(cmd=<span class="number">1</span>)</span><br><span class="line">public <span class="keyword">void</span> login();</span><br><span class="line">@SocketCmd(cmd=<span class="number">2</span>)</span><br><span class="line">public <span class="keyword">void</span> getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Scanner-java"><a href="#Scanner-java" class="headerlink" title="Scanner.java"></a>Scanner.java</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Scanner</span> <span class="title">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">@Override</span><br><span class="line">public <span class="built_in">Object</span> postProcessBeforeInitialization(<span class="built_in">Object</span> bean, <span class="built_in">String</span> beanName) throws BeansException &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public <span class="built_in">Object</span> postProcessAfterInitialization(<span class="built_in">Object</span> bean, <span class="built_in">String</span> beanName) throws BeansException &#123;</span><br><span class="line">Class&lt;? extends <span class="built_in">Object</span>&gt; clazz = bean.getClass();</span><br><span class="line">Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line"><span class="keyword">if</span>(interfaces != <span class="literal">null</span> &amp;&amp; interfaces.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//扫描类的所有接口父类</span></span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; interFace : interfaces) &#123;</span><br><span class="line"><span class="comment">//判断是否为handler接口类</span></span><br><span class="line"><span class="comment">//getAnnotation获得interface中注解名字为SocketModule的注解对象</span></span><br><span class="line">SocketModule socketModule = interFace.getAnnotation(SocketModule.class);</span><br><span class="line"><span class="keyword">if</span> (socketModule == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出命令方法</span></span><br><span class="line">Method[] methods = interFace.getMethods();</span><br><span class="line"><span class="keyword">if</span>(methods != <span class="literal">null</span> &amp;&amp; methods.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line"><span class="comment">//getAnnotation获得method中注解名字为SocketCmd的注解对象</span></span><br><span class="line">SocketCmd socketCmd = method.getAnnotation(SocketCmd.class);</span><br><span class="line"><span class="keyword">if</span>(socketCmd == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得注解里面的moudle值</span></span><br><span class="line">final short <span class="built_in">module</span> = socketModule.module();</span><br><span class="line"><span class="comment">//获得注解里面的cmd值</span></span><br><span class="line">final short cmd = socketCmd.cmd();</span><br><span class="line"><span class="comment">//InvokerHolder、Invoker在下面，对invoke进行了封装</span></span><br><span class="line"><span class="keyword">if</span>(InvokerHoler.getInvoker(<span class="built_in">module</span>, cmd) == <span class="literal">null</span>)&#123;</span><br><span class="line">InvokerHoler.addInvoker(<span class="built_in">module</span>, cmd, Invoker.valueOf(method, bean));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"重复命令:"</span>+<span class="string">"module:"</span>+<span class="built_in">module</span> +<span class="string">" "</span>+<span class="string">"cmd："</span> + cmd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Invoker.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">private Method method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">private <span class="built_in">Object</span> target;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> Invoker valueOf(Method method, <span class="built_in">Object</span> target)&#123;</span><br><span class="line">Invoker invoker = <span class="keyword">new</span> Invoker();</span><br><span class="line">invoker.setMethod(method);</span><br><span class="line">invoker.setTarget(target);</span><br><span class="line"><span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行</span></span><br><span class="line"><span class="comment"> * @param paramValues</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> * @throws InvocationTargetException </span></span><br><span class="line"><span class="comment"> * @throws IllegalArgumentException </span></span><br><span class="line"><span class="comment"> * @throws IllegalAccessException </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="built_in">Object</span> invoke(<span class="built_in">Object</span>... paramValues)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> method.invoke(target, paramValues);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Method getMethod() &#123;</span><br><span class="line"><span class="keyword">return</span> method;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> setMethod(Method method) &#123;</span><br><span class="line"><span class="keyword">this</span>.method = method;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="built_in">Object</span> getTarget() &#123;</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> setTarget(<span class="built_in">Object</span> target) &#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InvokerHodler.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InvokerHoler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**命令调用器*/</span></span><br><span class="line">    private <span class="keyword">static</span> <span class="built_in">Map</span>&lt;Short, <span class="built_in">Map</span>&lt;Short, Invoker&gt;&gt; invokers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加命令调用</span></span><br><span class="line"><span class="comment">     * @param module</span></span><br><span class="line"><span class="comment">     * @param cmd</span></span><br><span class="line"><span class="comment">     * @param invoker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> addInvoker(short <span class="built_in">module</span>, short cmd, Invoker invoker)&#123;</span><br><span class="line">    <span class="built_in">Map</span>&lt;Short, Invoker&gt; map = invokers.get(<span class="built_in">module</span>);</span><br><span class="line">    <span class="keyword">if</span>(map == <span class="literal">null</span>)&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    invokers.put(<span class="built_in">module</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(cmd, invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取命令调用</span></span><br><span class="line"><span class="comment">     * @param module</span></span><br><span class="line"><span class="comment">     * @param cmd</span></span><br><span class="line"><span class="comment">     * @param invoker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="keyword">static</span> Invoker getInvoker(short <span class="built_in">module</span>, short cmd)&#123;</span><br><span class="line">    <span class="built_in">Map</span>&lt;Short, Invoker&gt; map = invokers.get(<span class="built_in">module</span>);</span><br><span class="line">    <span class="keyword">if</span>(map != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将Scanner交给spring处理，这样，就可以通过注解实现业务分离。</p><h1 id="聊天室项目"><a href="#聊天室项目" class="headerlink" title="聊天室项目"></a>聊天室项目</h1><p>聊天室功能：多个客户端能够在类似qq群里聊天，某个用户能够指定角色几可以收到消息，如果角色在另一个客户端被登录，会被挤下线。<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312195922562.png"></p><h1 id="netty3和4、5的不同"><a href="#netty3和4、5的不同" class="headerlink" title="netty3和4、5的不同"></a>netty3和4、5的不同</h1><table><thead><tr><th style="text-align:center">作用</th><th>netty3</th><th>netty4/5</th></tr></thead><tbody><tr><td style="text-align:center">判断是否连接</td><td>channel.isConnected</td><td>channel.isActive</td></tr><tr><td style="text-align:center">发送数据</td><td>write</td><td>writeAndFlush</td></tr><tr><td style="text-align:center">绑定</td><td>getAttachement、setAttachement、removeAttachement</td><td>channe.attr(ATTACHMENT_KEY).set(attachement)/get()/remove()</td></tr><tr><td style="text-align:center">写数据（里面的方法一样，只是对象名字变了）</td><td>ChannelBuffer</td><td>ByteBuf</td></tr><tr><td style="text-align:center">new一个channel</td><td>ChannelBuffers.dynamicBuffer()</td><td>PooledByteBufAllocator一个内存申请器(要注意使用完后释放buffer)release（）释放或UnpooledByteBufAllocator（最好也进行一次释放）或Unpooled（底层走的是UnpooledByteBufAllocator） 注意申请一次，就只能释放一次 ——-当然netty封装消息的bytebuf用的是UnpooledByteBufAllocator，可以通过new ServerBootstrap().childOption(channelOption.ALLOCATOR,PooledByteBufAllocator.DEFAULT);还有：decode方法中传入的buffer是netty帮我们创建的，decode方法上层自动判断如果缓存（cumulation）中没有了数据就会自动释放。继承自SimpleChannelInbundHandler的handler顶层也会自动释放</td></tr><tr><td style="text-align:center">协助我们解决粘包分包的问题（里面实现的原理差不多，只是改了名字）解码器</td><td>FrameDecoder</td><td>ByteToMessageDecoder</td></tr><tr><td style="text-align:center">编码器</td><td>OneToOneEncoder</td><td>MessageToByteEncoder</td></tr><tr><td style="text-align:center">接收消息</td><td>messageReceive</td><td>channelRead0(netty5里面是messageReceive)</td></tr></tbody></table><h1 id="业务线程池"><a href="#业务线程池" class="headerlink" title="业务线程池"></a>业务线程池</h1><p>前面讲到抽象的例子，boss和worker分别是餐厅的服务员，负责的是帮客人点菜，可是点完菜之后做菜的过程么？做菜的过程就是业务，是不能交给服务员（boos和worker来做的），否则效率大打折扣。厨师应该有多个，a顾客要的才厨师1来做，剩下还有多个厨师，不影响其他顾客的正常消费。<br>上面例子中整个厨师团队就是业务线程池。</p><p>注意：如果不作处理的话，业务是在worker线程中的</p><h2 id="netty3中解决方法"><a href="#netty3中解决方法" class="headerlink" title="netty3中解决方法"></a>netty3中解决方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HiHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelHandler</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> ExecutorService executorService = Executors.newFixedTHeradPool(Runtime.getRuntime().availableProcessors()*<span class="number">2</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;</span><br><span class="line"><span class="comment">//修改为response对象</span></span><br><span class="line">Response message = (Response)e.getMessage();</span><br><span class="line">RUnnavle task  = handlerMessage(<span class="keyword">new</span> SessionImpl(ctx.getChannel()),request);</span><br><span class="line">executorService.execute(task);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public Runnavle handlerMessage(final Session session,final Request request)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"><span class="comment">//此处省略业务处理的过程，自行脑补</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br>如果不自己将业务进行异步的话，netty其实是一个同步的过程（虽然netty被叫做异步）。<br>业务中回写数据也默认是异步的，因为在前面的源码介绍中有介绍，AbstractNioSelector.java中的run方法里面有 processTaskQueue();就是讲write回写的数据封装到了队列中，供异步调用。</p><h2 id="netty4、netty5中的解决方法"><a href="#netty4、netty5中的解决方法" class="headerlink" title="netty4、netty5中的解决方法"></a>netty4、netty5中的解决方法</h2><p>不需要自己new一个线程池<br>Server.java(server中)<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line"><span class="comment">//服务类</span></span><br><span class="line">ClientBootstrap bootstrap = <span class="keyword">new</span>  ClientBootstrap();</span><br><span class="line"><span class="comment">//线程池</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span>.NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span>.NioEventLoopGroup();</span><br><span class="line"><span class="comment">//业务线程池</span></span><br><span class="line">EventLoopGroup busyGroup = <span class="keyword">new</span>.NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ResponseDecoder());</span><br><span class="line">ch.pipeline.addLast(<span class="keyword">new</span> RequestEncoder());</span><br><span class="line">ch.pipeline.addLast(busyGroup,<span class="keyword">new</span> HiHandler());</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p></p><p>这里只需要</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup busyGroup = <span class="keyword">new</span>.NioEventLoopGroup();</span><br><span class="line">ch.pipeline.addLast(busyGroup,<span class="keyword">new</span> HiHandler());<span class="comment">//在new HiHandler（）前面加入busyGroup参数</span></span><br></pre></td></tr></table></figure><p>原本的handler就不是再worker中运行了，变成了在上面的线程池循环组中运行</p><p>如果不加入这个参数，HiHandler和RequestEncoder是在一个线程中的（worker）<br>加入之后两个handler就不在一个线程中了。</p><p><strong><font color="red">注意： netty4、netty5中的这种方法比netty3要好</font></strong><br>因为在EventLoopGroup具有消息串行化的功能</p><h2 id="什么是消息串行化？"><a href="#什么是消息串行化？" class="headerlink" title="什么是消息串行化？"></a>什么是消息串行化？</h2><p>举个🌰：<br>假如a和b同时在打游戏<br>a发出指令1-1，要求锁定自己的账号，b也发出指令2-1，要求锁定a的账号，两者之间存在锁竞争是正常的。<br>可是如果a自己发出了5条1-1的指令，即连续要求锁定自己五次，五次请求同时进行，就会自己跟自己竞争。<br>一旦有了锁的竞争，就会十分影响效率</p><p>消息串行化就是请求一个一个执行</p><p>所以在netty3中需要自己实现编写可以实现有序的请求的处理线程，但是在netty4，netty5中EventLoopGroup具有消息串行化的功能。</p><p>具体实现可以开启多个线程，线程中存储着队列，将a和b的请求分别放到自己对应的线程中的队列中去，通过队列去执行，达到消息的串行化。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;借助spring实现业务分离（🌰）&quot;&gt;&lt;a href=&quot;#借助spring实现业务分离（🌰）&quot; class=&quot;
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基于Netty的RPC架构学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84RPC%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Netty" scheme="http://mmmmmm.me/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>基于Netty的RPC架构学习笔记（十一）：粘包、分包分析，如何避免socket攻击</title>
    <link href="http://mmmmmm.me/2019-03-10-11.html"/>
    <id>http://mmmmmm.me/2019-03-10-11.html</id>
    <published>2019-03-10T02:21:11.000Z</published>
    <updated>2019-03-12T11:58:56.025Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="消息如何在管道中流转"><a href="#消息如何在管道中流转" class="headerlink" title="消息如何在管道中流转"></a>消息如何在管道中流转</h2><p>当前的一个handler如何往下面的一个handler传递一个对象？<br>一个管道（pipeline）中会有多个handler<br>handler往下传递对象的方法是sendUpstream(event)</p><p>每个管道下面娥decoder、encoder其实最终都是继承了某个handler</p><p>当客户端发送消息到服务端以后netty会把这个消息对象封装成一个事件，把事件传递到管道里面，管道里面有很多handler,每次经过一个handler，就会出现一个新的事件，然后经过下一个handler，形成新的事件。<br>也没找到什么好的图解，感谢：<a href="https://www.cnblogs.com/chenmo-xpw/p/3938284.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenmo-xpw/p/3938284.html</a><br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312195850713.png"><br>上图中其实是将一个channelEvent即事件传入了channel中的pipeline，下面源码中详细介绍。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>进入</p><h3 id="AbstractNioSelector-java"><a href="#AbstractNioSelector-java" class="headerlink" title="AbstractNioSelector.java"></a>AbstractNioSelector.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">run()&#123;</span><br><span class="line">...</span><br><span class="line">    process(selector);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从process方法到</p><h3 id="AbstractNioWorker-java"><a href="#AbstractNioWorker-java" class="headerlink" title="AbstractNioWorker.java"></a>AbstractNioWorker.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process()&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!read(k)) &#123;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从read方法到</p><h3 id="NioWorker-java"><a href="#NioWorker-java" class="headerlink" title="NioWorker.java"></a>NioWorker.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">read(k)&#123;</span><br><span class="line"><span class="comment">//通过k得到channel</span></span><br><span class="line">final SocketChannel ch = (SocketChannel) k.channel();</span><br><span class="line">final NioSocketChannel channel = (NioSocketChannel) k.attachment();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">final ChannelBuffer buffer = bufferFactory.getBuffer(readBytes);</span><br><span class="line">    buffer.setBytes(<span class="number">0</span>, bb);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Fire the event.</span></span><br><span class="line">    fireMessageReceived(channel, buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从fireMessageReceived方法再进入fireMessageReceived方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> public <span class="keyword">static</span> <span class="keyword">void</span> fireMessageReceived(Channel channel, <span class="built_in">Object</span> message, SocketAddress remoteAddress) &#123;</span><br><span class="line"> <span class="comment">//从channel中获取一个管道，往管道中发送了一个sendUpstream事件</span></span><br><span class="line">        channel.getPipeline().sendUpstream(</span><br><span class="line">        <span class="comment">//new了一个UpstreamMessageEvent往管道中扔</span></span><br><span class="line">                <span class="keyword">new</span> UpstreamMessageEvent(channel, message, remoteAddress));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//上传的event</span></span><br><span class="line">  public <span class="keyword">void</span> sendUpstream(ChannelEvent e) &#123;</span><br><span class="line">  <span class="comment">//首先获取到一个DefaultChannelHandlerContext,在下面</span></span><br><span class="line">  <span class="comment">//head是头指针</span></span><br><span class="line">  <span class="comment">//getActualUpstreamContext方法在下面的DefualtChannelPipeline.java</span></span><br><span class="line">        DefaultChannelHandlerContext head = getActualUpstreamContext(<span class="keyword">this</span>.head);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        <span class="string">"The pipeline contains no upstream handlers; discarding: "</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//接着head里面接着send</span></span><br><span class="line"><span class="comment">//具体实现在DefaultChannelPipeline.java</span></span><br><span class="line">        sendUpstream(head, e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="DefaultChannelHandlerContext-java"><a href="#DefaultChannelHandlerContext-java" class="headerlink" title="DefaultChannelHandlerContext.java"></a>DefaultChannelHandlerContext.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private final <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelHandlerContext</span> <span class="title">implements</span> <span class="title">ChannelHandlerContext</span> </span>&#123;</span><br><span class="line"><span class="comment">//有next和prev来维护链表的关系。</span></span><br><span class="line">        volatile DefaultChannelHandlerContext next;</span><br><span class="line">        volatile DefaultChannelHandlerContext prev;</span><br><span class="line">        private final <span class="built_in">String</span> name;</span><br><span class="line">        <span class="comment">//就是前面的demo中的encodehandler和decodehandler</span></span><br><span class="line">        private final ChannelHandler handler;</span><br><span class="line">        private final boolean canHandleUpstream;</span><br><span class="line">        private final boolean canHandleDownstream;</span><br><span class="line">        private volatile <span class="built_in">Object</span> attachment;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是通过ChannelHandlerContext封装handler对象，让handler和handler之间有一个双向链表的关系</p><h3 id="DefualtChannelPipeline-java"><a href="#DefualtChannelPipeline-java" class="headerlink" title="DefualtChannelPipeline.java"></a>DefualtChannelPipeline.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private DefaultChannelHandlerContext getActualUpstreamContext(DefaultChannelHandlerContext ctx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DefaultChannelHandlerContext realCtx = ctx;</span><br><span class="line">        <span class="comment">//判断头指针是不是一个可以接受Upstream的handler</span></span><br><span class="line">        <span class="keyword">while</span> (!realCtx.canHandleUpstream()) &#123;</span><br><span class="line">        <span class="comment">//不是的话就往下找，找下一个可以接受Upstream的handler</span></span><br><span class="line">            realCtx = realCtx.next;</span><br><span class="line">            <span class="keyword">if</span> (realCtx == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> realCtx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> sendUpstream(DefaultChannelHandlerContext ctx, ChannelEvent e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//从head里面得到这些handler，然后调用这些handler的handleUpstream方法</span></span><br><span class="line">        <span class="comment">//这个方法是抽象方法，当前的类继承自SimpleChannelUpstreamHandler类，所以去这个类中看具体实现</span></span><br><span class="line">        <span class="comment">//SimpleChannelUpstreamHandler在下面</span></span><br><span class="line">            ((ChannelUpstreamHandler) ctx.getHandler()).handleUpstream(ctx, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyHandlerException(e, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们demo中的StringDecoder和Hellohandler是可以接受Upstream的，但是StringEncoder是不行的，因为implements ChannelDownstreamHandler，是一个下行的handler</p><h3 id="SimpleChannelUpstreamHandler-java"><a href="#SimpleChannelUpstreamHandler-java" class="headerlink" title="SimpleChannelUpstreamHandler.java"></a>SimpleChannelUpstreamHandler.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> handleUpstream(</span><br><span class="line">            ChannelHandlerContext ctx, ChannelEvent e) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> MessageEvent) &#123;</span><br><span class="line">        <span class="comment">//如果是MessageEvent，就执行messageReceived方法</span></span><br><span class="line">        <span class="comment">//public void messageReceived(</span></span><br><span class="line">        <span class="comment">//    ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;</span></span><br><span class="line">        <span class="comment">//调用完了之后接着调用sendUpstream方法</span></span><br><span class="line">        <span class="comment">// ctx.sendUpstream(e);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//public void sendUpstream(ChannelEvent e) &#123;</span></span><br><span class="line">          <span class="comment">//  DefaultChannelHandlerContext next = getActualUpstreamContext(this.next);</span></span><br><span class="line">         <span class="comment">//   if (next != null) &#123;</span></span><br><span class="line">         <span class="comment">//从当前节点往下找下一个可以处理sendUpstream的handler，继续传递e事件</span></span><br><span class="line">         <span class="comment">//       DefaultChannelPipeline.this.sendUpstream(next, e);</span></span><br><span class="line">          <span class="comment">//  &#125;</span></span><br><span class="line">       <span class="comment">// &#125;</span></span><br><span class="line">            messageReceived(ctx, (MessageEvent) e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> WriteCompletionEvent) &#123;</span><br><span class="line">            WriteCompletionEvent evt = (WriteCompletionEvent) e;</span><br><span class="line">            writeComplete(ctx, evt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ChildChannelStateEvent) &#123;</span><br><span class="line">            ChildChannelStateEvent evt = (ChildChannelStateEvent) e;</span><br><span class="line">            <span class="keyword">if</span> (evt.getChildChannel().isOpen()) &#123;</span><br><span class="line">                childChannelOpen(ctx, evt);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                childChannelClosed(ctx, evt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ChannelStateEvent) &#123;</span><br><span class="line">            ChannelStateEvent evt = (ChannelStateEvent) e;</span><br><span class="line">            <span class="keyword">switch</span> (evt.getState()) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPEN:</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Boolean</span>.TRUE.equals(evt.getValue())) &#123;</span><br><span class="line">                    channelOpen(ctx, evt);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    channelClosed(ctx, evt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">          ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上面这段代码知道<br><strong><font color="red">handler往下传递的一个方法是 sendUpstream ，应该继承SimpleChannelUpstreamHandler</font></strong></p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证上面的 handler往下传递的一个方法是 sendUpstream<br><strong><font color="red">自己定义handler。<br></font></strong></p><h3 id="Server-java"><a href="#Server-java" class="headerlink" title="Server.java"></a>Server.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelPipelineFactory;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.Channels;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">//服务类</span></span><br><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line"><span class="comment">//boss线程监听端口，worker线程负责数据读写</span></span><br><span class="line">ExecutorService boss = Executors.newCachedThreadPool();</span><br><span class="line">ExecutorService worker = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置niosocket工厂</span></span><br><span class="line">bootstrap.setFactory(<span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker));</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置管道的工厂</span></span><br><span class="line">bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ChannelPipeline getPipeline() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">pipeline.addLast(<span class="string">"handler1"</span>, <span class="keyword">new</span> MyHandler1());</span><br><span class="line">pipeline.addLast(<span class="string">"handler2"</span>, <span class="keyword">new</span> MyHandler2());</span><br><span class="line"><span class="keyword">return</span> pipeline;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">10101</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"start!!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Handler1-java"><a href="#Handler1-java" class="headerlink" title="Handler1.java"></a>Handler1.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffer;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.MessageEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.SimpleChannelHandler;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.UpstreamMessageEvent;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyHandler1</span> <span class="keyword">extends</span> <span class="title">SimpleChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">ChannelBuffer buffer = (ChannelBuffer)e.getMessage();</span><br><span class="line"></span><br><span class="line">byte[] array = buffer.array();</span><br><span class="line"><span class="built_in">String</span> message = <span class="keyword">new</span> <span class="built_in">String</span>(array);</span><br><span class="line">System.out.println(<span class="string">"handler1:"</span> + message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递</span></span><br><span class="line">ctx.sendUpstream(<span class="keyword">new</span> UpstreamMessageEvent(ctx.getChannel(), <span class="string">"abc"</span>, e.getRemoteAddress()));</span><br><span class="line">ctx.sendUpstream(<span class="keyword">new</span> UpstreamMessageEvent(ctx.getChannel(), <span class="string">"efg"</span>, e.getRemoteAddress()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Handler2-java"><a href="#Handler2-java" class="headerlink" title="Handler2.java"></a>Handler2.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.MessageEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.SimpleChannelHandler;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyHandler2</span> <span class="keyword">extends</span> <span class="title">SimpleChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> message = (<span class="built_in">String</span>)e.getMessage();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"handler2:"</span> + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client-java"><a href="#Client-java" class="headerlink" title="Client.java"></a>Client.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">10101</span>);</span><br><span class="line"></span><br><span class="line">socket.getOutputStream().write(<span class="string">"hello"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start！！！</span><br><span class="line">handler1：hello</span><br><span class="line">handler2：abc</span><br><span class="line">handler2：efg</span><br></pre></td></tr></table></figure><p>注意handler1中，通过如下代码向下传递</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递</span></span><br><span class="line">ctx.sendUpstream(<span class="keyword">new</span> UpstreamMessageEvent(ctx.getChannel(), <span class="string">"abc"</span>, e.getRemoteAddress()));</span><br><span class="line">ctx.sendUpstream(<span class="keyword">new</span> UpstreamMessageEvent(ctx.getChannel(), <span class="string">"efg"</span>, e.getRemoteAddress()));</span><br></pre></td></tr></table></figure><h1 id="观察粘包、分包现象，并进行处理。"><a href="#观察粘包、分包现象，并进行处理。" class="headerlink" title="观察粘包、分包现象，并进行处理。"></a>观察粘包、分包现象，并进行处理。</h1><p>粘包就是客户端分十次进行传递十个hello，可是客户端一次就输出了，所以不能判断是几次请求，相当于只处理了一次</p><h2 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h2><h3 id="Server-java-1"><a href="#Server-java-1" class="headerlink" title="Server.java"></a>Server.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelPipelineFactory;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.Channels;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">//服务类</span></span><br><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line"><span class="comment">//boss线程监听端口，worker线程负责数据读写</span></span><br><span class="line">ExecutorService boss = Executors.newCachedThreadPool();</span><br><span class="line">ExecutorService worker = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置niosocket工厂</span></span><br><span class="line">bootstrap.setFactory(<span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker));</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置管道的工厂</span></span><br><span class="line">bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ChannelPipeline getPipeline() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line"><span class="comment">//pipeline.addLast("decoder", new MyDecoder());</span></span><br><span class="line">pipeline.addLast(<span class="string">"handler1"</span>, <span class="keyword">new</span> HelloHandler());</span><br><span class="line"><span class="keyword">return</span> pipeline;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">10101</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"start!!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HelloHandler-java"><a href="#HelloHandler-java" class="headerlink" title="HelloHandler.java"></a>HelloHandler.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.MessageEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.SimpleChannelHandler;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HelloHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">ChannelBuffer message = (ChannelBuffer)e.getMessage();</span><br><span class="line">byte[] array = message.arrage();</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="built_in">String</span> (array))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client-java-1"><a href="#Client-java-1" class="headerlink" title="Client.java"></a>Client.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">10101</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> message = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">byte[] bytes = message.getBytes();</span><br><span class="line"></span><br><span class="line"><span class="comment">//ByteBuffer buffer = ByteBuffer.allocate(4 + bytes.length);</span></span><br><span class="line"><span class="comment">//buffer.putInt(bytes.length);</span></span><br><span class="line"><span class="comment">//buffer.put(bytes);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//byte[] array = buffer.array();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for(int i=0; i&lt;1000; i++)&#123;</span></span><br><span class="line"><span class="comment">//socket.getOutputStream().write(array);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">socket.getOutputStream().write(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start!!!</span><br><span class="line">hellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohell</span><br><span class="line">ohellohellohellohellohellohellohellohellohellohellohellohe</span><br><span class="line">llohellohellohellohellohellohellohello</span><br><span class="line">hellohellohellohellohello</span><br></pre></td></tr></table></figure><p>如图将很多请求当做一次请求输出，就是粘包，后面几行的行首不是he开头的，就是而是上一行的行尾和本行行首分开了，就是分包</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>定义一个稳定的结构 length + hello</p><h3 id="MyDecoder-java"><a href="#MyDecoder-java" class="headerlink" title="MyDecoder.java"></a>MyDecoder.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffer;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.frame.FrameDecoder;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyDecoder</span> <span class="keyword">extends</span> <span class="title">FrameDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected <span class="built_in">Object</span> decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer.readableBytes() &gt; <span class="number">4</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这段代码是为了防止字节流攻击，本文的下面小节中会讲到</span></span><br><span class="line"><span class="keyword">if</span>(buffer.readableBytes() &gt; <span class="number">2048</span>)&#123;</span><br><span class="line">buffer.skipBytes(buffer.readableBytes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//标记</span></span><br><span class="line">buffer.markReaderIndex();</span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">int length = buffer.readInt();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer.readableBytes() &lt; length)&#123;</span><br><span class="line">buffer.resetReaderIndex();</span><br><span class="line"><span class="comment">//缓存当前剩余的buffer数据，等待剩下数据包到来</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读数据</span></span><br><span class="line">byte[] bytes = <span class="keyword">new</span> byte[length];</span><br><span class="line">buffer.readBytes(bytes);</span><br><span class="line"><span class="comment">//往下传递对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">String</span>(bytes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓存当前剩余的buffer数据，等待剩下数据包到来</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>1、为什么FrameDecoder return的对象就是往下传递的对象</p><p>2、buffer里面数据未被读取完怎么办？</p><p>3、为什么return null就可以缓存buffer</p><p>会在本文章的下面的小节中解答</p><h3 id="HelloHandler-java-1"><a href="#HelloHandler-java-1" class="headerlink" title="HelloHandler.java"></a>HelloHandler.java</h3><p>上面的HelloHandler修改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.MessageEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.SimpleChannelHandler;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HelloHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//为了确定是不是一次一次的请求过来的，</span></span><br><span class="line"><span class="comment">//因为pipeline中处理handler的时间是一个单线程的时间</span></span><br><span class="line"><span class="comment">//不会涉及到并发，所以直接给一个私有变量即可。</span></span><br><span class="line"></span><br><span class="line">private int count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(e.getMessage() + <span class="string">"  "</span> +count);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在server-java中添加"><a href="#在server-java中添加" class="headerlink" title="在server.java中添加"></a>在server.java中添加</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> MyDecoder());</span><br><span class="line">pipeline.addLast(<span class="string">"handler1"</span>, <span class="keyword">new</span> HelloHandler());</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start！！！</span><br><span class="line">hello <span class="number">1</span></span><br><span class="line">hello <span class="number">2</span></span><br><span class="line">hello <span class="number">3</span></span><br><span class="line">hello <span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="查看FramDecoder源码（解决上小节的疑问）"><a href="#查看FramDecoder源码（解决上小节的疑问）" class="headerlink" title="查看FramDecoder源码（解决上小节的疑问）"></a>查看FramDecoder源码（解决上小节的疑问）</h1><p>FramDecoder 继承SimpleChannelUpstreamHandler<br>上面提到进入pipeline后第一个处理的方法是messageReceived方法</p><h2 id="FramDecoder"><a href="#FramDecoder" class="headerlink" title="FramDecoder"></a>FramDecoder</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public <span class="keyword">void</span> messageReceived(</span><br><span class="line">            ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Object</span> m = e.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (!(m <span class="keyword">instanceof</span> ChannelBuffer)) &#123;</span><br><span class="line">        <span class="comment">//判断是不是channelbuffer，不是的话就向下传递事件</span></span><br><span class="line">            ctx.sendUpstream(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChannelBuffer input = (ChannelBuffer) m;</span><br><span class="line">        <span class="keyword">if</span> (!input.readable()) &#123;</span><br><span class="line">        <span class="comment">//判断有没有数据可读，没有的话就直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//这里的cumulation其实就是一个缓存的buffer对象</span></span><br><span class="line"><span class="comment">//假如handler中return null之后buffer中海有数据，就存到这里面</span></span><br><span class="line"><span class="comment">//假如读完之后，往下传递对象，但是buffer中还有未传递完的对象，也会将数据存到里面</span></span><br><span class="line"><span class="comment">//其实        protected ChannelBuffer cumulation; 本身也是一个channelbuffer</span></span><br><span class="line">        <span class="keyword">if</span> (cumulation == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// the cumulation buffer is not created yet so just pass the input to callDecode(...) method</span></span><br><span class="line">                <span class="comment">//第一次进来cumulation里面没有缓存的数据进入callDecode对象，往下面看</span></span><br><span class="line">                <span class="comment">//第三个参数是我们的input</span></span><br><span class="line">                <span class="comment">//这个方法具体实现往下看</span></span><br><span class="line">                callDecode(ctx, e.getChannel(), input, e.getRemoteAddress());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//缓存数据到cumulation</span></span><br><span class="line">                updateCumulation(ctx, input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Cumulation中有数据，就把新的数据添加到cumulation后面,具体代码往下看</span></span><br><span class="line">            input = appendToCumulation(input);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//再次进入callDecode方法</span></span><br><span class="line">                callDecode(ctx, e.getChannel(), input, e.getRemoteAddress());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                updateCumulation(ctx, input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private <span class="keyword">void</span> callDecode(</span><br><span class="line">            ChannelHandlerContext context, Channel channel,</span><br><span class="line">            ChannelBuffer cumulation, SocketAddress remoteAddress) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cumulation.readable()) &#123;</span><br><span class="line">        <span class="comment">//首先记录一下读指针位置</span></span><br><span class="line">            int oldReaderIndex = cumulation.readerIndex();</span><br><span class="line">            <span class="comment">//然后执行decode方法，这里的decode方法就是我我们之前自定义的myDecoder等方法</span></span><br><span class="line">            <span class="comment">//回一下之前自定义的，如果进来的数据小于四个字节，直接return null，如果长度不够也return null</span></span><br><span class="line">            <span class="comment">//判断长度之后，读，读完之后buffer中还有数据，return new String（）；</span></span><br><span class="line">            <span class="comment">//看一下这里renturn的对象是frame</span></span><br><span class="line">            <span class="built_in">Object</span> frame = decode(context, channel, cumulation);</span><br><span class="line">            <span class="keyword">if</span> (frame == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//首先看旧的指针和现在的是不是一样</span></span><br><span class="line">                <span class="keyword">if</span> (oldReaderIndex == cumulation.readerIndex()) &#123;</span><br><span class="line">                    <span class="comment">// Seems like more data is required.</span></span><br><span class="line">                    <span class="comment">// Let us wait for the next notification.</span></span><br><span class="line">                    <span class="comment">//是的话就不管了</span></span><br><span class="line">                    <span class="comment">//第一次return了返回看上面的代码</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Previous data has been discarded.</span></span><br><span class="line">                    <span class="comment">// Probably it is reading on.</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们自定义的Handler不是return null，就走这里</span></span><br><span class="line">            <span class="comment">//如果旧的指针和新的指针相同的话，就会抛出异常</span></span><br><span class="line">            <span class="comment">//可是我们return的是一个string，所以肯定不是null</span></span><br><span class="line">            <span class="keyword">if</span> (oldReaderIndex == cumulation.readerIndex()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">"decode() method must read at least one byte "</span> +</span><br><span class="line">                        <span class="string">"if it returned a frame (caused by: "</span> + getClass() + <span class="string">')'</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//所以走到了这里，具体代码往下看</span></span><br><span class="line">            unfoldAndFireMessageReceived(context, remoteAddress, frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//就是看input里面还有没有数据，有的话就把数据加到cumulation中</span></span><br><span class="line">protected ChannelBuffer updateCumulation(ChannelHandlerContext ctx, ChannelBuffer input) &#123;</span><br><span class="line">        ChannelBuffer newCumulation;</span><br><span class="line">        int readableBytes = input.readableBytes();</span><br><span class="line">        <span class="keyword">if</span> (readableBytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            int inputCapacity = input.capacity();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If input.readableBytes() == input.capacity() (i.e. input is full),</span></span><br><span class="line">            <span class="comment">// there's nothing to save from creating a new cumulation buffer</span></span><br><span class="line">            <span class="comment">// even if input.capacity() exceeds the threshold, because the new cumulation</span></span><br><span class="line">            <span class="comment">// buffer will have the same capacity and content with input.</span></span><br><span class="line">            <span class="keyword">if</span> (readableBytes &lt; inputCapacity &amp;&amp; inputCapacity &gt; copyThreshold) &#123;</span><br><span class="line">                <span class="comment">// At least one byte was consumed by callDecode() and input.capacity()</span></span><br><span class="line">                <span class="comment">// exceeded the threshold.</span></span><br><span class="line">                cumulation = newCumulation = newCumulationBuffer(ctx, input.readableBytes());</span><br><span class="line">                cumulation.writeBytes(input);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Nothing was consumed by callDecode() or input.capacity() did not</span></span><br><span class="line">                <span class="comment">// exceed the threshold.</span></span><br><span class="line">                <span class="keyword">if</span> (input.readerIndex() != <span class="number">0</span>) &#123;</span><br><span class="line">                    cumulation = newCumulation = input.slice();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cumulation = newCumulation = input;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cumulation = newCumulation = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newCumulation;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如过cumulation中有数据，就把新的数据加到后面，返回上面接着看</span></span><br><span class="line"> protected ChannelBuffer appendToCumulation(ChannelBuffer input) &#123;</span><br><span class="line">        ChannelBuffer cumulation = <span class="keyword">this</span>.cumulation;</span><br><span class="line">        assert cumulation.readable();</span><br><span class="line">        <span class="keyword">if</span> (cumulation <span class="keyword">instanceof</span> CompositeChannelBuffer) &#123;</span><br><span class="line">            <span class="comment">// Make sure the resulting cumulation buffer has no more than the configured components.</span></span><br><span class="line">            CompositeChannelBuffer composite = (CompositeChannelBuffer) cumulation;</span><br><span class="line">            <span class="keyword">if</span> (composite.numComponents() &gt;= maxCumulationBufferComponents) &#123;</span><br><span class="line">                cumulation = composite.copy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.cumulation = input = ChannelBuffers.wrappedBuffer(cumulation, input);</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> protected final <span class="keyword">void</span> unfoldAndFireMessageReceived(</span><br><span class="line">            ChannelHandlerContext context, SocketAddress remoteAddress, <span class="built_in">Object</span> result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unfold) &#123;</span><br><span class="line">        <span class="comment">//result就是我们上面的frame，就是自定义的handler中的return 后面的值（走到这步说明return肯定不是null）</span></span><br><span class="line">        <span class="comment">//如果是数组</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Object</span>[]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">Object</span> r: (<span class="built_in">Object</span>[]) result) &#123;</span><br><span class="line">                    Channels.fireMessageReceived(context, r, remoteAddress);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Iterable&lt;?&gt;) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">Object</span> r: (Iterable&lt;?&gt;) result) &#123;</span><br><span class="line">                    Channels.fireMessageReceived(context, r, remoteAddress);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//fireMessageReceived方法往下看，其实还是执行了sendUpStream方法，也就是往下传。</span></span><br><span class="line">                Channels.fireMessageReceived(context, result, remoteAddress);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Channels.fireMessageReceived(context, result, remoteAddress);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> fireMessageReceived(</span><br><span class="line">            ChannelHandlerContext ctx, <span class="built_in">Object</span> message, SocketAddress remoteAddress) &#123;</span><br><span class="line">        ctx.sendUpstream(<span class="keyword">new</span> UpstreamMessageEvent(</span><br><span class="line">                ctx.getChannel(), message, remoteAddress));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>1、为什么FrameDecoder return的对象就是往下传递的对象 （还是调用了sendUpstream）</p><p>2、buffer里面数据未被读取完怎么办？ （cumulation缓存）</p><p>3、为什么return null就可以缓存buffer （cumulation缓存）</p><h1 id="如何避免socket攻击"><a href="#如何避免socket攻击" class="headerlink" title="如何避免socket攻击"></a>如何避免socket攻击</h1><p>上面的长度加内容的方式还是有问题的<br>比如客户端发送的数据 长度是8，可是真正发送了10个字节。<br>或者客户端发送了Integer.Max个字节，每次判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(buffer.readableBytes() &lt; length)&#123;</span><br><span class="line">buffer.resetReaderIndex();</span><br><span class="line"><span class="comment">//缓存当前剩余的buffer数据，等待剩下数据包到来</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次都是判断，不断的网缓存里面生产数据包，知道内存不够，宕机</p><p>把长度定义的很大，这种数据包，通常被称为socket攻击，字节流式攻击</p><h2 id="解决（🌰）"><a href="#解决（🌰）" class="headerlink" title="解决（🌰）"></a>解决（🌰）</h2><p>可以通过清除缓存的方式，可是因为清除了数据之后，因为可能会出现分包截断的现象，下次进来的时候，可能不是开头，所以不能知道哪个是长度，哪个是数据，所以需要包头，只有当时读到包头的时候才继续往下走。</p><h3 id="ResponseDecoder-java"><a href="#ResponseDecoder-java" class="headerlink" title="ResponseDecoder.java"></a>ResponseDecoder.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">package com.cn.codc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffer;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.frame.FrameDecoder;</span><br><span class="line"><span class="keyword">import</span> com.cn.constant.ConstantValue;</span><br><span class="line"><span class="keyword">import</span> com.cn.model.Response;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * response解码器</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 数据包格式</span></span><br><span class="line"><span class="comment"> * +——----——+——-----——+——----——+——----——+——-----——+——-----——+</span></span><br><span class="line"><span class="comment"> * | 包头          | 模块号        | 命令号       |  状态码    |  长度          |   数据       |</span></span><br><span class="line"><span class="comment"> * +——----——+——-----——+——----——+——----——+——-----——+——-----——+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * 包头4字节</span></span><br><span class="line"><span class="comment"> * 模块号2字节short</span></span><br><span class="line"><span class="comment"> * 命令号2字节short</span></span><br><span class="line"><span class="comment"> * 长度4字节(描述数据部分字节长度)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> -</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ResponseDecoder</span> <span class="keyword">extends</span> <span class="title">FrameDecoder</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据包基本长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> int BASE_LENTH = <span class="number">4</span> + <span class="number">2</span> + <span class="number">2</span> + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected <span class="built_in">Object</span> decode(ChannelHandlerContext arg0, Channel arg1, ChannelBuffer buffer) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可读长度必须大于基本长度</span></span><br><span class="line"><span class="keyword">if</span>(buffer.readableBytes() &gt;= BASE_LENTH)&#123;</span><br><span class="line"><span class="comment">//防止字节流攻击</span></span><br><span class="line"><span class="keyword">if</span>(buffer.readableBytes()&gt;<span class="number">2048</span>)&#123;</span><br><span class="line"><span class="comment">//清除缓存中的数据</span></span><br><span class="line">buffer.skipBytes(buffer.readableBytes());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//记录包头开始的index</span></span><br><span class="line">int beginReader ；</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">beginReader = buffer.readerIndex();</span><br><span class="line"><span class="comment">//标记当前索引</span></span><br><span class="line">buffer.markReaderIndex();</span><br><span class="line"><span class="comment">//判断包头是否是当前的包头</span></span><br><span class="line"><span class="comment">//因为清除了数据之后，因为可能会出现分包截断的现象，下次进来的时候，</span></span><br><span class="line"><span class="comment">//可能不是开头，所以不能知道哪个是长度，哪个是数据，所以需要包头，</span></span><br><span class="line"><span class="comment">//只有当时读到包头的时候才继续往下走。</span></span><br><span class="line"><span class="keyword">if</span>(buffer.readInt() == ConstantValue.FLAG)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//未读到包头超过了一个字节</span></span><br><span class="line">buffer.resetReaderIndex();</span><br><span class="line"><span class="comment">//因为可能读一个int之后，略过了包头，因为可能包头在第一个字节处</span></span><br><span class="line"><span class="comment">//所以这里选择继续往下读一个字节</span></span><br><span class="line">buffer.readByte();</span><br><span class="line"><span class="comment">//可能出现极端的情况，长度又变得不满足</span></span><br><span class="line"><span class="keyword">if</span>(buffer.readableBytes()&lt;BASE_LENGTH)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模块号</span></span><br><span class="line">short <span class="built_in">module</span> = buffer.readShort();</span><br><span class="line"><span class="comment">//命令号</span></span><br><span class="line">short cmd = buffer.readShort();</span><br><span class="line"><span class="comment">//状态码</span></span><br><span class="line">int stateCode = buffer.readInt();</span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">int length = buffer.readInt();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer.readableBytes() &lt; length)&#123;</span><br><span class="line"><span class="comment">//还原读指针</span></span><br><span class="line">buffer.readerIndex(beginReader);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">byte[] data = <span class="keyword">new</span> byte[length];</span><br><span class="line">buffer.readBytes(data);</span><br><span class="line"></span><br><span class="line">Response response = <span class="keyword">new</span> Response();</span><br><span class="line">response.setModule(<span class="built_in">module</span>);</span><br><span class="line">response.setCmd(cmd);</span><br><span class="line">response.setStateCode(stateCode);</span><br><span class="line">response.setData(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续往下传递 </span></span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据包不完整，需要等待后面的包来</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基于Netty的RPC架构学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84RPC%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Netty" scheme="http://mmmmmm.me/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>基于Netty的RPC架构学习笔记（十）：自定义数据包协议</title>
    <link href="http://mmmmmm.me/2019-03-10-10.html"/>
    <id>http://mmmmmm.me/2019-03-10-10.html</id>
    <published>2019-03-10T02:21:10.000Z</published>
    <updated>2019-03-10T15:09:15.833Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="数据包简介"><a href="#数据包简介" class="headerlink" title="数据包简介"></a>数据包简介</h1><h2 id="粘包、分包现象"><a href="#粘包、分包现象" class="headerlink" title="粘包、分包现象"></a>粘包、分包现象</h2><p>假如客户端需要给服务端发送数据<br>give me a coffee give me a tea<br>可能会出现粘包或者分包的现象</p><ul><li>粘包现象<br>give me a coffeegive me a tea</li><li><p>分包现象<br>give me<br>a coffeegive me a tea</p><p>粘包和分包出现的原因是：没有一个稳定数据结构，解决方法比如</p></li><li>分割符<br>give me a coffee|give me a tea|<br>give me a coffee|<br>give me a tea|<ul><li>长度 + 数据<br>16give me a coffee13give me a tea<br>16give me a coffee<br>13give me a tea<h2 id="数据包格式"><a href="#数据包格式" class="headerlink" title="数据包格式"></a>数据包格式</h2>+———-——+———–——+———-——+———-——+———–——+<br>| 包头 | 模块号 | 命令号 | 长度 | 数据 |<br>+———-——+———–——+———-——+———-——+———–——+<br>包头4字节 （一些不常用的东西）<br>模块号2字节short（Player 1号）<br>命令号2字节short（Player要做的事情，比如获取玩家数据 1号）<br>长度4字节(描述数据部分字节长度)<br>Player 1<br>1 获取玩家数据<br>2 注册用户<br>3 购买金币</li></ul></li></ul><h1 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h1><p>需要的jar：netty-3.10.5.final.jar</p><h2 id="Common项目"><a href="#Common项目" class="headerlink" title="Common项目"></a>Common项目</h2><p>新建项目Common==》新建包model、 module、codc、constant、serial==&gt;model包下新建Request.java</p><h3 id="Request-java"><a href="#Request-java" class="headerlink" title="Request.java"></a>Request.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package com.cn.model;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求模块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">private short <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 命令号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">private short cmd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据部分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">private byte[] data;</span><br><span class="line"></span><br><span class="line">public short getModule() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> setModule(short <span class="built_in">module</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.module = <span class="built_in">module</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public short getCmd() &#123;</span><br><span class="line"><span class="keyword">return</span> cmd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> setCmd(short cmd) &#123;</span><br><span class="line"><span class="keyword">this</span>.cmd = cmd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public byte[] getData() &#123;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> setData(byte[] data) &#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int getDataLength()&#123;</span><br><span class="line"><span class="keyword">if</span>(data == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data.length;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constant包下新建</p><h3 id="ConstantValue-java"><a href="#ConstantValue-java" class="headerlink" title="ConstantValue.java"></a>ConstantValue.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.cn.constant;</span><br><span class="line"></span><br><span class="line">public interface ConstantValue &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包头,包头是一个常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> final int FLAG = <span class="number">-32523523</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>codc包下新建RequestDecoder.java和RequestEncoder.java</p><h3 id="RequestEncoder-java"><a href="#RequestEncoder-java" class="headerlink" title="RequestEncoder.java"></a>RequestEncoder.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.cn.codc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffer;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffers;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.oneone.OneToOneEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cn.constant.ConstantValue;</span><br><span class="line"><span class="keyword">import</span> com.cn.model.Request;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求编码器</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 数据包格式</span></span><br><span class="line"><span class="comment"> * +——----——+——-----——+——----——+——----——+——-----——+</span></span><br><span class="line"><span class="comment"> * | 包头          | 模块号        | 命令号      |  长度        |   数据       |</span></span><br><span class="line"><span class="comment"> * +——----——+——-----——+——----——+——----——+——-----——+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * 包头4字节</span></span><br><span class="line"><span class="comment"> * 模块号2字节short</span></span><br><span class="line"><span class="comment"> * 命令号2字节short</span></span><br><span class="line"><span class="comment"> * 长度4字节(描述数据部分字节长度)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RequestEncoder</span> <span class="keyword">extends</span> <span class="title">OneToOneEncoder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected <span class="built_in">Object</span> encode(ChannelHandlerContext context, Channel channel, <span class="built_in">Object</span> rs) throws Exception &#123;</span><br><span class="line">Request request = (Request)(rs);</span><br><span class="line"></span><br><span class="line">ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();</span><br><span class="line"><span class="comment">//包头</span></span><br><span class="line">buffer.writeInt(ConstantValue.FLAG);</span><br><span class="line"><span class="comment">//module</span></span><br><span class="line">buffer.writeShort(request.getModule());</span><br><span class="line"><span class="comment">//cmd</span></span><br><span class="line">buffer.writeShort(request.getCmd());</span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">buffer.writeInt(request.getDataLength());</span><br><span class="line"><span class="comment">//data</span></span><br><span class="line"><span class="keyword">if</span>(request.getData() != <span class="literal">null</span>)&#123;</span><br><span class="line">buffer.writeBytes(request.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RequestDecoder-java"><a href="#RequestDecoder-java" class="headerlink" title="RequestDecoder.java"></a>RequestDecoder.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">package com.cn.codc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffer;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.frame.FrameDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cn.constant.ConstantValue;</span><br><span class="line"><span class="keyword">import</span> com.cn.model.Request;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求解码器</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 数据包格式</span></span><br><span class="line"><span class="comment"> * +——----——+——-----——+——----——+——----——+——-----——+</span></span><br><span class="line"><span class="comment"> * | 包头          | 模块号        | 命令号      |  长度        |   数据       |</span></span><br><span class="line"><span class="comment"> * +——----——+——-----——+——----——+——----——+——-----——+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * 包头4字节</span></span><br><span class="line"><span class="comment"> * 模块号2字节short</span></span><br><span class="line"><span class="comment"> * 命令号2字节short</span></span><br><span class="line"><span class="comment"> * 长度4字节(描述数据部分字节长度)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//FrameDecoder可以协助我们解决粘包分包的问题</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RequestDecoder</span> <span class="keyword">extends</span> <span class="title">FrameDecoder</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据包基本长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> int BASE_LENTH = <span class="number">4</span> + <span class="number">2</span> + <span class="number">2</span> + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected <span class="built_in">Object</span> decode(ChannelHandlerContext arg0, Channel arg1, ChannelBuffer buffer) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可读长度必须大于基本长度</span></span><br><span class="line"><span class="keyword">if</span>(buffer.readableBytes() &gt;= BASE_LENTH)&#123;</span><br><span class="line"><span class="comment">//防止socket字节流攻击</span></span><br><span class="line"><span class="keyword">if</span>(buffer.readableBytes() &gt; <span class="number">2048</span>)&#123;</span><br><span class="line">buffer.skipBytes(buffer.readableBytes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录包头开始的index</span></span><br><span class="line">int beginReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">beginReader = buffer.readerIndex();</span><br><span class="line">buffer.markReaderIndex();</span><br><span class="line"><span class="keyword">if</span>(buffer.readInt() == ConstantValue.FLAG)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未读到包头，略过一个字节</span></span><br><span class="line">buffer.resetReaderIndex();</span><br><span class="line">buffer.readByte();</span><br><span class="line"></span><br><span class="line"><span class="comment">//长度又变得不满足</span></span><br><span class="line"><span class="keyword">if</span>(buffer.readableBytes() &lt; BASE_LENTH)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模块号</span></span><br><span class="line">short <span class="built_in">module</span> = buffer.readShort();</span><br><span class="line"><span class="comment">//命令号</span></span><br><span class="line">short cmd = buffer.readShort();</span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">int length = buffer.readInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断请求数据包数据是否到齐</span></span><br><span class="line"><span class="keyword">if</span>(buffer.readableBytes() &lt; length)&#123;</span><br><span class="line"><span class="comment">//还原读指针到最开始的地方</span></span><br><span class="line">buffer.readerIndex(beginReader);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取data数据</span></span><br><span class="line">byte[] data = <span class="keyword">new</span> byte[length];</span><br><span class="line">buffer.readBytes(data);</span><br><span class="line"></span><br><span class="line">Request request = <span class="keyword">new</span> Request();</span><br><span class="line">request.setModule(<span class="built_in">module</span>);</span><br><span class="line">request.setCmd(cmd);</span><br><span class="line">request.setData(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续往下传递 </span></span><br><span class="line"><span class="keyword">return</span> request;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据包不完整，需要等待后面的包来,(buffer.readableBytes() &lt; BASE_LENTH</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChannelBuffer writeindex和readindex<br>wirteindex初始值是0，当写一个int，wirteindex就是4<br>readindex同上<br>但是注意readindex是不能超过writeindex的</p><p>modle包下新建</p><h3 id="Response-java"><a href="#Response-java" class="headerlink" title="Response.java"></a>Response.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package com.cn.model;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 返回对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 请求模块</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private short <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 命令号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private short cmd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 状态码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private int stateCode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 数据部分</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private byte[] data;</span><br><span class="line"></span><br><span class="line">  public short getModule() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">void</span> setModule(short <span class="built_in">module</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.module = <span class="built_in">module</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public short getCmd() &#123;</span><br><span class="line">  <span class="keyword">return</span> cmd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">void</span> setCmd(short cmd) &#123;</span><br><span class="line">  <span class="keyword">this</span>.cmd = cmd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getStateCode() &#123;</span><br><span class="line">  <span class="keyword">return</span> stateCode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">void</span> setStateCode(int stateCode) &#123;</span><br><span class="line">  <span class="keyword">this</span>.stateCode = stateCode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public byte[] getData() &#123;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">void</span> setData(byte[] data) &#123;</span><br><span class="line">  <span class="keyword">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getDataLength()&#123;</span><br><span class="line">  <span class="keyword">if</span>(data == <span class="literal">null</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data.length;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>model下新建</p><h3 id="StateCode-java，response的状态码"><a href="#StateCode-java，response的状态码" class="headerlink" title="StateCode.java，response的状态码"></a>StateCode.java，response的状态码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.cn.model;</span><br><span class="line"></span><br><span class="line">public interface StateCode &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> int SUCCESS  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> int FAIL  =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>codc包下新建ResponseEncoder.java和ResponseDecoder.java</p><h3 id="ResponseEncoder-java"><a href="#ResponseEncoder-java" class="headerlink" title="ResponseEncoder.java"></a>ResponseEncoder.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.cn.codc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffer;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffers;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.oneone.OneToOneEncoder;</span><br><span class="line"><span class="keyword">import</span> com.cn.constant.ConstantValue;</span><br><span class="line"><span class="keyword">import</span> com.cn.model.Response;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求编码器</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 数据包格式</span></span><br><span class="line"><span class="comment"> * +——----——+——-----——+——----——+——----——+——-----——+——-----——+</span></span><br><span class="line"><span class="comment"> * | 包头          | 模块号        | 命令号       |  状态码    |  长度          |   数据       |</span></span><br><span class="line"><span class="comment"> * +——----——+——-----——+——----——+——----——+——-----——+——-----——+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * 包头4字节</span></span><br><span class="line"><span class="comment"> * 模块号2字节short</span></span><br><span class="line"><span class="comment"> * 命令号2字节short</span></span><br><span class="line"><span class="comment"> * 长度4字节(描述数据部分字节长度)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ResponseEncoder</span> <span class="keyword">extends</span> <span class="title">OneToOneEncoder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected <span class="built_in">Object</span> encode(ChannelHandlerContext context, Channel channel, <span class="built_in">Object</span> rs) throws Exception &#123;</span><br><span class="line">Response response = (Response)(rs);</span><br><span class="line"></span><br><span class="line">ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();</span><br><span class="line"><span class="comment">//包头</span></span><br><span class="line">buffer.writeInt(ConstantValue.FLAG);</span><br><span class="line"><span class="comment">//module</span></span><br><span class="line">buffer.writeShort(response.getModule());</span><br><span class="line"><span class="comment">//cmd</span></span><br><span class="line">buffer.writeShort(response.getCmd());</span><br><span class="line"><span class="comment">//状态码</span></span><br><span class="line">buffer.writeInt(response.getStateCode());</span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">buffer.writeInt(response.getDataLength());</span><br><span class="line"><span class="comment">//data</span></span><br><span class="line"><span class="keyword">if</span>(response.getData() != <span class="literal">null</span>)&#123;</span><br><span class="line">buffer.writeBytes(response.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ResponseDecoder-java"><a href="#ResponseDecoder-java" class="headerlink" title="ResponseDecoder.java"></a>ResponseDecoder.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package com.cn.codc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffer;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.frame.FrameDecoder;</span><br><span class="line"><span class="keyword">import</span> com.cn.constant.ConstantValue;</span><br><span class="line"><span class="keyword">import</span> com.cn.model.Response;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * response解码器</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 数据包格式</span></span><br><span class="line"><span class="comment"> * +——----——+——-----——+——----——+——----——+——-----——+——-----——+</span></span><br><span class="line"><span class="comment"> * | 包头          | 模块号        | 命令号       |  状态码    |  长度          |   数据       |</span></span><br><span class="line"><span class="comment"> * +——----——+——-----——+——----——+——----——+——-----——+——-----——+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * 包头4字节</span></span><br><span class="line"><span class="comment"> * 模块号2字节short</span></span><br><span class="line"><span class="comment"> * 命令号2字节short</span></span><br><span class="line"><span class="comment"> * 长度4字节(描述数据部分字节长度)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> -</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ResponseDecoder</span> <span class="keyword">extends</span> <span class="title">FrameDecoder</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据包基本长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> int BASE_LENTH = <span class="number">4</span> + <span class="number">2</span> + <span class="number">2</span> + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected <span class="built_in">Object</span> decode(ChannelHandlerContext arg0, Channel arg1, ChannelBuffer buffer) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可读长度必须大于基本长度</span></span><br><span class="line"><span class="keyword">if</span>(buffer.readableBytes() &gt;= BASE_LENTH)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录包头开始的index</span></span><br><span class="line">int beginReader = buffer.readerIndex();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(buffer.readInt() == ConstantValue.FLAG)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模块号</span></span><br><span class="line">short <span class="built_in">module</span> = buffer.readShort();</span><br><span class="line"><span class="comment">//命令号</span></span><br><span class="line">short cmd = buffer.readShort();</span><br><span class="line"><span class="comment">//状态码</span></span><br><span class="line">int stateCode = buffer.readInt();</span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">int length = buffer.readInt();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer.readableBytes() &lt; length)&#123;</span><br><span class="line"><span class="comment">//还原读指针</span></span><br><span class="line">buffer.readerIndex(beginReader);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">byte[] data = <span class="keyword">new</span> byte[length];</span><br><span class="line">buffer.readBytes(data);</span><br><span class="line"></span><br><span class="line">Response response = <span class="keyword">new</span> Response();</span><br><span class="line">response.setModule(<span class="built_in">module</span>);</span><br><span class="line">response.setCmd(cmd);</span><br><span class="line">response.setStateCode(stateCode);</span><br><span class="line">response.setData(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续往下传递 </span></span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据包不完整，需要等待后面的包来</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： <strong><font color="red">上面的代码在遇到socket字节流攻击的时候会有异常，包括为什么需要包头，会在下面一节中的最后进行讲解</font></strong></p><p>新建serial包==》将上节最后的两个序列化的工具类粘贴过来（BufferFactory.java和Serializer.java）<br>model包下新建fuben包==》新建和request包和response包==》request包下新建FightRequest.java==》response包下新建FightResponse.java<br>这里的副本简单理解为打游戏刷的副本这个对象</p><h2 id="FightRequest-java"><a href="#FightRequest-java" class="headerlink" title="FightRequest.java"></a>FightRequest.java</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.cn.module.fuben.request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cn.serial.Serializer;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FightRequest</span> <span class="keyword">extends</span> <span class="title">Serializer</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 副本id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">private int fubenId;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">private int count;</span><br><span class="line"></span><br><span class="line">public int getFubenId() &#123;</span><br><span class="line"><span class="keyword">return</span> fubenId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> setFubenId(int fubenId) &#123;</span><br><span class="line"><span class="keyword">this</span>.fubenId = fubenId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getCount() &#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> setCount(int count) &#123;</span><br><span class="line"><span class="keyword">this</span>.count = count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected <span class="keyword">void</span> read() &#123;</span><br><span class="line"><span class="keyword">this</span>.fubenId = readInt();</span><br><span class="line"><span class="keyword">this</span>.count = readInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected <span class="keyword">void</span> write() &#123;</span><br><span class="line">writeInt(fubenId);</span><br><span class="line">writeInt(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Client项目"><a href="#Client项目" class="headerlink" title="Client项目"></a>Client项目</h2><p>新建Client项目，将之前client代码拷贝过来</p><h3 id="Client-java"><a href="#Client-java" class="headerlink" title="Client.java"></a>Client.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package com.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.bootstrap.ClientBootstrap;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelPipelineFactory;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.Channels;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;</span><br><span class="line"><span class="keyword">import</span> com.cn.codc.RequestEncoder;</span><br><span class="line"><span class="keyword">import</span> com.cn.codc.ResponseDecoder;</span><br><span class="line"><span class="keyword">import</span> com.cn.model.Request;</span><br><span class="line"><span class="keyword">import</span> com.cn.module.fuben.request.FightRequest;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * netty客户端入门</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务类</span></span><br><span class="line">ClientBootstrap bootstrap = <span class="keyword">new</span>  ClientBootstrap();</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池</span></span><br><span class="line">ExecutorService boss = Executors.newCachedThreadPool();</span><br><span class="line">ExecutorService worker = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">//socket工厂</span></span><br><span class="line">bootstrap.setFactory(<span class="keyword">new</span> NioClientSocketChannelFactory(boss, worker));</span><br><span class="line"></span><br><span class="line"><span class="comment">//管道工厂</span></span><br><span class="line">bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ChannelPipeline getPipeline() throws Exception &#123;</span><br><span class="line">ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line"><span class="comment">//修改为刚刚写的ResponseEncoder和RequestEndoder</span></span><br><span class="line">pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> ResponseDecoder());</span><br><span class="line">pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> RequestEncoder());</span><br><span class="line">pipeline.addLast(<span class="string">"hiHandler"</span>, <span class="keyword">new</span> HiHandler());</span><br><span class="line"><span class="keyword">return</span> pipeline;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接服务端</span></span><br><span class="line">ChannelFuture connect = bootstrap.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">10101</span>));</span><br><span class="line">Channel channel = connect.sync().getChannel();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"client start"</span>);</span><br><span class="line"></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"请输入"</span>);</span><br><span class="line">int fubenId = Integer.parseInt(scanner.nextLine());</span><br><span class="line">int count = Integer.parseInt(scanner.nextLine());</span><br><span class="line"></span><br><span class="line">FightRequest fightRequest = <span class="keyword">new</span> FightRequest();</span><br><span class="line">fightRequest.setFubenId(fubenId);</span><br><span class="line">fightRequest.setCount(count);</span><br><span class="line"></span><br><span class="line">Request request = <span class="keyword">new</span> Request();</span><br><span class="line">request.setModule((short) <span class="number">1</span>);</span><br><span class="line">request.setCmd((short) <span class="number">1</span>);</span><br><span class="line">request.setData(fightRequest.getBytes());</span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">channel.write(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的变化是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改为刚刚写的ResponseEncoder和RequestEndoder</span></span><br><span class="line"><span class="comment">//response解码</span></span><br><span class="line">pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> ResponseDecoder());</span><br><span class="line"><span class="comment">//requset编码</span></span><br><span class="line">pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> RequestEncoder());</span><br><span class="line">pipeline.addLast(<span class="string">"hiHandler"</span>, <span class="keyword">new</span> HiHandler());</span><br></pre></td></tr></table></figure><p>和最后变成发送requst</p><h3 id="HiHandler-java"><a href="#HiHandler-java" class="headerlink" title="HiHandler.java"></a>HiHandler.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">package com.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelStateEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ExceptionEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.MessageEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.SimpleChannelHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cn.model.Response;</span><br><span class="line"><span class="keyword">import</span> com.cn.model.StateCode;</span><br><span class="line"><span class="keyword">import</span> com.cn.module.fuben.request.FightRequest;</span><br><span class="line"><span class="keyword">import</span> com.cn.module.fuben.response.FightResponse;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息接受处理类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HiHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;</span><br><span class="line"><span class="comment">//修改为response对象</span></span><br><span class="line">Response message = (Response)e.getMessage();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(message.getModule() == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(message.getCmd() == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//从server端获取数据并输出</span></span><br><span class="line">FightResponse fightResponse = <span class="keyword">new</span> FightResponse();</span><br><span class="line">fightResponse.readFromBytes(message.getData());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"gold:"</span> + fightResponse.getGold());</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(message.getCmd() == <span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (message.getModule() == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 捕获异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception &#123;</span><br><span class="line">System.out.println(<span class="string">"exceptionCaught"</span>);</span><br><span class="line"><span class="keyword">super</span>.exceptionCaught(ctx, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception &#123;</span><br><span class="line">System.out.println(<span class="string">"channelConnected"</span>);</span><br><span class="line"><span class="keyword">super</span>.channelConnected(ctx, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须是链接已经建立，关闭通道的时候才会触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception &#123;</span><br><span class="line">System.out.println(<span class="string">"channelDisconnected"</span>);</span><br><span class="line"><span class="keyword">super</span>.channelDisconnected(ctx, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * channel关闭的时候触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception &#123;</span><br><span class="line">System.out.println(<span class="string">"channelClosed"</span>);</span><br><span class="line"><span class="keyword">super</span>.channelClosed(ctx, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将原来收到和回写的对象转化成response对象</p><h2 id="Server项目"><a href="#Server项目" class="headerlink" title="Server项目"></a>Server项目</h2><p>新建Server项目，将之前server代码拷贝过来</p><h3 id="Server-java"><a href="#Server-java" class="headerlink" title="Server.java"></a>Server.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package com.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelPipelineFactory;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.Channels;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cn.codc.RequestDecoder;</span><br><span class="line"><span class="keyword">import</span> com.cn.codc.ResponseEncoder;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * netty服务端入门</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务类</span></span><br><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line"><span class="comment">//boss线程监听端口，worker线程负责数据读写</span></span><br><span class="line">ExecutorService boss = Executors.newCachedThreadPool();</span><br><span class="line">ExecutorService worker = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置niosocket工厂</span></span><br><span class="line">bootstrap.setFactory(<span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker));</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置管道的工厂</span></span><br><span class="line">bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ChannelPipeline getPipeline() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> RequestDecoder());</span><br><span class="line">pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> ResponseEncoder());</span><br><span class="line">pipeline.addLast(<span class="string">"helloHandler"</span>, <span class="keyword">new</span> HelloHandler());</span><br><span class="line"><span class="keyword">return</span> pipeline;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">10101</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"start!!!"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line"><span class="comment">//对request解码</span></span><br><span class="line">pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> RequestDecoder());</span><br><span class="line"><span class="comment">//response编码</span></span><br><span class="line">pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> ResponseEncoder());</span><br><span class="line">pipeline.addLast(<span class="string">"helloHandler"</span>, <span class="keyword">new</span> HelloHandler());</span><br><span class="line"><span class="keyword">return</span> pipeline;</span><br></pre></td></tr></table></figure><h3 id="HiHandler-java-1"><a href="#HiHandler-java-1" class="headerlink" title="HiHandler.java"></a>HiHandler.java</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">package com.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelStateEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ExceptionEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.MessageEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.SimpleChannelHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cn.model.Request;</span><br><span class="line"><span class="keyword">import</span> com.cn.model.Response;</span><br><span class="line"><span class="keyword">import</span> com.cn.model.StateCode;</span><br><span class="line"><span class="keyword">import</span> com.cn.module.fuben.request.FightRequest;</span><br><span class="line"><span class="keyword">import</span> com.cn.module.fuben.response.FightResponse;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息接受处理类</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HelloHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">Request message = (Request)e.getMessage();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(message.getModule() == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(message.getCmd() == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">FightRequest fightRequest = <span class="keyword">new</span> FightRequest();</span><br><span class="line">fightRequest.readFromBytes(message.getData());</span><br><span class="line"><span class="comment">//需要打的副本id是xxx打了xxx次</span></span><br><span class="line">System.out.println(<span class="string">"fubenId:"</span> +fightRequest.getFubenId() + <span class="string">"   "</span> + <span class="string">"count:"</span> + fightRequest.getCount());</span><br><span class="line"></span><br><span class="line"><span class="comment">//回写数据</span></span><br><span class="line">FightResponse fightResponse = <span class="keyword">new</span> FightResponse();</span><br><span class="line">fightResponse.setGold(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">Response response = <span class="keyword">new</span> Response();</span><br><span class="line">response.setModule((short) <span class="number">1</span>);</span><br><span class="line">response.setCmd((short) <span class="number">1</span>);</span><br><span class="line">response.setStateCode(StateCode.SUCCESS);</span><br><span class="line">response.setData(fightResponse.getBytes());</span><br><span class="line">ctx.getChannel().write(response);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(message.getCmd() == <span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (message.getModule() == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 捕获异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception &#123;</span><br><span class="line">System.out.println(<span class="string">"exceptionCaught"</span>);</span><br><span class="line"><span class="keyword">super</span>.exceptionCaught(ctx, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception &#123;</span><br><span class="line">System.out.println(<span class="string">"channelConnected"</span>);</span><br><span class="line"><span class="keyword">super</span>.channelConnected(ctx, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须是链接已经建立，关闭通道的时候才会触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception &#123;</span><br><span class="line">System.out.println(<span class="string">"channelDisconnected"</span>);</span><br><span class="line"><span class="keyword">super</span>.channelDisconnected(ctx, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * channel关闭的时候触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception &#123;</span><br><span class="line">System.out.println(<span class="string">"channelClosed"</span>);</span><br><span class="line"><span class="keyword">super</span>.channelClosed(ctx, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将收到的数据强转为requset</p><h2 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h2><p>运行：<br>client端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入：</span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="comment">//要打101副本，打十次</span></span><br></pre></td></tr></table></figure><p>server端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fubenID：<span class="number">101</span> count：<span class="number">10</span></span><br></pre></td></tr></table></figure><p>client端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gold:<span class="number">999</span></span><br></pre></td></tr></table></figure><h2 id="弊端："><a href="#弊端：" class="headerlink" title="弊端："></a>弊端：</h2><p>每次都要做判断<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(message.getModule() == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(message.getCmd() == <span class="number">1</span>)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;数据包简介&quot;&gt;&lt;a href=&quot;#数据包简介&quot; class=&quot;headerlink&quot; title=&quot;数据包简介&quot;&gt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基于Netty的RPC架构学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84RPC%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Netty" scheme="http://mmmmmm.me/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>基于Netty的RPC架构学习笔记（九）：自定义序列化协议</title>
    <link href="http://mmmmmm.me/2019-03-10-9.html"/>
    <id>http://mmmmmm.me/2019-03-10-9.html</id>
    <published>2019-03-10T02:21:09.000Z</published>
    <updated>2019-03-12T12:37:53.458Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="为什么需要自定义序列化协议"><a href="#为什么需要自定义序列化协议" class="headerlink" title="为什么需要自定义序列化协议"></a>为什么需要自定义序列化协议</h1><p>上节中proto buff明显比java本身的序列化生成的byte数组短很多，因为java自身的序列化传入了很多信息（比如类信息、类型、字段等），通过自定义序列化协议能够通过自己定义的方式实现序列化和反序列化。</p><h1 id="🌰"><a href="#🌰" class="headerlink" title="🌰"></a>🌰</h1><h2 id="test1"><a href="#test1" class="headerlink" title="test1"></a>test1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">package com.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">int id = <span class="number">101</span>;</span><br><span class="line">int age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream arrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="comment">//希望将int写进去，可是看write的源码返现</span></span><br><span class="line"><span class="comment">//write（int b）&#123;</span></span><br><span class="line"><span class="comment">//  buf[coung] = byte（b）</span></span><br><span class="line"><span class="comment">//count+=1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//发现是直接把int转化成了byte，int占有4个字节长度，所以这里出现了数据截断，所以自己写一个方法int2bytes。</span></span><br><span class="line">arrayOutputStream.write(int2bytes(id));</span><br><span class="line">arrayOutputStream.write(int2bytes(age));</span><br><span class="line"></span><br><span class="line">byte[] byteArray = arrayOutputStream.toByteArray();</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(byteArray));</span><br><span class="line"></span><br><span class="line"><span class="comment">//==============================================================</span></span><br><span class="line">ByteArrayInputStream arrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(byteArray);</span><br><span class="line">byte[] idBytes = <span class="keyword">new</span> byte[<span class="number">4</span>];</span><br><span class="line">arrayInputStream.read(idBytes);</span><br><span class="line">System.out.println(<span class="string">"id:"</span> + bytes2int(idBytes));</span><br><span class="line"></span><br><span class="line">byte[] ageBytes = <span class="keyword">new</span> byte[<span class="number">4</span>];</span><br><span class="line">arrayInputStream.read(ageBytes);</span><br><span class="line">System.out.println(<span class="string">"age:"</span> + bytes2int(ageBytes));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大端字节序列(先写高位，再写低位)</span></span><br><span class="line"><span class="comment"> * 百度下 大小端字节序列</span></span><br><span class="line"><span class="comment"> * @param i</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> byte[] int2bytes(int i)&#123;</span><br><span class="line">byte[] bytes = <span class="keyword">new</span> byte[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//一个字节八位，所以3*8</span></span><br><span class="line">bytes[<span class="number">0</span>] = (byte)(i &gt;&gt; <span class="number">3</span>*<span class="number">8</span>);</span><br><span class="line">bytes[<span class="number">1</span>] = (byte)(i &gt;&gt; <span class="number">2</span>*<span class="number">8</span>);</span><br><span class="line">bytes[<span class="number">2</span>] = (byte)(i &gt;&gt; <span class="number">1</span>*<span class="number">8</span>);</span><br><span class="line">bytes[<span class="number">3</span>] = (byte)(i &gt;&gt; <span class="number">0</span>*<span class="number">8</span>);</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大端</span></span><br><span class="line"><span class="comment"> * @param bytes</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> int bytes2int(byte[] bytes)&#123;</span><br><span class="line"><span class="comment">//原来向右移动了三个字节，希望还原回来，所以向左移动三个字节</span></span><br><span class="line"><span class="comment">//或运算就是为了把数据合并起来，变成int数据</span></span><br><span class="line"><span class="keyword">return</span> (bytes[<span class="number">0</span>] &lt;&lt; <span class="number">3</span>*<span class="number">8</span>) |</span><br><span class="line">(bytes[<span class="number">1</span>] &lt;&lt; <span class="number">2</span>*<span class="number">8</span>) |</span><br><span class="line">(bytes[<span class="number">2</span>] &lt;&lt; <span class="number">1</span>*<span class="number">8</span>) |</span><br><span class="line">(bytes[<span class="number">3</span>] &lt;&lt; <span class="number">0</span>*<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">101</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">21</span>]</span><br><span class="line">id:<span class="number">101</span></span><br><span class="line">age:<span class="number">21</span></span><br></pre></td></tr></table></figure><p>每次都需要进行位运算，而且先在是转换int，long、float、double转换呢？</p><h2 id="test2"><a href="#test2" class="headerlink" title="test2"></a>test2</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">int id = <span class="number">101</span>;</span><br><span class="line">int age = <span class="number">21</span>;</span><br><span class="line"><span class="comment">//通过nio的bytebuffer转换，省去了位运算方法</span></span><br><span class="line"><span class="comment">//申请八个空间大小</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">buffer.putInt(id);</span><br><span class="line">buffer.putInt(age);</span><br><span class="line">byte[] array = buffer.array();</span><br><span class="line">System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//====================================================</span></span><br><span class="line"></span><br><span class="line">ByteBuffer buffer2 = ByteBuffer.wrap(array);</span><br><span class="line">System.out.println(<span class="string">"id:"</span>+buffer2.getInt());</span><br><span class="line">System.out.println(<span class="string">"age:"</span>+buffer2.getInt());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">101</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">21</span>]</span><br><span class="line">id:<span class="number">101</span></span><br><span class="line">age:<span class="number">21</span></span><br></pre></td></tr></table></figure><p>简化了很多操作，但是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>可是每次需要给定申请的给定空间大小，不能自动扩容</p><h2 id="test3（使用netty中的ChannelBuffers）"><a href="#test3（使用netty中的ChannelBuffers）" class="headerlink" title="test3（使用netty中的ChannelBuffers）"></a>test3（使用netty中的ChannelBuffers）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffer;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffers;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();</span><br><span class="line">buffer.writeInt(<span class="number">101</span>);</span><br><span class="line">buffer.writeDouble(<span class="number">80.1</span>);</span><br><span class="line"></span><br><span class="line">byte[] bytes = <span class="keyword">new</span> byte[buffer.writerIndex()];</span><br><span class="line">buffer.readBytes(bytes);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line"><span class="string">"abc"</span>.getBytes();</span><br><span class="line"></span><br><span class="line"><span class="comment">//================================================</span></span><br><span class="line">ChannelBuffer wrappedBuffer = ChannelBuffers.wrappedBuffer(bytes);</span><br><span class="line">System.out.println(wrappedBuffer.readInt());</span><br><span class="line">System.out.println(wrappedBuffer.readDouble());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">101</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">21</span>]</span><br><span class="line">id:<span class="number">101</span></span><br><span class="line">age:<span class="number">21</span></span><br></pre></td></tr></table></figure><p>注意</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//channelBuffer根据写指针的位置，获取byte数组大小</span></span><br><span class="line">byte[] bytes = <span class="keyword">new</span> byte[buffer.writerIndex()];</span><br></pre></td></tr></table></figure><p>除了能够自动扩容，还能够自动写入int double等类型，可是还是优缺点，这里没有一个writeString的方法</p><p><strong><font color="red">通过“abc”.getBytes()得到字节数据，可是无法确定字节的大小，不像int知道是四个字节，所以String LIst Map都需要在前面加一个长度字段。<br></font></strong><br>|-|-|<br>|-|-|<br>|String List Map | short长度+字节数组|</p><h2 id="自定义序列化协议（test4）"><a href="#自定义序列化协议（test4）" class="headerlink" title="自定义序列化协议（test4）"></a>自定义序列化协议（test4）</h2><p>SeriaLizer.java (自定义了序列化的规则)<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><span class="line">package com.serial;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffer;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化接口</span></span><br><span class="line"><span class="comment"> * @</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public abstract <span class="class"><span class="keyword">class</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> final Charset CHARSET = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">protected ChannelBuffer writeBuffer;</span><br><span class="line"></span><br><span class="line">protected ChannelBuffer readBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化具体实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">protected abstract <span class="keyword">void</span> read();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化具体实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">protected abstract <span class="keyword">void</span> write();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从byte数组获取数据</span></span><br><span class="line"><span class="comment"> * @param bytes读取的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public Serializer readFromBytes(byte[] bytes) &#123;</span><br><span class="line">readBuffer = BufferFactory.getBuffer(bytes);</span><br><span class="line">read();</span><br><span class="line">readBuffer.clear();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从buff获取数据</span></span><br><span class="line"><span class="comment"> * @param readBuffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">void</span> readFromBuffer(ChannelBuffer readBuffer) &#123;</span><br><span class="line"><span class="keyword">this</span>.readBuffer = readBuffer;</span><br><span class="line">read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写入本地buff</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public ChannelBuffer writeToLocalBuff()&#123;</span><br><span class="line">writeBuffer = BufferFactory.getBuffer();</span><br><span class="line">write();</span><br><span class="line"><span class="keyword">return</span> writeBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写入目标buff</span></span><br><span class="line"><span class="comment"> * @param buffer</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public ChannelBuffer writeToTargetBuff(ChannelBuffer buffer)&#123;</span><br><span class="line">writeBuffer = buffer;</span><br><span class="line">write();</span><br><span class="line"><span class="keyword">return</span> writeBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回buffer数组</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public byte[] getBytes() &#123;</span><br><span class="line">writeToLocalBuff();</span><br><span class="line">byte[] bytes = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (writeBuffer.writerIndex() == <span class="number">0</span>) &#123;</span><br><span class="line">bytes = <span class="keyword">new</span> byte[<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">bytes = <span class="keyword">new</span> byte[writeBuffer.writerIndex()];</span><br><span class="line">writeBuffer.readBytes(bytes);</span><br><span class="line">&#125;</span><br><span class="line">writeBuffer.clear();</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public byte readByte() &#123;</span><br><span class="line"><span class="keyword">return</span> readBuffer.readByte();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public short readShort() &#123;</span><br><span class="line"><span class="keyword">return</span> readBuffer.readShort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int readInt() &#123;</span><br><span class="line"><span class="keyword">return</span> readBuffer.readInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public long readLong() &#123;</span><br><span class="line"><span class="keyword">return</span> readBuffer.readLong();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public float readFloat() &#123;</span><br><span class="line"><span class="keyword">return</span> readBuffer.readFloat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double readDouble() &#123;</span><br><span class="line"><span class="keyword">return</span> readBuffer.readDouble();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="built_in">String</span> readString() &#123;</span><br><span class="line">int size = readBuffer.readShort();</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">byte[] bytes = <span class="keyword">new</span> byte[size];</span><br><span class="line">readBuffer.readBytes(bytes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">String</span>(bytes, CHARSET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; List&lt;T&gt; readList(Class&lt;T&gt; clz) &#123;</span><br><span class="line">List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">int size = readBuffer.readShort();</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">list.add(read(clz));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;K,V&gt; <span class="built_in">Map</span>&lt;K,V&gt; readMap(Class&lt;K&gt; keyClz, Class&lt;V&gt; valueClz) &#123;</span><br><span class="line"><span class="built_in">Map</span>&lt;K,V&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">int size = readBuffer.readShort();</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">K key = read(keyClz);</span><br><span class="line">V value = read(valueClz);</span><br><span class="line">map.put(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">public &lt;I&gt; I read(Class&lt;I&gt; clz) &#123;</span><br><span class="line"><span class="built_in">Object</span> t = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> ( clz == int.class || clz == Integer.class) &#123;</span><br><span class="line">t = <span class="keyword">this</span>.readInt();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (clz == byte.class || clz == Byte.class)&#123;</span><br><span class="line">t = <span class="keyword">this</span>.readByte();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (clz == short.class || clz == Short.class)&#123;</span><br><span class="line">t = <span class="keyword">this</span>.readShort();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (clz == long.class || clz == Long.class)&#123;</span><br><span class="line">t = <span class="keyword">this</span>.readLong();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (clz == float.class || clz == Float.class)&#123;</span><br><span class="line">t = readFloat();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (clz == double.class || clz == Double.class)&#123;</span><br><span class="line">t = readDouble();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (clz == <span class="built_in">String</span>.class )&#123;</span><br><span class="line">t = readString();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (Serializer.class.isAssignableFrom(clz))&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">byte hasObject = <span class="keyword">this</span>.readBuffer.readByte();</span><br><span class="line"><span class="keyword">if</span>(hasObject == <span class="number">1</span>)&#123;</span><br><span class="line">Serializer temp = (Serializer)clz.newInstance();</span><br><span class="line">temp.readFromBuffer(<span class="keyword">this</span>.readBuffer);</span><br><span class="line">t = temp;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">t = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="built_in">String</span>.format(<span class="string">"不支持类型:[%s]"</span>, clz));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (I) t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Serializer writeByte(Byte value) &#123;</span><br><span class="line">writeBuffer.writeByte(value);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Serializer writeShort(Short value) &#123;</span><br><span class="line">writeBuffer.writeShort(value);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Serializer writeInt(Integer value) &#123;</span><br><span class="line">writeBuffer.writeInt(value);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Serializer writeLong(Long value) &#123;</span><br><span class="line">writeBuffer.writeLong(value);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Serializer writeFloat(Float value) &#123;</span><br><span class="line">writeBuffer.writeFloat(value);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Serializer writeDouble(Double value) &#123;</span><br><span class="line">writeBuffer.writeDouble(value);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; Serializer writeList(List&lt;T&gt; list) &#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty(list)) &#123;</span><br><span class="line">writeBuffer.writeShort((short) <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">writeBuffer.writeShort((short) list.size());</span><br><span class="line"><span class="keyword">for</span> (T item : list) &#123;</span><br><span class="line">writeObject(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;K,V&gt; Serializer writeMap(<span class="built_in">Map</span>&lt;K, V&gt; map) &#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty(map)) &#123;</span><br><span class="line">writeBuffer.writeShort((short) <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">writeBuffer.writeShort((short) map.size());</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">writeObject(entry.getKey());</span><br><span class="line">writeObject(entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Serializer writeString(<span class="built_in">String</span> value) &#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span> || value.isEmpty()) &#123;</span><br><span class="line">writeShort((short) <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">byte data[] = value.getBytes(CHARSET);</span><br><span class="line">short len = (short) data.length;</span><br><span class="line">writeBuffer.writeShort(len);</span><br><span class="line">writeBuffer.writeBytes(data);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Serializer writeObject(<span class="built_in">Object</span> object) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(object == <span class="literal">null</span>)&#123;</span><br><span class="line">writeByte((byte)<span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">writeInt((int) object);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">writeLong((long) object);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> Short) &#123;</span><br><span class="line">writeShort((short) object);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> Byte) &#123;</span><br><span class="line">writeByte((byte) object);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> <span class="built_in">String</span>) &#123;</span><br><span class="line"><span class="built_in">String</span> value = (<span class="built_in">String</span>) object;</span><br><span class="line">writeString(value);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> Serializer) &#123;</span><br><span class="line">writeByte((byte)<span class="number">1</span>);</span><br><span class="line">Serializer value = (Serializer) object;</span><br><span class="line">value.writeToTargetBuff(writeBuffer);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不可序列化的类型:"</span> + object.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;T&gt; boolean isEmpty(Collection&lt;T&gt; c) &#123;</span><br><span class="line"><span class="keyword">return</span> c == <span class="literal">null</span> || c.size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">public &lt;K,V&gt; boolean isEmpty(<span class="built_in">Map</span>&lt;K,V&gt; c) &#123;</span><br><span class="line"><span class="keyword">return</span> c == <span class="literal">null</span> || c.size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注意其中的readString等方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">String</span> readString() &#123;</span><br><span class="line">int size = readBuffer.readShort();</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">byte[] bytes = <span class="keyword">new</span> byte[size];</span><br><span class="line">readBuffer.readBytes(bytes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">String</span>(bytes, CHARSET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将需要的String（list map一样）的byte大小保存到readbuffer中，反序列化的时候再从里面读出来。<br>BufferFactory.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.serial;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteOrder;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffer;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffers;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * buff工厂</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BufferFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> ByteOrder BYTE_ORDER = ByteOrder.BIG_ENDIAN;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个buffer</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> ChannelBuffer getBuffer() &#123;</span><br><span class="line">ChannelBuffer dynamicBuffer = ChannelBuffers.dynamicBuffer();</span><br><span class="line"><span class="keyword">return</span> dynamicBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将数据写入buffer</span></span><br><span class="line"><span class="comment"> * @param bytes</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> ChannelBuffer getBuffer(byte[] bytes) &#123;</span><br><span class="line">ChannelBuffer copiedBuffer = ChannelBuffers.copiedBuffer(bytes);</span><br><span class="line"><span class="keyword">return</span> copiedBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Player.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package com.serial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 玩家对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Serializer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">public Player() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Player(long playerId,  int age, <span class="built_in">String</span> name) &#123;</span><br><span class="line"><span class="keyword">this</span>.playerId = playerId;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private long playerId;</span><br><span class="line"></span><br><span class="line">private int age;</span><br><span class="line"></span><br><span class="line">private <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">private List&lt;Integer&gt; skills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public long getPlayerId() &#123;</span><br><span class="line"><span class="keyword">return</span> playerId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> setPlayerId(long playerId) &#123;</span><br><span class="line"><span class="keyword">this</span>.playerId = playerId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getAge() &#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> setAge(int age) &#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="built_in">String</span> getName() &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> setName(<span class="built_in">String</span> name) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public List&lt;Integer&gt; getSkills() &#123;</span><br><span class="line"><span class="keyword">return</span> skills;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> setSkills(List&lt;Integer&gt; skills) &#123;</span><br><span class="line"><span class="keyword">this</span>.skills = skills;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected <span class="keyword">void</span> read() &#123;</span><br><span class="line"><span class="keyword">this</span>.playerId = readLong();</span><br><span class="line"><span class="keyword">this</span>.age = readInt();</span><br><span class="line"><span class="keyword">this</span>.name = readString();</span><br><span class="line"><span class="keyword">this</span>.skills = readList(Integer.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected <span class="keyword">void</span> write() &#123;</span><br><span class="line">writeLong(playerId);</span><br><span class="line">writeInt(age);</span><br><span class="line">writeString(name);</span><br><span class="line">writeList(skills);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test4.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">Player player = <span class="keyword">new</span> Player();</span><br><span class="line">player.setPlayerId(<span class="number">10001</span>);</span><br><span class="line">player.setAge(<span class="number">22</span>);</span><br><span class="line">player.getSkills().add(<span class="number">101</span>);</span><br><span class="line">player.getResource().setGold(<span class="number">99999</span>);</span><br><span class="line"></span><br><span class="line">byte[] bytes = player.getBytes();</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line"><span class="comment">//==============================================</span></span><br><span class="line"></span><br><span class="line">Player player2 = <span class="keyword">new</span> Player();</span><br><span class="line">player2.readFromBytes(bytes);</span><br><span class="line">System.out.println(player2.getPlayerId() + <span class="string">"   "</span>+player2.getAge() + <span class="string">"     "</span>+ Arrays.toString(player2.getSkills().toArray())+<span class="string">"   "</span> +player2.getResource().getGold());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">39</span>,<span class="number">17</span>,<span class="number">0</span>,<span class="number">0</span>。。。。]</span><br><span class="line"><span class="number">1001</span> <span class="number">33</span> <span class="number">101</span> <span class="number">9999</span></span><br></pre></td></tr></table></figure><p>通过Seriazer的封装，结合前面ChannelBuffers的方式，将String list map需要传入大小的问题进行了结局。</p><h1 id="对比分析protobuff原理-重点学习proto位运算的原理"><a href="#对比分析protobuff原理-重点学习proto位运算的原理" class="headerlink" title="对比分析protobuff原理  重点学习proto位运算的原理   "></a>对比分析protobuff原理 <strong><font color="red">重点学习proto位运算的原理</font></strong></h1><h2 id="初窥"><a href="#初窥" class="headerlink" title="初窥"></a>初窥</h2><p>通过上面的例子和上节的protobuff，传入相同的值到Player类中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">39</span>,<span class="number">17</span>,<span class="number">0</span>,<span class="number">0</span>。。。。]</span><br><span class="line"><span class="number">1001</span> <span class="number">33</span> <span class="number">101</span> <span class="number">9999</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">39</span>,<span class="number">17</span>]</span><br><span class="line"><span class="number">1001</span> <span class="number">33</span> <span class="number">101</span> <span class="number">9999</span></span><br></pre></td></tr></table></figure><p>当然上面的数据是我编的，可是protobuff生产出来的byte数组大小，比我们尽最大努力自定义的数组大小还要小很多。</p><h2 id="分析protobuff源码"><a href="#分析protobuff源码" class="headerlink" title="分析protobuff源码"></a>分析protobuff源码</h2><p>上节中的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Player player = builder.build();</span><br><span class="line">byte[] byteArray = player.toByteArray();</span><br></pre></td></tr></table></figure><p>所以看tobyteArray方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public byte[] toByteArray() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    final byte[] result = <span class="keyword">new</span> byte[getSerializedSize()];</span><br><span class="line">    final CodedOutputStream output = CodedOutputStream.newInstance(result);</span><br><span class="line">    writeTo(output);</span><br><span class="line">    output.checkNoSpaceLeft();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">      <span class="string">"Serializing to a byte array threw an IOException "</span> +</span><br><span class="line">      <span class="string">"(should never happen)."</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看writeTo方法，writeTo是一个接口方法，查看具体实现类PlayerModule.java<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  public <span class="keyword">void</span> writeTo(com.google.protobuf.CodedOutputStream output)</span><br><span class="line">                        throws java.io.IOException &#123;</span><br><span class="line">      getSerializedSize();</span><br><span class="line">      <span class="keyword">if</span> (((bitField0_ &amp; <span class="number">0x00000001</span>) == <span class="number">0x00000001</span>)) &#123;</span><br><span class="line">        output.writeInt64(<span class="number">1</span>, playerID_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (((bitField0_ &amp; <span class="number">0x00000002</span>) == <span class="number">0x00000002</span>)) &#123;</span><br><span class="line">        output.writeInt32(<span class="number">2</span>, age_);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">if</span> (((bitField0_ &amp; <span class="number">0x00000001</span>) == <span class="number">0x00000001</span>)) &#123;</span><br><span class="line">        output.writeBytes(<span class="number">3</span>, getNameBytes());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; skill.size(); i++) &#123;</span><br><span class="line">        output.writeInt32(<span class="number">4</span>, skill.get(i));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      getUnknownFields().writeTo(output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里的writeInt64等方法中的第一个参数1234是上节中proto文件中的key，表示是第几个字节</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">required int64 playerId = <span class="number">1</span>;</span><br><span class="line">required int32 age = <span class="number">2</span>;</span><br><span class="line">required string name = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//repeated的意思是list，重复int的list</span></span><br><span class="line">repeated int32 skills = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>查看WriteInt32方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> writeInt32(final int fieldNumber, final int value)</span><br><span class="line">                        throws IOException &#123;</span><br><span class="line"> <span class="comment">//写第几个字节</span></span><br><span class="line">   writeTag(fieldNumber, WireFormat.WIRETYPE_VARINT);</span><br><span class="line">   <span class="comment">//写具体的年龄</span></span><br><span class="line">   writeInt32NoTag(value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>查看writeInt32NoTag方法<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> writeInt32NoTag(final int value) throws IOException &#123;</span><br><span class="line">  <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    writeRawVarint32(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Must sign-extend.</span></span><br><span class="line">    writeRawVarint64(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>查看writeRawVarint32方法<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> writeRawVarint32(int value) throws IOException &#123;</span><br><span class="line">   <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> ((value &amp; ~<span class="number">0x7F</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">       writeRawByte(value);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       writeRawByte((value &amp; <span class="number">0x7F</span>) | <span class="number">0x80</span>);</span><br><span class="line">       value &gt;&gt;&gt;= <span class="number">7</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><p>0x7F 转化成二进制 0111 1111<br>~0x7F 取反后 1000 0000<br>value&amp; ~0x7F 的结果就是value的1-7位都被置为了0，value是32位，前面还有25位可能有数据，所以可能value &amp; ~0x7F != 0<br>所以如果value &amp; ~0x7F == 0，说明value值的大小是小于7位的</p><p>如果小于后面7位的大小，就写一个字节的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> writeRawByte(final byte value) throws IOException &#123;</span><br><span class="line">   <span class="keyword">if</span> (position == limit) &#123;</span><br><span class="line">     refreshBuffer();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果大于后面7位的大小</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">writeRawByte((value &amp; <span class="number">0x7F</span>) | <span class="number">0x80</span>);</span><br><span class="line">value &gt;&gt;&gt;= <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>value &amp; 0x7F获取1-7位数据<br>0x80表示成二进制1000 0000<br>或运算 1xxx xxxx 通过第八位判断后面还有没有数据，如果有数据就是1，如果没有数据就是0，<br>所以这里说明有数据，往右移7位，接着读，然后在此判断剩下的数据是不是小于七位，如此循环。</p><p>因为这里的第一位用来表示还有没有数据，所以只能表示28位的数据位，而真正需要表示的是32位，所以还需要一个字节存储丢失的4位，所以int 的字节长度不是传统的4个，在proto中为伸缩的1-5个字节，long不是传统的8位，在proto中是伸缩的1-9位</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;为什么需要自定义序列化协议&quot;&gt;&lt;a href=&quot;#为什么需要自定义序列化协议&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基于Netty的RPC架构学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84RPC%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Netty" scheme="http://mmmmmm.me/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>基于Netty的RPC架构学习笔记（八）：protocol buff学习使用</title>
    <link href="http://mmmmmm.me/2019-03-10-8.html"/>
    <id>http://mmmmmm.me/2019-03-10-8.html</id>
    <published>2019-03-10T02:21:08.000Z</published>
    <updated>2019-03-10T15:09:10.101Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>protocol buff是一种协议，是谷歌推出的一种序列化协议<br>Java序列化协议也是一种协议<br>两者的目的是，将对象序列化成字节数组，或者说是二进制数据</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>protobuf的两个jar包、 protoc.exe(生成java的源代码，需要写protobuf的配置文件才能生成。)</p><h2 id="protobuf配置文件"><a href="#protobuf配置文件" class="headerlink" title="protobuf配置文件"></a>protobuf配置文件</h2><p>任意目录新建文件夹（任意名字）==》新建proto文件（任意名字，例如player.proto）后缀为proto</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包名</span></span><br><span class="line">option java_package = <span class="string">"com.proto"</span>;</span><br><span class="line"><span class="comment">//java_outer_classname的作用是将Paler类和Resource类整合到一个大的类中，一个大的Moudle中，名叫PlayerModule</span></span><br><span class="line">option java_outer_classname = <span class="string">"PlayerModule"</span>;</span><br><span class="line"><span class="comment">//message相当于java中的class</span></span><br><span class="line">message PBPlayer&#123;</span><br><span class="line"><span class="comment">//在protobuf中没有int和long当时有对应的类型，int32是int类型，int64是long类型</span></span><br><span class="line"><span class="comment">//required意思是这个字段类型必须设置，加入不设置就会报错</span></span><br><span class="line"><span class="comment">//后面的123是key值，这些key值在message中是不能重复的，这里的key相当于&#123;name：xiaoming&#125;中的name</span></span><br><span class="line">required int64 playerId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">required int32 age = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">required string name = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//repeated的意思是list，重复int的list</span></span><br><span class="line">repeated int32 skills = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message PBResource&#123;</span><br><span class="line"><span class="comment">//金币</span></span><br><span class="line">required int64 gold = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">required int32 energy = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成java代码"><a href="#生成java代码" class="headerlink" title="生成java代码"></a>生成java代码</h2><p>将上面的player.proto放到protoc.exe的同级目录===》在这个目录中新建build.bat<br>build.bat</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是生成c代码就是--cpp_out</span></span><br><span class="line"><span class="comment">//=后面是将java文件生成到哪个目录</span></span><br><span class="line">protoc ./player.protp --java_out=./</span><br><span class="line"><span class="comment">//断点启动方便观察错误</span></span><br><span class="line">pasue</span><br></pre></td></tr></table></figure><p>点击build.bat会自动生成一个文件加com.proto ===》PlayerModule.java</p><h1 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h1><p>新建项目==》libs用来放jar包==》新建proto目录用来放proto文件==》把上面的两个jar拷贝过去 ==》proto文件拷贝到proto目录中==》protoc.exe和build.bat拷贝到项目根目录<br>修改build.bat<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protoc ./proto<span class="comment">/*.protp --java_out=./src</span></span><br><span class="line"><span class="comment">pasue</span></span><br></pre></td></tr></table></figure><p></p><p>在src下新建PB2Bytes.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">package com.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JAVA2Bytes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">byte[] bytes = toBytes();</span><br><span class="line">toPlayer(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化</span></span><br><span class="line"><span class="comment"> * @throws IOException </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> byte[] toBytes() throws IOException&#123;</span><br><span class="line"></span><br><span class="line">Player player = <span class="keyword">new</span> Player(<span class="number">101</span>, <span class="number">20</span>, <span class="string">"peter"</span>);</span><br><span class="line">player.getSkills().add(<span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入对象</span></span><br><span class="line">objectOutputStream.writeObject(player);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 字节数组</span></span><br><span class="line">byte[] byteArray = byteArrayOutputStream.toByteArray();</span><br><span class="line">System.out.println(Arrays.toString(byteArray));</span><br><span class="line"><span class="keyword">return</span> byteArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化</span></span><br><span class="line"><span class="comment"> * @param bs</span></span><br><span class="line"><span class="comment"> * @throws Exceptipackage com.proto;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">import java.util.Arrays;</span></span><br><span class="line"><span class="comment">import com.proto.PlayerModule.PBPlayer;</span></span><br><span class="line"><span class="comment">import com.proto.PlayerModule.PBPlayer.Builder;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- protobuf学习</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- @author </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">PB2Bytes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">  byte[] bytes = toBytes();</span><br><span class="line">  toPlayer(bytes);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 序列化</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    public <span class="keyword">static</span> byte[] toBytes()&#123;</span><br><span class="line">    <span class="comment">//获取一个PBPlayer的构造器</span></span><br><span class="line">    Builder builder = PlayerModule.PBPlayer.newBuilder();</span><br><span class="line">    <span class="comment">//设置数据</span></span><br><span class="line">    <span class="comment">//上面skill是list，本应该setSkill，可是这里是setSkill（index，value），不是我们平常的skill</span></span><br><span class="line">    <span class="comment">//可以直接addSkill（1001）添加1001这个技能</span></span><br><span class="line">    <span class="comment">//前面文件文加了required前缀的必须要在这里设置值，不然会报错如下</span></span><br><span class="line">    <span class="comment">//Message missing required field</span></span><br><span class="line">    builder.setPlayerId(<span class="number">101</span>).setAge(<span class="number">20</span>).setName(<span class="string">"peter"</span>).addSkills(<span class="number">1001</span>);</span><br><span class="line">    <span class="comment">//构造出对象</span></span><br><span class="line">    PBPlayer player = builder.build();</span><br><span class="line">    <span class="comment">//序列化成字节数组</span></span><br><span class="line">    byte[] byteArray = player.toByteArray();</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(byteArray));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> byteArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 反序列化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - @param bs</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - @throws Exception </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> toPlayer(byte[] bs) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">     PBPlayer player = PlayerModule.PBPlayer.parseFrom(bs);</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">"playerId:"</span> + player.getPlayerId());</span><br><span class="line">     System.out.println(<span class="string">"age:"</span> + player.getAge());</span><br><span class="line">     System.out.println(<span class="string">"name:"</span> + player.getName());</span><br><span class="line">     System.out.println(<span class="string">"skills:"</span> + (Arrays.toString(player.getSkillsList().toArray())));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">8</span>,<span class="number">101</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">16</span>,<span class="number">5</span>,<span class="number">112</span>,<span class="number">101</span>,<span class="number">116</span>,<span class="number">101</span>,<span class="number">114</span>,<span class="number">32</span>,<span class="number">-23</span>,<span class="number">7</span>]</span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line">peter</span><br><span class="line"><span class="number">1001</span></span><br></pre></td></tr></table></figure><h1 id="java序列化和反序列化"><a href="#java序列化和反序列化" class="headerlink" title="java序列化和反序列化"></a>java序列化和反序列化</h1><p>Player.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package com.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 玩家对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="title">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - */</span></span><br><span class="line">    private <span class="keyword">static</span> final long serialVersionUID = <span class="number">-5248069984631225347</span>L;</span><br><span class="line"></span><br><span class="line">  public Player(long playerId,  int age, <span class="built_in">String</span> name) &#123;</span><br><span class="line">  <span class="keyword">this</span>.playerId = playerId;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private long playerId;</span><br><span class="line"></span><br><span class="line">  private int age;</span><br><span class="line"></span><br><span class="line">  private <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  private List&lt;Integer&gt; skills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public long getPlayerId() &#123;</span><br><span class="line">  <span class="keyword">return</span> playerId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">void</span> setPlayerId(long playerId) &#123;</span><br><span class="line">  <span class="keyword">this</span>.playerId = playerId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getAge() &#123;</span><br><span class="line">  <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">void</span> setAge(int age) &#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="built_in">String</span> getName() &#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">void</span> setName(<span class="built_in">String</span> name) &#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public List&lt;Integer&gt; getSkills() &#123;</span><br><span class="line">  <span class="keyword">return</span> skills;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">void</span> setSkills(List&lt;Integer&gt; skills) &#123;</span><br><span class="line">  <span class="keyword">this</span>.skills = skills;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>JAVA2Bytes.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JAVA2Bytes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">byte[] bytes = toBytes();</span><br><span class="line">toPlayer(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化</span></span><br><span class="line"><span class="comment"> * @throws IOException </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> byte[] toBytes() throws IOException&#123;</span><br><span class="line"></span><br><span class="line">Player player = <span class="keyword">new</span> Player(<span class="number">101</span>, <span class="number">20</span>, <span class="string">"peter"</span>);</span><br><span class="line">player.getSkills().add(<span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入对象</span></span><br><span class="line">objectOutputStream.writeObject(player);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 字节数组</span></span><br><span class="line"><span class="comment">//ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);</span></span><br><span class="line"><span class="comment">//最终是写到byteArrayOutputStream中，所以通过byteArrayOutputStream获得。</span></span><br><span class="line">byte[] byteArray = byteArrayOutputStream.toByteArray();</span><br><span class="line">System.out.println(Arrays.toString(byteArray));</span><br><span class="line"><span class="keyword">return</span> byteArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化</span></span><br><span class="line"><span class="comment"> * @param bs</span></span><br><span class="line"><span class="comment"> * @throws Exception </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> toPlayer(byte[] bs) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bs));</span><br><span class="line">Player player = (Player)inputStream.readObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"> System.out.println(<span class="string">"playerId:"</span> + player.getPlayerId());</span><br><span class="line"> System.out.println(<span class="string">"age:"</span> + player.getAge());</span><br><span class="line"> System.out.println(<span class="string">"name:"</span> + player.getName());</span><br><span class="line"> System.out.println(<span class="string">"skills:"</span> + (Arrays.toString(player.getSkills().toArray())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">-84</span>,<span class="number">-19</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">115</span>,<span class="number">114</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">99</span>,<span class="number">111</span>,<span class="number">109</span>,<span class="number">46</span>,<span class="number">106</span>,<span class="number">97</span>,<span class="number">118</span>,<span class="number">97</span>,<span class="number">46</span>,<span class="number">80</span>,<span class="number">108.</span>.......]</span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line">peter</span><br><span class="line"><span class="number">1001</span></span><br></pre></td></tr></table></figure><p></p><h1 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h1><p>java序列化出来的字节数组比proto buff的长很多，字节数组短的话能够减少很多的带宽。</p><p>为什么？</p><p>java中的字节数组包括这个类的类信息、这个类有哪个字段、协议头、每个类叫什么名称、每个类是什么类型的、最后的数值是多少等。</p><p>proto buff不许要有配置文件，java不需要只要双方都是java就行，所以proto buff其实是把类的名称、类型、字段等都写到了配置文件中，所以在序列化的时候集成了这些描述信息，所以字节很短。</p><p>proto buff分配空间是有伸缩性的，比如int 在内存中是 4 个字节，proto buff根据实际大小分配1-5个字节，从概率学的角度讲大部分可能都是一个或者两个字节</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基于Netty的RPC架构学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84RPC%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Netty" scheme="http://mmmmmm.me/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>基于Netty的RPC架构学习笔记（七）：netty学习之心跳</title>
    <link href="http://mmmmmm.me/2019-03-10-7.html"/>
    <id>http://mmmmmm.me/2019-03-10-7.html</id>
    <published>2019-03-10T02:21:07.000Z</published>
    <updated>2019-03-10T15:09:07.694Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="idleStateHandler"><a href="#idleStateHandler" class="headerlink" title="idleStateHandler"></a>idleStateHandler</h1><p>Netty提供的检测会话状态的工具。</p><h2 id="netty3🌰"><a href="#netty3🌰" class="headerlink" title="netty3🌰"></a>netty3🌰</h2><p>Server.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package com.heart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelPipelineFactory;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.Channels;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.util.HashedWheelTimer;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务类</span></span><br><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line"><span class="comment">//boss线程监听端口，worker线程负责数据读写</span></span><br><span class="line">ExecutorService boss = Executors.newCachedThreadPool();</span><br><span class="line">ExecutorService worker = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置niosocket工厂</span></span><br><span class="line">bootstrap.setFactory(<span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker));</span><br><span class="line"><span class="comment">//new一个定时器</span></span><br><span class="line">final HashedWheelTimer hashedWheelTimer = <span class="keyword">new</span> HashedWheelTimer();</span><br><span class="line"><span class="comment">//设置管道的工厂</span></span><br><span class="line">bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ChannelPipeline getPipeline() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line"><span class="comment">//需要在这里添加一个处理，handler才能处理</span></span><br><span class="line"><span class="comment">//IdleStateHandler参数，定时器（在上面定义了，需要new出来），读超时时间，写超时时间，读写超时时间。</span></span><br><span class="line">pipeline.addLast(<span class="string">"idle"</span>, <span class="keyword">new</span> IdleStateHandler(hashedWheelTimer, <span class="number">5</span>, <span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line">pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">pipeline.addLast(<span class="string">"helloHandler"</span>, <span class="keyword">new</span> HelloHandler());</span><br><span class="line"><span class="keyword">return</span> pipeline;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">10101</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"start!!!"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloHanler.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.heart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.MessageEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.SimpleChannelHandler;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.timeout.IdleState;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HelloHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> handleUpstream(final ChannelHandlerContext ctx, ChannelEvent e) throws Exception &#123;</span><br><span class="line"><span class="keyword">if</span> (e <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line"><span class="comment">//e.getState返回状态，如果太久没有读，就会返回read，如果太久没有写就会返回write，没有度也没有写返回ALL_IDE</span></span><br><span class="line"><span class="keyword">if</span>(((IdleStateEvent)e).getState() == IdleState.ALL_IDLE)&#123;</span><br><span class="line">System.out.println(<span class="string">"提示玩家下线"</span>);</span><br><span class="line"><span class="comment">//关闭会话，踢玩家下线</span></span><br><span class="line"><span class="comment">//回写给用户，提示会话将会关闭。</span></span><br><span class="line">ChannelFuture write = ctx.getChannel().write(<span class="string">"time out, you will close"</span>);</span><br><span class="line">write.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line"> ctx.getChannel().close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">super</span>.handleUpstream(ctx, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等10秒不读也不写就会自动关闭</p><h2 id="netty5🌰"><a href="#netty5🌰" class="headerlink" title="netty5🌰"></a>netty5🌰</h2><p>Server.java<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package com.heart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * netty5服务端</span></span><br><span class="line"><span class="comment"> * @au</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">//服务类</span></span><br><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line"><span class="comment">//boss和worker</span></span><br><span class="line">EventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//设置线程池</span></span><br><span class="line">bootstrap.group(boss, worker);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置socket工厂、</span></span><br><span class="line">bootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置管道工厂</span></span><br><span class="line">bootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected <span class="keyword">void</span> initChannel(Channel ch) throws Exception &#123;</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">5</span>, <span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//netty3中对应设置如下</span></span><br><span class="line"><span class="comment">//bootstrap.setOption("backlog", 1024);</span></span><br><span class="line"><span class="comment">//bootstrap.setOption("tcpNoDelay", true);</span></span><br><span class="line"><span class="comment">//bootstrap.setOption("keepAlive", true);</span></span><br><span class="line"><span class="comment">//设置参数，TCP参数</span></span><br><span class="line">bootstrap.option(ChannelOption.SO_BACKLOG, <span class="number">2048</span>);<span class="comment">//serverSocketchannel的设置，链接缓冲池的大小</span></span><br><span class="line">bootstrap.childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>);<span class="comment">//socketchannel的设置,维持链接的活跃，清除死链接</span></span><br><span class="line">bootstrap.childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>);<span class="comment">//socketchannel的设置,关闭延迟发送</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定端口</span></span><br><span class="line">ChannelFuture future = bootstrap.bind(<span class="number">10101</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"start"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待服务端关闭</span></span><br><span class="line">future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">boss.shutdownGracefully();</span><br><span class="line">worker.shutdownGracefully();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>ServerHandler.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package com.heart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleState;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端消息处理</span></span><br><span class="line"><span class="comment"> * @</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected <span class="keyword">void</span> messageReceived(ChannelHandlerContext ctx, <span class="built_in">String</span> msg) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(msg);</span><br><span class="line"></span><br><span class="line">ctx.channel().writeAndFlush(<span class="string">"hi"</span>);</span><br><span class="line">ctx.writeAndFlush(<span class="string">"hi"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> userEventTriggered(final ChannelHandlerContext ctx, <span class="built_in">Object</span> evt) throws Exception &#123;</span><br><span class="line"><span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">IdleStateEvent event = (IdleStateEvent)evt;</span><br><span class="line"><span class="keyword">if</span>(event.state() == IdleState.ALL_IDLE)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除超时会话</span></span><br><span class="line">ChannelFuture writeAndFlush = ctx.writeAndFlush(<span class="string">"you will close"</span>);</span><br><span class="line">writeAndFlush.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">ctx.channel().close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新客户端接入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">System.out.println(<span class="string">"channelActive"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端断开</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">System.out.println(<span class="string">"channelInactive"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">cause.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>心跳其实就是一个普通的请求，特点数据简单，业务也简单</li></ol><ol start="2"><li>心跳对于服务端来说，定时清除闲置会话inactive(netty5) channelclose(netty3)</li></ol><p>假如客户端突然停电了，这个时候会话保存着，然后有电了之后，再次请求会重新建立会话，原来的会话就成了僵尸会话，需要定时去清理这些僵尸会话。后台还可以返回系统时间，达到一个防作弊的效果，前端修改系统时间可以达到一个游戏加速的作用。</p><ol start="3"><li>心跳对客户端来说，用来检测会话是否断开，是否重连！ 用来检测网络延时！</li></ol><p>手机app中经常有断开连接、重新连接的操作。玩王者的时候右上角有一个网络延迟，就是心跳做的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;idleStateHandler&quot;&gt;&lt;a href=&quot;#idleStateHandler&quot; class=&quot;head
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基于Netty的RPC架构学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84RPC%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Netty" scheme="http://mmmmmm.me/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>基于Netty的RPC架构学习笔记（六）：netty5案例学习</title>
    <link href="http://mmmmmm.me/2019-03-10-6.html"/>
    <id>http://mmmmmm.me/2019-03-10-6.html</id>
    <published>2019-03-10T02:21:06.000Z</published>
    <updated>2019-03-12T11:56:54.826Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="netty5服务端入门案例"><a href="#netty5服务端入门案例" class="headerlink" title="netty5服务端入门案例"></a>netty5服务端入门案例</h1><p>Server.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package com.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- netty5服务端</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">  <span class="comment">//服务类</span></span><br><span class="line">  ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//boss和worker</span></span><br><span class="line">  <span class="comment">//在前面的3里面的例子这里是两个线程池，在5里面做了一次封装</span></span><br><span class="line">  <span class="comment">//EventLoopGroup这个类中还是包含线程池这个属性的</span></span><br><span class="line">  EventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">  EventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//设置线程池</span></span><br><span class="line">  bootstrap.group(boss, worker);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//设置socket工厂、</span></span><br><span class="line">  <span class="comment">//在3中 bootstrap.setFactory(new NioServerSocketChannelFactory(boss, worker));</span></span><br><span class="line">  </span><br><span class="line">  bootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//设置管道工厂</span></span><br><span class="line">  <span class="comment">//在3中bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123;</span></span><br><span class="line">  <span class="comment">//管道最终是要放到channel中的，这边不是把管道传过来，而是直接把拥有管道的channel，传过来，</span></span><br><span class="line">  <span class="comment">//我们自己去设置管道</span></span><br><span class="line">  bootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected <span class="keyword">void</span> initChannel(Channel ch) throws Exception &#123;</span><br><span class="line">  ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">  ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">  ch.pipeline().addLast(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//netty3中对应设置如下</span></span><br><span class="line">  <span class="comment">//bootstrap.setOption("backlog", 1024);</span></span><br><span class="line">  <span class="comment">//bootstrap.setOption("tcpNoDelay", true);</span></span><br><span class="line">  <span class="comment">//bootstrap.setOption("keepAlive", true);</span></span><br><span class="line">  <span class="comment">//设置参数，TCP参数</span></span><br><span class="line">  <span class="comment">//serverSocketchannel的设置，链接缓冲池的大小</span></span><br><span class="line">  <span class="comment">//accept操作是从缓存队列里面拿到主机，加入有2048个主机连接进来，第2049个主机想再次连接进来</span></span><br><span class="line">  <span class="comment">//就会被拒绝</span></span><br><span class="line">  bootstrap.option(ChannelOption.SO_BACKLOG, <span class="number">2048</span>);</span><br><span class="line">  <span class="comment">//socketchannel的设置,维持链接的活跃，清除死链接</span></span><br><span class="line">  <span class="comment">//加入有连接在很长一段时间既没有读也没有写，就会自动关掉这个连接</span></span><br><span class="line">  bootstrap.childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//socketchannel的设置,关闭延迟发送</span></span><br><span class="line">  <span class="comment">//tcp是有批量发送的算法的，这里设置为true，进行关闭</span></span><br><span class="line">  bootstrap.childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//绑定端口</span></span><br><span class="line">  ChannelFuture future = bootstrap.bind(<span class="number">10101</span>);</span><br><span class="line">  </span><br><span class="line">  System.out.println(<span class="string">"start"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//等待服务端关闭</span></span><br><span class="line">  <span class="comment">//这里的channel是serversocketchannel或者监听端口的channel</span></span><br><span class="line">  <span class="comment">//.sync()就会阻塞在这里等待channel关闭之后再继续往下走。</span></span><br><span class="line">  future.channel().closeFuture().sync();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">//释放资源</span></span><br><span class="line">  boss.shutdownGracefully();</span><br><span class="line">  worker.shutdownGracefully();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ServerHandler.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package com.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 服务端消息处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected <span class="keyword">void</span> messageReceived(ChannelHandlerContext ctx, <span class="built_in">String</span> msg) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到客户端发送的数据</span></span><br><span class="line"><span class="comment">//3中 String s = (String) e.getMessage()</span></span><br><span class="line"><span class="comment">//这里可以拿来直接用</span></span><br><span class="line">  System.out.println(msg);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//下面两种回写都是可以的，他们两个调用的是同一个方法</span></span><br><span class="line">  ctx.channel().writeAndFlush(<span class="string">"hi"</span>);</span><br><span class="line">  ctx.writeAndFlush(<span class="string">"hi"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 新客户端接入,相当于3中的channelConnected</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">"channelActive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 客户端断开</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @Override，相当于<span class="number">3</span>中的channelDisconnected</span><br><span class="line">    public <span class="keyword">void</span> channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">"channelInactive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过telnet进行测试</p><h1 id="netty5客户端入门案例"><a href="#netty5客户端入门案例" class="headerlink" title="netty5客户端入门案例"></a>netty5客户端入门案例</h1><p>Client.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package com.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- netty5的客户端</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">  <span class="comment">//服务类</span></span><br><span class="line">  Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">  <span class="comment">//因为boss是监听端口的所以这里只需要worker</span></span><br><span class="line">  <span class="comment">//worker</span></span><br><span class="line">  EventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//设置线程池</span></span><br><span class="line">  bootstrap.group(worker);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//设置socket工厂、</span></span><br><span class="line">  bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//设置管道</span></span><br><span class="line">  bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected <span class="keyword">void</span> initChannel(Channel ch) throws Exception &#123;</span><br><span class="line">  ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">  ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">  ch.pipeline().addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  ChannelFuture connect = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">10101</span>);</span><br><span class="line">  </span><br><span class="line">  BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  System.out.println(<span class="string">"请输入："</span>);</span><br><span class="line">  <span class="built_in">String</span> msg = bufferedReader.readLine();</span><br><span class="line">  connect.channel().writeAndFlush(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">  worker.shutdownGracefully();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ClientHandler</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 客户端消息处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected <span class="keyword">void</span> messageReceived(ChannelHandlerContext ctx, <span class="built_in">String</span> msg) throws Exception &#123;</span><br><span class="line">  System.out.println(<span class="string">"客户端收到消息:"</span>+msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单客户端多连接程序"><a href="#单客户端多连接程序" class="headerlink" title="单客户端多连接程序"></a>单客户端多连接程序</h1><h2 id="知识普及"><a href="#知识普及" class="headerlink" title="知识普及"></a>知识普及</h2><h3 id="线程池原理图"><a href="#线程池原理图" class="headerlink" title="线程池原理图"></a>线程池原理图</h3><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312195557528.png"><br>当任务进来的时候，将任务放到各个线程对应的队列中，线程没有任务了就去队列里面取，因为有这些队列的存在所以是并发执行。<br>一个thread+队列======》一个单线程线程池 ======》线程安全的，任务是线性执行的</p><p>维护多个缓存对象通常会有两种设计方案，一种是做成对象池，一种是做成对象组。</p><h3 id="对象池原理图"><a href="#对象池原理图" class="headerlink" title="对象池原理图"></a>对象池原理图</h3><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312195557722.png"><br>初始化n个对象放到队列中，如果队列中有拿出来直接用，如果队列中没有可以创建一个对象，拿去用，用完之后归还给线程池，发现多了一个对象，可以直接销毁，也可以等待线程池中有可用的对象再执行相关的任务。<br>对象池通常用在，对象是线程不安全的或者对象在多线程并发的时候会出现阻塞效应的时候。</p><h3 id="对象组原理图"><a href="#对象组原理图" class="headerlink" title="对象组原理图"></a>对象组原理图</h3><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312195557719.png"><br>因为对象还在数组中，所以不需要归还对象。<br>数组中的对象可能会被多个对象访问，所以需要数组中的对象具有锁并发的能力，否则不适合用对象组的方式</p><p>在这个例子中Netty要并发写的是channel</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>单个线程安全，不会产生阻塞效应，使用对象组<br>单个线程不安全，会产生阻塞效应，使用对象池</p><h3 id="理论结合实际"><a href="#理论结合实际" class="headerlink" title="理论结合实际"></a>理论结合实际</h3><p>netty中的channel是支持并发的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">connect.channel().writeAndFlush(msg)<span class="comment">//writeAndFlush往下点</span></span><br><span class="line">|</span><br><span class="line">AbstractChannelHandlerContext<span class="comment">//writeAndFlush点击invokeWrite</span></span><br><span class="line">|</span><br><span class="line">DefaultChannelHandleInvoker</span><br><span class="line"><span class="comment">//关注writeAndFlush方法，假如当前是worker线程，就直接写，假如不是就封装成一个任务扔到一个线程池中，safeExecuteOutbound方法</span></span><br><span class="line">|</span><br><span class="line"><span class="comment">//进入safeExecuteOutbound，里面的线程池是一个NioEventoop对象，继承自SingleThreadEventLoop，</span></span><br><span class="line"><span class="comment">//再继承SingleThreadEventLoopExecuter，即单线程线程池</span></span><br></pre></td></tr></table></figure><p>一个thread+队列======》一个单线程线程池 ======》线程安全的，任务是线性执行的</p><p>因为channel是线程安全的，所以最后采用对象组的方式。</p><h2 id="开干开干"><a href="#开干开干" class="headerlink" title="开干开干"></a>开干开干</h2><p>MultClient.java<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">package com.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 多连接客户端</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">MultClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 服务类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 会话    缓存客户端的连接。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private List&lt;Channel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 引用计数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private final AtomicInteger index = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 初始化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - @param count</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    public <span class="keyword">void</span> init(int count)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//worker</span></span><br><span class="line">    EventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程池</span></span><br><span class="line">    bootstrap.group(worker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置socket工厂、</span></span><br><span class="line">    bootstrap.channel(NioSocketChannel.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置管道</span></span><br><span class="line">    bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected <span class="keyword">void</span> initChannel(Channel ch) throws Exception &#123;</span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=count; i++)&#123;</span><br><span class="line">    ChannelFuture future = bootstrap.connect(<span class="string">"192.168.0.103"</span>, <span class="number">10101</span>);</span><br><span class="line">    channels.add(future.channel());</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 获取会话</span></span><br><span class="line"><span class="comment">  - @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    public Channel nextChannel()&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirstActiveChannel(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  private Channel getFirstActiveChannel(int count)&#123;</span><br><span class="line">  Channel channel = channels.get(<span class="built_in">Math</span>.abs(index.getAndIncrement() % channels.size()));</span><br><span class="line">  <span class="keyword">if</span>(!channel.isActive())&#123;</span><br><span class="line">  <span class="comment">//重连</span></span><br><span class="line">  reconnect(channel);</span><br><span class="line">  <span class="comment">//如果已经没有channel可用了</span></span><br><span class="line">  <span class="keyword">if</span>(count &gt;= channels.size())&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"no can use channel"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getFirstActiveChannel(count + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> channel;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 重连</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - @param channel</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private <span class="keyword">void</span> reconnect(Channel channel)&#123;</span><br><span class="line">    synchronized(channel)&#123;</span><br><span class="line">    <span class="comment">//如果是-1，说明已经不在channel数组中了，已经移除掉了</span></span><br><span class="line">    <span class="keyword">if</span>(channels.indexOf(channel) == <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    Channel newChannel = bootstrap.connect(<span class="string">"192.168.0.103"</span>, <span class="number">10101</span>).channel();</span><br><span class="line">    channels.set(channels.indexOf(channel), newChannel);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Start.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 启动类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- @au</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">Start</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  MultClient client = <span class="keyword">new</span> MultClient();</span><br><span class="line">  client.init(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">"请输入:"</span>);</span><br><span class="line">  <span class="built_in">String</span> msg = bufferedReader.readLine();</span><br><span class="line">  client.nextChannel().writeAndFlush(msg);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行======》输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">channelActive</span><br><span class="line">channelActive</span><br><span class="line">channelActive</span><br><span class="line">channelActive</span><br><span class="line">channelActive</span><br></pre></td></tr></table></figure><p>这个时候断开本机的网络（如果上面客户端尝试连接的是127.0.0.1的话，断开也能连接，所以即使是连接本机服务端，也要写成真正的ip地址），抛出异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException:no can use channel</span><br></pre></td></tr></table></figure><p>然后再次开启网络，在while true 的帮助下自动重连。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为channel本身就是线程安全的，所以多客户端连一个服务端的情况下，可以尝试非阻塞的方式，即对象组。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;netty5服务端入门案例&quot;&gt;&lt;a href=&quot;#netty5服务端入门案例&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基于Netty的RPC架构学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84RPC%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Netty" scheme="http://mmmmmm.me/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>基于Netty的RPC架构学习笔记（五）：netty线程模型源码分析（二）</title>
    <link href="http://mmmmmm.me/2019-03-10-5.html"/>
    <id>http://mmmmmm.me/2019-03-10-5.html</id>
    <published>2019-03-10T02:21:05.000Z</published>
    <updated>2019-03-10T15:09:02.915Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="小技巧（如何看开源框架的源码）"><a href="#小技巧（如何看开源框架的源码）" class="headerlink" title="小技巧（如何看开源框架的源码）"></a>小技巧（如何看开源框架的源码）</h1><p>一断点<br>二打印<br>三看调用栈<br>四搜索</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置niosocket工厂</span></span><br><span class="line"><span class="comment">//NioServerSocketChannelFactory看下面</span></span><br><span class="line">  bootstrap.setFactory(<span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker));</span><br></pre></td></tr></table></figure><p>NioServerSocketChannelFactory.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public NioServerSocketChannelFactory(</span><br><span class="line">            Executor bossExecutor, Executor workerExecutor) &#123;</span><br><span class="line">            <span class="comment">//首先获取当前worker的数量,代码看下面的SelectorUtil.java</span></span><br><span class="line">            <span class="comment">//接着会调用下面三个参数的构造方法NioServerSocketChannelFactory</span></span><br><span class="line">        <span class="keyword">this</span>(bossExecutor, workerExecutor, getMaxThreads(workerExecutor));</span><br><span class="line">&#125;</span><br><span class="line">public NioServerSocketChannelFactory(</span><br><span class="line">            Executor bossExecutor, Executor workerExecutor,</span><br><span class="line">            int workerCount) &#123;</span><br><span class="line">            <span class="comment">//接着调用下面四个参数的构造方法NioServerSocketChannelFactory</span></span><br><span class="line">            <span class="comment">//boss默认给的1</span></span><br><span class="line">        <span class="keyword">this</span>(bossExecutor, <span class="number">1</span>, workerExecutor, workerCount);</span><br><span class="line">&#125;</span><br><span class="line">public NioServerSocketChannelFactory(</span><br><span class="line">            Executor bossExecutor, int bossCount, Executor workerExecutor,</span><br><span class="line">            int workerCount) &#123;</span><br><span class="line">            <span class="comment">//开始new一个worker的池子</span></span><br><span class="line">            <span class="comment">//代码看下面的NioWorkerPool.java</span></span><br><span class="line">        <span class="keyword">this</span>(bossExecutor, bossCount, <span class="keyword">new</span> NioWorkerPool(workerExecutor, workerCount));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SelectorUtil.java<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认数量是当前的核数成2</span></span><br><span class="line"><span class="keyword">static</span> final int DEFAULT_IO_THREADS = Runtime.getRuntime().availableProcessors() * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"> private <span class="keyword">static</span> int getMaxThreads(Executor executor) &#123;</span><br><span class="line"> <span class="comment">//MaxThreads最大池大小</span></span><br><span class="line">        <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> ThreadPoolExecutor) &#123;</span><br><span class="line">            final int maxThreads = ((ThreadPoolExecutor) executor).getMaximumPoolSize();</span><br><span class="line">            <span class="comment">//取maxThreads和DEFAULT_IO_THREADS两者的最小值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.min(maxThreads, SelectorUtil.DEFAULT_IO_THREADS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为我们之前的例子中是给的无限大小的池子，所以这里返回DEFAULT_IO_THREADS</span></span><br><span class="line">        <span class="keyword">return</span> SelectorUtil.DEFAULT_IO_THREADS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>NioWorkerPool.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public NioWorkerPool(Executor workerExecutor, int workerCount) &#123;</span><br><span class="line"><span class="comment">//调用自己的NioWorkerPool方法，在下面</span></span><br><span class="line">        <span class="keyword">this</span>(workerExecutor, workerCount, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">public NioWorkerPool(Executor workerExecutor, int workerCount, ThreadNameDeterminer determiner) &#123;</span><br><span class="line"><span class="comment">//调用父类的构造方法</span></span><br><span class="line">        <span class="keyword">super</span>(workerExecutor, workerCount, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">this</span>.determiner = determiner;</span><br><span class="line">        <span class="comment">//init了一次,代码看下面init方法</span></span><br><span class="line">        init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现了抽象方法newWorker</span></span><br><span class="line">@Override</span><br><span class="line">protected NioWorker newWorker(Executor executor) &#123;</span><br><span class="line"><span class="comment">//new了一个NioWorker</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NioWorker(executor, determiner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NioWOrker.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public NioWorker(Executor executor, ThreadNameDeterminer determiner) &#123;</span><br><span class="line"><span class="comment">//调用父类方法，看下面AbstractNioWorker.java</span></span><br><span class="line">        <span class="keyword">super</span>(executor, determiner);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">    protected boolean read(SelectionKey k) &#123;</span><br><span class="line">        final SocketChannel ch = (SocketChannel) k.channel();</span><br><span class="line">        final NioSocketChannel channel = (NioSocketChannel) k.attachment();</span><br><span class="line"></span><br><span class="line">        final ReceiveBufferSizePredictor predictor =</span><br><span class="line">            channel.getConfig().getReceiveBufferSizePredictor();</span><br><span class="line">        final int predictedRecvBufSize = predictor.nextReceiveBufferSize();</span><br><span class="line">        final ChannelBufferFactory bufferFactory = channel.getConfig().getBufferFactory();</span><br><span class="line"></span><br><span class="line">        int ret = <span class="number">0</span>;</span><br><span class="line">        int readBytes = <span class="number">0</span>;</span><br><span class="line">        boolean failure = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        ByteBuffer bb = recvBufferPool.get(predictedRecvBufSize).order(bufferFactory.getDefaultOrder());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((ret = ch.read(bb)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                readBytes += ret;</span><br><span class="line">                <span class="keyword">if</span> (!bb.hasRemaining()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            failure = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">            <span class="comment">// Can happen, and does not need a user attention.</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            fireExceptionCaught(channel, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (readBytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            bb.flip();</span><br><span class="line"><span class="comment">//在这里封装成了ChannelBuffer</span></span><br><span class="line">            final ChannelBuffer buffer = bufferFactory.getBuffer(readBytes);</span><br><span class="line">            buffer.setBytes(<span class="number">0</span>, bb);</span><br><span class="line">            buffer.writerIndex(readBytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update the predictor.</span></span><br><span class="line">            predictor.previousReceiveBufferSize(readBytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Fire the event.产生一个上传的事件</span></span><br><span class="line">            <span class="comment">//channels里面的一个方法</span></span><br><span class="line">             <span class="comment">//   * @param message  the received message </span></span><br><span class="line">    <span class="comment">//public static void fireMessageReceived(Channel channel, Object message) &#123;</span></span><br><span class="line">        <span class="comment">//fireMessageReceived(channel, message, null);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">            fireMessageReceived(channel, buffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span> || failure) &#123;</span><br><span class="line">            k.cancel(); <span class="comment">// Some JDK implementations run into an infinite loop without this.</span></span><br><span class="line">            close(channel, succeededFuture(channel));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>AbstractNioWorker.java<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">AbstractNioWorker(Executor executor, ThreadNameDeterminer determiner) &#123;</span><br><span class="line"><span class="comment">//又调用了父类的抽象方法，看下面AbstractNioSelector.java</span></span><br><span class="line">        <span class="keyword">super</span>(executor, determiner);</span><br><span class="line"> &#125;</span><br><span class="line">  @Override</span><br><span class="line">    protected <span class="keyword">void</span> process(Selector selector) throws IOException &#123;</span><br><span class="line">        <span class="built_in">Set</span>&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">        <span class="comment">// check if the set is empty and if so just return to not create garbage by</span></span><br><span class="line">        <span class="comment">// creating a new Iterator every time even if there is nothing to process.</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/597</span></span><br><span class="line">        <span class="keyword">if</span> (selectedKeys.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;SelectionKey&gt; i = selectedKeys.iterator(); i.hasNext();) &#123;</span><br><span class="line">            SelectionKey k = i.next();</span><br><span class="line">            i.remove();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                int readyOps = k.readyOps();</span><br><span class="line">                <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_READ) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//读数据，向上看NioWorker中的read方法</span></span><br><span class="line">                    <span class="keyword">if</span> (!read(k)) &#123;</span><br><span class="line">                        <span class="comment">// Connection already closed - no need to handle write.</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">                    writeFromSelectorLoop(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">                close(k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cleanUpCancelledKeys()) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// break the loop to avoid ConcurrentModificationException</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>AbstractNioSelector.java<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">AbstractNioSelector(Executor executor, ThreadNameDeterminer determiner) &#123;</span><br><span class="line"><span class="comment">//给了一个线程池</span></span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line"><span class="comment">//openSelector看下面openSelector方法</span></span><br><span class="line">        openSelector(determiner);</span><br><span class="line">&#125;</span><br><span class="line">private <span class="keyword">void</span> openSelector(ThreadNameDeterminer determiner) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//设置当前的selector</span></span><br><span class="line">            selector = SelectorUtil.open();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Failed to create a selector."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the worker thread with the new Selector.</span></span><br><span class="line">        boolean success = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//把这个Nioworker跑起来，因为NioWorker本身是继承AbstractNioSelector这个类的</span></span><br><span class="line">        <span class="comment">//所以跑的是这个类的run方法</span></span><br><span class="line">        <span class="comment">//从哪里启动呢？往下看DeadLockProofWorker.java</span></span><br><span class="line">        <span class="comment">//也就是调用的newThreadRenamingRunnable(id, determiner)</span></span><br><span class="line">        <span class="comment">//newThreadRenamingRunnable看下面AbstractNioWorker.java</span></span><br><span class="line">            DeadLockProofWorker.start(executor, newThreadRenamingRunnable(id, determiner));</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="comment">// Release the Selector if the execution fails.</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Failed to close a selector."</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">                selector = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// The method will return to the caller at this point.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        assert selector != <span class="literal">null</span> &amp;&amp; selector.isOpen();</span><br><span class="line">    &#125;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">//标记wakenup状态</span></span><br><span class="line">            wakenUp.set(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//状态监测的代码</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//取任务</span></span><br><span class="line">            processTaskQueue();</span><br><span class="line"><span class="comment">//业务处理，这是一个抽象方法，被三个类实现AbstractNioWorker、NioClientBoss、</span></span><br><span class="line"><span class="comment">//AbstractNioWorker中的process在上方</span></span><br><span class="line"><span class="comment">//NioServerBoss中的process在下方</span></span><br><span class="line">process(selector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>NioServerBoss.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected <span class="keyword">void</span> process(Selector selector) &#123;</span><br><span class="line">      <span class="built_in">Set</span>&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">      <span class="keyword">if</span> (selectedKeys.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;SelectionKey&gt; i = selectedKeys.iterator(); i.hasNext();) &#123;</span><br><span class="line">          SelectionKey k = i.next();</span><br><span class="line">          i.remove();</span><br><span class="line">          NioServerSocketChannel channel = (NioServerSocketChannel) k.attachment();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// accept connections in a for loop until no new connection is ready</span></span><br><span class="line">              <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="comment">//accept事件</span></span><br><span class="line">                  SocketChannel acceptedSocket = channel.socket.accept();</span><br><span class="line">                  <span class="keyword">if</span> (acceptedSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//注册的方法在本类的下方，向worker线程里面注册任务</span></span><br><span class="line">                  registerAcceptedChannel(channel, acceptedSocket, thread);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">              <span class="comment">// Raised by accept() when the server socket was closed.</span></span><br><span class="line">              k.cancel();</span><br><span class="line">              channel.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">              <span class="comment">// Thrown every second to get ClosedChannelException</span></span><br><span class="line">              <span class="comment">// raised.</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">              <span class="comment">// Closed as requested.</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">              <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                  logger.warn(</span><br><span class="line">                          <span class="string">"Failed to accept a connection."</span>, t);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                  <span class="comment">// Ignore</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private <span class="keyword">static</span> <span class="keyword">void</span> registerAcceptedChannel(NioServerSocketChannel parent, SocketChannel acceptedSocket,</span><br><span class="line">                                       Thread currentThread) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          ChannelSink sink = parent.getPipeline().getSink();</span><br><span class="line">          ChannelPipeline pipeline =</span><br><span class="line">                  parent.getConfig().getPipelineFactory().getPipeline();</span><br><span class="line">                  <span class="comment">//找到一个worker,通过下面的方法把每个工作均匀的分配给每一个worker</span></span><br><span class="line">                  <span class="comment">// public E nextWorker() &#123;</span></span><br><span class="line">      <span class="comment">//return (E) workers[Math.abs(workerIndex.getAndIncrement() % workers.length)];</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">          NioWorker worker = parent.workerPool.nextWorker();</span><br><span class="line">          <span class="comment">//向worker里面注册任务，而不是直接去操作worker</span></span><br><span class="line">          <span class="comment">//让他关注一下socketchannel，即acceptedSocket注册这个东西</span></span><br><span class="line">          <span class="comment">//因为register这个方法是继承AbstractNioSelector的，即完成之后需要提交任务并记过wakenup</span></span><br><span class="line">         <span class="comment">//代码粘贴过来了</span></span><br><span class="line">          <span class="comment">//public void register(Channel channel, ChannelFuture future) &#123;</span></span><br><span class="line">      <span class="comment">//Runnable task = createRegisterTask(channel, future);</span></span><br><span class="line">      <span class="comment">//registerTask(task);</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"> <span class="comment">// protected final void registerTask(Runnable task) &#123;</span></span><br><span class="line">     <span class="comment">// taskQueue.add(task);</span></span><br><span class="line">      <span class="comment">//Selector selector = this.selector;</span></span><br><span class="line">      <span class="comment">//if (selector != null) &#123;</span></span><br><span class="line">          <span class="comment">//if (wakenUp.compareAndSet(false, true)) &#123;</span></span><br><span class="line">              <span class="comment">//selector.wakenup();</span></span><br><span class="line">          <span class="comment">//&#125;</span></span><br><span class="line">      <span class="comment">//&#125; else &#123;</span></span><br><span class="line">          <span class="comment">//if (taskQueue.remove(task)) &#123;</span></span><br><span class="line">              <span class="comment">// the selector was null this means the Worker has already been shutdown.</span></span><br><span class="line">              <span class="comment">//throw new RejectedExecutionException("Worker has already been shutdown");</span></span><br><span class="line">          <span class="comment">//&#125;</span></span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line">          worker.register(<span class="keyword">new</span> NioAcceptedSocketChannel(</span><br><span class="line">                  parent.getFactory(), pipeline, parent, sink</span><br><span class="line">                  , acceptedSocket,</span><br><span class="line">                  worker, currentThread), <span class="literal">null</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">              logger.warn(</span><br><span class="line">                      <span class="string">"Failed to initialize an accepted socket."</span>, e);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              acceptedSocket.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">              <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                  logger.warn(</span><br><span class="line">                          <span class="string">"Failed to close a partially accepted socket."</span>,</span><br><span class="line">                          e2);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>AbstractNioWorker.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected ThreadRenamingRunnable newThreadRenamingRunnable(int id, ThreadNameDeterminer determiner) &#123;</span><br><span class="line"><span class="comment">//this当前的NioWorker，然后给了一个线程的名称</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadRenamingRunnable(<span class="keyword">this</span>, <span class="string">"New I/O worker #"</span> + id, determiner);</span><br><span class="line">    &#125;</span><br><span class="line">public ThreadRenamingRunnable(Runnable runnable, <span class="built_in">String</span> proposedThreadName, ThreadNameDeterminer determiner) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runnable == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"runnable"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (proposedThreadName == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"proposedThreadName"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.runnable = runnable;</span><br><span class="line">        <span class="keyword">this</span>.determiner = determiner;</span><br><span class="line">        <span class="keyword">this</span>.proposedThreadName = proposedThreadName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里runnable执行其实就是NioWorker进行了run</span></span><br><span class="line"><span class="comment">//NioWorker.run其实是运行父类的AbstractNioWorker run</span></span><br><span class="line"><span class="comment">//AbstractNioWorker 的run又调用的是父类AbstractNioSelector的run方法</span></span><br><span class="line"><span class="comment">//AbstractNioSelector的run方法,往上面看</span></span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>DeadLockProofWorker.java<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public final <span class="class"><span class="keyword">class</span> <span class="title">DeadLockProofWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An &lt;em&gt;internal use only&lt;/em&gt; thread-local variable that tells the</span></span><br><span class="line"><span class="comment">     * &#123;@link Executor&#125; that this worker acquired a worker thread from.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="keyword">static</span> final ThreadLocal&lt;Executor&gt; PARENT = <span class="keyword">new</span> ThreadLocal&lt;Executor&gt;();</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> start(final Executor parent, final Runnable runnable) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"parent"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (runnable == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"runnable"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//通过线程池启动一个Runnable</span></span><br><span class="line">        parent.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            public <span class="keyword">void</span> run() &#123;</span><br><span class="line">                PARENT.set(parent);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//调用Runnable的run方法，然后返回去看</span></span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    PARENT.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private DeadLockProofWorker() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>AbstractNioWorkerPool.java<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里到了他的父类AbstractNioWorkerPool</span></span><br><span class="line">blic <span class="keyword">void</span> run() &#123;</span><br><span class="line">        thread = Thread.currentThread();</span><br><span class="line">        startupLatch.countDown();</span><br><span class="line"></span><br><span class="line">        int selectReturnsImmediately = <span class="number">0</span>;</span><br><span class="line">        Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组workers</span></span><br><span class="line">private final AbstractNioWorker[] workers;</span><br><span class="line"><span class="comment">//父类的构造方法方法</span></span><br><span class="line">AbstractNioWorkerPool(Executor workerExecutor, int workerCount, boolean autoInit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (workerExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"workerExecutor"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (workerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"workerCount ("</span> + workerCount + <span class="string">") "</span> + <span class="string">"must be a positive integer."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有一个workers的数组，new了workerCount的数组</span></span><br><span class="line">        workers = <span class="keyword">new</span> AbstractNioWorker[workerCount];</span><br><span class="line">        <span class="keyword">this</span>.workerExecutor = workerExecutor;</span><br><span class="line">        <span class="keyword">if</span> (autoInit) &#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">protected <span class="keyword">void</span> init() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!initialized.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"initialized already"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; workers.length; i++) &#123;</span><br><span class="line">        <span class="comment">//对worker进行初始化，具体实现往下看</span></span><br><span class="line">            workers[i] = newWorker(workerExecutor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        waitForWorkerThreads();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是一个抽象方法，具体实现看上面的NioWorkerPool.java中的newWorker方法</span></span><br><span class="line">protected abstract E newWorker(Executor executor);</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    public E nextWorker() &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) workers[<span class="built_in">Math</span>.abs(workerIndex.getAndIncrement() % workers.length)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> rebuildSelectors() &#123;</span><br><span class="line">        <span class="keyword">for</span> (AbstractNioWorker worker: workers) &#123;</span><br><span class="line">            worker.rebuildSelector();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="阅读源码技巧"><a href="#阅读源码技巧" class="headerlink" title="阅读源码技巧"></a>阅读源码技巧</h1><h2 id="打印查看"><a href="#打印查看" class="headerlink" title="打印查看"></a>打印查看</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">sout(Thread.currentThread().getName()+<span class="string">" "</span>+wakenup);</span><br><span class="line">wakenUp.set(<span class="literal">false</span>);</span><br><span class="line">...</span><br><span class="line">sout(Thread.currentThread().getName()+<span class="string">" "</span>+select);</span><br><span class="line">int selected = select(selector);</span><br><span class="line">...</span><br><span class="line">sout(Thread.currentThread().getName()+<span class="string">" "</span>+processTaskQueue);</span><br><span class="line">processTaskQueue();</span><br><span class="line">...</span><br><span class="line">sout(Thread.currentThread().getName()+<span class="string">" "</span>+process);</span><br><span class="line">process(selector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">New I/O server boss #2 process </span><br><span class="line">New I/O server boss #2 wakenup </span><br><span class="line">New I/O server boss #2 select </span><br><span class="line">New I/O server boss #2 processTaskQueue</span><br><span class="line">New I/O server boss #2 process</span><br><span class="line">New I/O server boss #2 wakenup </span><br><span class="line">New I/O server boss #2 select </span><br><span class="line">...</span><br><span class="line">New I/O worker #1 wakenup</span><br><span class="line">New I/O worker #1 select</span><br><span class="line">New I/O worker #1 processTaskQueue</span><br><span class="line">New I/O worker #1 process</span><br><span class="line">New I/O worker #1 wakenup</span><br><span class="line">New I/O worker #1 select</span><br><span class="line">New I/O worker #1 processTaskQueue</span><br><span class="line">New I/O worker #1 process</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到worker是四个四个循环往复，可是boss线程为什么在select就没有继续执行了？</p><h2 id="通过打断点调试"><a href="#通过打断点调试" class="headerlink" title="通过打断点调试"></a>通过打断点调试</h2><p>将断点打在wakenup.set<br>为了只看boss线程，eclipse进入断点的控制页面–》右上角breanpoints–》选中本类右击–》BreakPoint Properties–》新的页面中勾选Conditional–》下面输入“Thread.currentThread().getName().contains(“boss”)”–》点击ok</p><p>通过打断点发现到了select方法的时候点进去，然后没有执行默认的select（500），这样的方法，而是执行的select（）这种阻塞的方式，所以阻塞住了。</p><h2 id="查看调用栈"><a href="#查看调用栈" class="headerlink" title="查看调用栈"></a>查看调用栈</h2><p>通过查看调用栈的方式查看某个方法具体调用的堆栈信息<br>eclipse在debug界面的左上角<br>idea在debug界面的左下角</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;小技巧（如何看开源框架的源码）&quot;&gt;&lt;a href=&quot;#小技巧（如何看开源框架的源码）&quot; class=&quot;header
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基于Netty的RPC架构学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84RPC%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Netty" scheme="http://mmmmmm.me/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>基于Netty的RPC架构学习笔记（四）：netty线程模型源码分析（一）</title>
    <link href="http://mmmmmm.me/2019-03-10-4.html"/>
    <id>http://mmmmmm.me/2019-03-10-4.html</id>
    <published>2019-03-10T02:21:04.000Z</published>
    <updated>2019-03-12T11:56:59.971Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="如何提高NIO的工作效率"><a href="#如何提高NIO的工作效率" class="headerlink" title="如何提高NIO的工作效率"></a>如何提高NIO的工作效率</h1><h2 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h2><p>前面第一节中的NIO代码<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> listen() throws IOException &#123;</span><br><span class="line">System.out.println(<span class="string">"服务端启动成功！"</span>);</span><br><span class="line"><span class="comment">// 轮询访问selector</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 当注册的事件到达时，方法返回；否则,该方法会一直阻塞</span></span><br><span class="line"><span class="comment">//点不进去select方法，因为底层是c写的</span></span><br><span class="line">selector.select();</span><br><span class="line"><span class="comment">// 获得selector中选中的项的迭代器，选中的项为注册的事件</span></span><br><span class="line">Iterator&lt;?&gt; ite = <span class="keyword">this</span>.selector.selectedKeys().iterator();</span><br><span class="line"><span class="keyword">while</span> (ite.hasNext()) &#123;</span><br><span class="line">SelectionKey key = (SelectionKey) ite.next();</span><br><span class="line"><span class="comment">// 删除已选的key,以防重复处理</span></span><br><span class="line">ite.remove();</span><br><span class="line">handler(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>仅仅修改成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> listen() throws IOException &#123;</span><br><span class="line">System.out.println(<span class="string">"服务端启动成功！"</span>);</span><br><span class="line"><span class="comment">// 轮询访问selector</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 当注册的事件到达时，方法返回；否则,该方法会一直阻塞</span></span><br><span class="line"><span class="comment">//点不进去select方法，因为底层是c写的</span></span><br><span class="line">selector.select();</span><br><span class="line"><span class="comment">// 获得selector中选中的项的迭代器，选中的项为注册的事件</span></span><br><span class="line">Iterator&lt;?&gt; ite = <span class="keyword">this</span>.selector.selectedKeys().iterator();</span><br><span class="line"><span class="keyword">while</span> (ite.hasNext()) &#123;</span><br><span class="line">SelectionKey key = (SelectionKey) ite.next();</span><br><span class="line"><span class="comment">// 删除已选的key,以防重复处理</span></span><br><span class="line">ite.remove();</span><br><span class="line">newCachedThreadPool.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run()&#123;</span><br><span class="line">handler(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> handlerAccept(SelectionKey key) throws IOException &#123;</span><br><span class="line">ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line"><span class="comment">// 获得和客户端连接的通道，SocketChannel相当于传统io里面的Channel</span></span><br><span class="line">SocketChannel channel = server.accept();</span><br><span class="line"><span class="comment">// 设置成非阻塞</span></span><br><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里可以给客户端发送信息哦</span></span><br><span class="line">System.out.println(<span class="string">"新的客户端连接"</span>);</span><br><span class="line"><span class="comment">// 在和客户端连接成功之后，为了可以接收到客户端的信息，需要给通道设置读的权限。</span></span><br><span class="line">channel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过telnet请求一下</p><p>报错，空指针异常，因为虽然ite.remove，可是在handler（key）还没有处理完的时候就返回了，没有处理select方法并不不会阻塞，所以下次还是这个key去访问selector.select()，this.selector.selectedKeys()还是刚才的客户端，然后再进行一次handler，也就是这个ket又进行了一次accept，同一个key accept了两次。<br>看到上面的handleraccept方法，第一次已经accept到了客户端，所以第二次accept的时候就获取不到了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel channel = server.accept();</span><br></pre></td></tr></table></figure><p>获取不到channel，这行代码的下面就抛出了空指针异常。</p><p><strong><font color="red">综上：NIO的多线程不能通过上面的方式</font></strong></p><h2 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h2><h3 id="一个NIO是不是只能有一个selector？"><a href="#一个NIO是不是只能有一个selector？" class="headerlink" title="一个NIO是不是只能有一个selector？"></a>一个NIO是不是只能有一个selector？</h3><p>不是，一个系统可以有多个selector</p><h3 id="selector是不是只能注册一个ServerSocketChannel？"><a href="#selector是不是只能注册一个ServerSocketChannel？" class="headerlink" title="selector是不是只能注册一个ServerSocketChannel？"></a>selector是不是只能注册一个ServerSocketChannel？</h3><p>不是，可以注册多个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">scocketchannel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><p>selector既要负责大门，又要负责每个客人点菜的需求</p><h2 id="图说NettyIO"><a href="#图说NettyIO" class="headerlink" title="图说NettyIO"></a>图说NettyIO</h2><p>socketIO<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312195226359.png"><br>NIO<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312195423240.png"><br>NettyIO<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312195437178.png"><br>随着餐厅规模的越来越大，需要更多的服务生，如何分配这些服务生呢？每个服务生分配到不同的区域，管理不同的区域，大门的地方也可以分配一个服务生。</p><h1 id="如何构建一个多线程的NIO系统-🌰源码解读"><a href="#如何构建一个多线程的NIO系统-🌰源码解读" class="headerlink" title="如何构建一个多线程的NIO系统(🌰源码解读)"></a>如何构建一个多线程的NIO系统(🌰源码解读)</h1><p>下面是一个精简了Netty源码的小例子（从Netty中抽取部分代码并整合）<br>代码结构：<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312195226743.png"><br>start.java<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> com.cn.pool.NioSelectorRunnablePool;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 启动函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Start</span> </span>&#123;</span><br><span class="line"> public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">  <span class="comment">//初始化线程</span></span><br><span class="line">  <span class="comment">//NioSelectorRunnablePool是用来管理线程池的</span></span><br><span class="line">  <span class="comment">//给了两个线程池一个boss，一个worker</span></span><br><span class="line">  <span class="comment">//newCachedThreadPool 缓存的线程池，当一下子好多任务的时候，就开好多线程去做，如果没有任务</span></span><br><span class="line">  <span class="comment">//的时候，线程空闲下来的时候，慢慢线程的数量就会减少，自然消亡，简而言之就是线程的数量在某段时</span></span><br><span class="line">  <span class="comment">//间内是会扩张或者收缩的</span></span><br><span class="line">  <span class="comment">//这个类的构造函数在下面的NioSelectorRunnablePool.java</span></span><br><span class="line">  NioSelectorRunnablePool nioSelectorRunnablePool = <span class="keyword">new</span> NioSelectorRunnablePool(Executors.newCachedThreadPool(), Executors.newCachedThreadPool()); </span><br><span class="line">  <span class="comment">//获取服务类，将线程管理者交给服务类</span></span><br><span class="line">  <span class="comment">//具体看ServerBoosTrap.java</span></span><br><span class="line">  ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap(nioSelectorRunnablePool);  </span><br><span class="line">  <span class="comment">//绑定端口具体看ServerBoosTrap.java</span></span><br><span class="line">  bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">10101</span>));</span><br><span class="line">  System.out.println(<span class="string">"start"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>NioSelectorRunnablePool.java<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">package com.cn.pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> com.cn.NioServerBoss;</span><br><span class="line"><span class="keyword">import</span> com.cn.NioServerWorker;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- selector线程管理者</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">NioSelectorRunnablePool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - boss线程数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private final AtomicInteger bossIndex = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    private Boss[] bosses;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - worker线程数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private final AtomicInteger workerIndex = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    private Worker[] workeres;</span><br><span class="line"></span><br><span class="line">  public NioSelectorRunnablePool(Executor boss, Executor worker) &#123;</span><br><span class="line">  <span class="comment">//初始化线程池boss，默认是1的数量</span></span><br><span class="line">  <span class="comment">//往下一点点是initBoss这个方法</span></span><br><span class="line">  initBoss(boss, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//初始化worker，传入worker线程池，数量是系统的核心数量*2</span></span><br><span class="line">  <span class="comment">//往下看initWorker方法</span></span><br><span class="line">  initWorker(worker, Runtime.getRuntime().availableProcessors() * <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 初始化boss线程</span></span><br><span class="line"><span class="comment">  - @param boss</span></span><br><span class="line"><span class="comment">  - @param count</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private <span class="keyword">void</span> initBoss(Executor boss, int count) &#123;</span><br><span class="line">    <span class="comment">//NioServerBoss在下面NioServerBoss.java里面</span></span><br><span class="line">    <span class="keyword">this</span>.bosses = <span class="keyword">new</span> NioServerBoss[count];</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; bosses.length; i++) &#123;</span><br><span class="line">    <span class="comment">//回到这里对每一个boss初始化</span></span><br><span class="line">    <span class="comment">//构造方法在下面</span></span><br><span class="line">    bosses[i] = <span class="keyword">new</span> NioServerBoss(boss, <span class="string">"boss thread "</span> + (i+<span class="number">1</span>), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 初始化worker线程</span></span><br><span class="line"><span class="comment">  - @param worker</span></span><br><span class="line"><span class="comment">  - @param count</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private <span class="keyword">void</span> initWorker(Executor worker, int count) &#123;</span><br><span class="line">    <span class="keyword">this</span>.workeres = <span class="keyword">new</span> NioServerWorker[count];</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; workeres.length; i++) &#123;</span><br><span class="line">    <span class="comment">//NioServerWorker在下面</span></span><br><span class="line">    workeres[i] = <span class="keyword">new</span> NioServerWorker(worker, <span class="string">"worker thread "</span> + (i+<span class="number">1</span>), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 获取一个worker</span></span><br><span class="line"><span class="comment">  - @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    public Worker nextWorker() &#123;</span><br><span class="line">     <span class="keyword">return</span> workeres[<span class="built_in">Math</span>.abs(workerIndex.getAndIncrement() % workeres.length)];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 获取一个boss</span></span><br><span class="line"><span class="comment">  - @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    public Boss nextBoss() &#123;</span><br><span class="line">     <span class="keyword">return</span> bosses[<span class="built_in">Math</span>.abs(bossIndex.getAndIncrement() % bosses.length)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>NioServerBoss,java<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package com.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ClosedChannelException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cn.pool.Boss;</span><br><span class="line"><span class="keyword">import</span> com.cn.pool.NioSelectorRunnablePool;</span><br><span class="line"><span class="keyword">import</span> com.cn.pool.Worker;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- boss实现类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="comment">//AbstractNioSelector在下面AbstractNioSelector.java这个类是selector的一个抽象类</span></span><br><span class="line">   <span class="comment">//为什么要是抽象类？</span></span><br><span class="line">   <span class="comment">//在门口的服务生和在里面为客人服务的服务生有很多共同点，比如关注多个地方，穿着一样</span></span><br><span class="line">   <span class="comment">//但是还有很多不同的地方，比如大门口的服务生说欢迎光临，大厅的服务生看哪里有点菜的需求</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">NioServerBoss</span> <span class="keyword">extends</span> <span class="title">AbstractNioSelector</span> <span class="title">implements</span> <span class="title">Boss</span></span>&#123;</span><br><span class="line">  public NioServerBoss(Executor executor, <span class="built_in">String</span> threadName, NioSelectorRunnablePool selectorRunnablePool) &#123;</span><br><span class="line">  <span class="comment">//调动的是其父类AbstractNioSelector的构造方法，往下看</span></span><br><span class="line">  <span class="keyword">super</span>(executor, threadName, selectorRunnablePool);</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  protected <span class="keyword">void</span> process(Selector selector) throws IOException &#123;</span><br><span class="line">  <span class="built_in">Set</span>&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">      <span class="keyword">if</span> (selectedKeys.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">for</span> (Iterator&lt;SelectionKey&gt; i = selectedKeys.iterator(); i.hasNext();) &#123;</span><br><span class="line">      SelectionKey key = i.next();</span><br><span class="line">      i.remove();</span><br><span class="line">      ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">  <span class="comment">//accept 新客户端</span></span><br><span class="line">  SocketChannel channel = server.accept();</span><br><span class="line">  <span class="comment">// 设置为非阻塞</span></span><br><span class="line">  channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// 通过线程管理者，获取一个worker，</span></span><br><span class="line">  <span class="comment">//门口的服务生引入客人后要带到某个区域的worker身边，告诉他你要负责这位客人。</span></span><br><span class="line">  Worker nextworker = getSelectorRunnablePool().nextWorker();</span><br><span class="line">  <span class="comment">// 注册新客户端接入任务</span></span><br><span class="line">  <span class="comment">//负责大厅的服务生给自己注册任务</span></span><br><span class="line">  <span class="comment">//registerNewChannelTask具体的实现看下面的NioServerWorker类</span></span><br><span class="line">  <span class="comment">//将当前的客户端注册给selector read事件</span></span><br><span class="line">  <span class="comment">//这么做的好处是什么？？？有效的解决高并发</span></span><br><span class="line">  <span class="comment">//往别的队列里面加任务，而不是直接去操作你的东西，你自己去处理这个任务，</span></span><br><span class="line">  nextworker.registerNewChannelTask(channel);</span><br><span class="line">  </span><br><span class="line">  System.out.println(<span class="string">"新客户端链接"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public <span class="keyword">void</span> registerAcceptChannelTask(final ServerSocketChannel serverChannel)&#123;</span><br><span class="line">   final Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">   <span class="comment">//注册完下面的事件之后，执行registerTask，具体看AbstractNioSelector.java</span></span><br><span class="line">   <span class="comment">//简而言之就是把任务放入队列，并wakenup</span></span><br><span class="line">   registerTask(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public <span class="keyword">void</span> run() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//注册serverChannel，accept到selector</span></span><br><span class="line">  serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  protected int select(Selector selector) throws IOException &#123;</span><br><span class="line">  <span class="keyword">return</span> selector.select();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>AbstractNioSelector.java<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">package com.cn;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> com.cn.pool.NioSelectorRunnablePool;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">- 抽象selector线程类</span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment">- */</span></span><br><span class="line">  public abstract <span class="class"><span class="keyword">class</span> <span class="title">AbstractNioSelector</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  - 线程池</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private final Executor executor;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  - 选择器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    protected Selector selector;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  - 选择器wakenUp状态标记</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    protected final AtomicBoolean wakenUp = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> - 任务队列</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private final Queue&lt;Runnable&gt; taskQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;Runnable&gt;();</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  - 线程名称</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private <span class="built_in">String</span> threadName;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  - 线程管理对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    protected NioSelectorRunnablePool selectorRunnablePool;</span><br><span class="line">    <span class="comment">//线程池、线程名、线程管理者</span></span><br><span class="line">  AbstractNioSelector(Executor executor, <span class="built_in">String</span> threadName, NioSelectorRunnablePool selectorRunnablePool) &#123;</span><br><span class="line">  <span class="keyword">this</span>.executor = executor;</span><br><span class="line">  <span class="keyword">this</span>.threadName = threadName;</span><br><span class="line">  <span class="keyword">this</span>.selectorRunnablePool = selectorRunnablePool;</span><br><span class="line">  <span class="comment">//最后openSelector，往下看往每一个线程里面加入了selector这个东西</span></span><br><span class="line">  <span class="comment">//一个线程加一个selector才有为多个客人服务的能力。</span></span><br><span class="line">  openSelector();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  - 获取selector并启动线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private <span class="keyword">void</span> openSelector() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to create a selector."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用线程池执行当前对象，运行当前线程</span></span><br><span class="line">    <span class="comment">//这里的this就是bosses[i] = new NioServerBoss(boss, "boss thread " + (i+1), this);</span></span><br><span class="line">    <span class="comment">//继承AbstractNioSelect又实现了Runnable，所以有一个run方法，看下面</span></span><br><span class="line">    executor.execute(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public <span class="keyword">void</span> run() &#123;</span><br><span class="line">  <span class="comment">//给当前线程赋一个名字</span></span><br><span class="line">  Thread.currentThread().setName(<span class="keyword">this</span>.threadName);</span><br><span class="line">  <span class="comment">//这里是最核心的，看完这里回去看NioSelectorRunnablePool的initWorker</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  wakenUp.set(<span class="literal">false</span>);  </span><br><span class="line">  <span class="comment">//selector的抽象方法有两个实现</span></span><br><span class="line">  <span class="comment">//boos中return selector.select();直接阻塞了</span></span><br><span class="line">  <span class="comment">//worker中return selector.select(500);超时时间500</span></span><br><span class="line">  select(selector);</span><br><span class="line">  <span class="comment">//执行队列中的任务</span></span><br><span class="line">  <span class="comment">//方法在下面</span></span><br><span class="line">  processTaskQueue(); </span><br><span class="line">  <span class="comment">//抽象方法被boss和worker实现，具体实现看上面的NioServerBoss和下面的NioServerWorker</span></span><br><span class="line">  process(selector);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="comment">// ignore</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  - 注册一个任务并激活selector</span></span><br><span class="line"><span class="comment">  - </span></span><br><span class="line"><span class="comment">  - @param task</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//简而言之就是把任务放入队列，并wakenup</span></span><br><span class="line">    protected final <span class="keyword">void</span> registerTask(Runnable task) &#123;</span><br><span class="line">    <span class="comment">//往队列中加了任务</span></span><br><span class="line">    taskQueue.add(task);</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">    <span class="keyword">if</span> (selector != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//wakenUp是一个原子的类，conpareAndSet，看他是不是false，是false的话就设置为true</span></span><br><span class="line">    <span class="keyword">if</span> (wakenUp.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="comment">//加入一个新的客户端，要立马激活selector的阻塞状态，即如果原来select或select（long）</span></span><br><span class="line">    <span class="comment">//被阻塞，调用这个方法将其立马返回。</span></span><br><span class="line">    <span class="comment">//可以看到上面哪个方法里wakenUp.set(false);  </span></span><br><span class="line">    <span class="comment">//看完这里回去接着看main方法中的第二行ServerBootstrap</span></span><br><span class="line">    selector.wakenup();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    taskQueue.remove(task);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 执行队列里的任务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    private <span class="keyword">void</span> processTaskQueue() &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    final Runnable task = taskQueue.poll();</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    task.run();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  - 获取线程管理对象</span></span><br><span class="line"><span class="comment">  - @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    public NioSelectorRunnablePool getSelectorRunnablePool() &#123;</span><br><span class="line">    <span class="keyword">return</span> selectorRunnablePool;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  - select抽象方法</span></span><br><span class="line"><span class="comment">  - </span></span><br><span class="line"><span class="comment">  - @param selector</span></span><br><span class="line"><span class="comment">  - @return</span></span><br><span class="line"><span class="comment">  - @throws IOException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    protected abstract int select(Selector selector) throws IOException;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  - selector的业务处理</span></span><br><span class="line"><span class="comment">  - </span></span><br><span class="line"><span class="comment">  - @param selector</span></span><br><span class="line"><span class="comment">  - @throws IOException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    protected abstract <span class="keyword">void</span> process(Selector selector) throws IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>NioServerWorker.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package com.cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ClosedChannelException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cn.pool.NioSelectorRunnablePool;</span><br><span class="line"><span class="keyword">import</span> com.cn.pool.Worker;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- worker实现类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="comment">//和NioServerBoss是一样的继承AbstractNioSelector</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">NioServerWorker</span> <span class="keyword">extends</span> <span class="title">AbstractNioSelector</span> <span class="title">implements</span> <span class="title">Worker</span></span>&#123;</span><br><span class="line">  <span class="comment">//和NioServerBoss是一样的运行父类的构造方法</span></span><br><span class="line">  <span class="comment">//跳转到上面的AbstractNioSelector类的构造方法</span></span><br><span class="line">  public NioServerWorker(Executor executor, <span class="built_in">String</span> threadName, NioSelectorRunnablePool selectorRunnablePool) &#123;</span><br><span class="line">  <span class="keyword">super</span>(executor, threadName, selectorRunnablePool);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected <span class="keyword">void</span> process(Selector selector) throws IOException &#123;</span><br><span class="line">  <span class="built_in">Set</span>&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">      <span class="keyword">if</span> (selectedKeys.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Iterator&lt;SelectionKey&gt; ite = <span class="keyword">this</span>.selector.selectedKeys().iterator();</span><br><span class="line">  <span class="keyword">while</span> (ite.hasNext()) &#123;</span><br><span class="line">  SelectionKey key = (SelectionKey) ite.next();</span><br><span class="line">  <span class="comment">// 移除，防止重复处理</span></span><br><span class="line">  ite.remove();</span><br><span class="line">  <span class="comment">// 得到事件发生的Socket通道</span></span><br><span class="line">  SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">  <span class="comment">// 数据总长度</span></span><br><span class="line">  int ret = <span class="number">0</span>;</span><br><span class="line">  boolean failure = <span class="literal">true</span>;</span><br><span class="line">  ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">  <span class="comment">//读取数据</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  ret = channel.read(buffer);</span><br><span class="line">  failure = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="comment">// ignore</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断是否连接已断开</span></span><br><span class="line">  <span class="keyword">if</span> (ret &lt;= <span class="number">0</span> || failure) &#123;</span><br><span class="line">  key.cancel();</span><br><span class="line">  System.out.println(<span class="string">"客户端断开连接"</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"收到数据:"</span> + <span class="keyword">new</span> <span class="built_in">String</span>(buffer.array())); </span><br><span class="line">   <span class="comment">//回写数据</span></span><br><span class="line">   ByteBuffer outBuffer = ByteBuffer.wrap(<span class="string">"收到\n"</span>.getBytes());</span><br><span class="line">   channel.write(outBuffer);<span class="comment">// 将消息回送给客户端</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 加入一个新的socket客户端</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    public <span class="keyword">void</span> registerNewChannelTask(final SocketChannel channel)&#123;</span><br><span class="line">     final Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">     <span class="comment">//registerTask方法是抽象的在AbstractNioSelector，往上面看</span></span><br><span class="line">     registerTask(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> run() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//将客户端注册到selector中</span></span><br><span class="line">    <span class="comment">//将当前的客户端注册给selector read事件</span></span><br><span class="line">    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected int select(Selector selector) throws IOException &#123;</span><br><span class="line">  <span class="keyword">return</span> selector.select(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServerBootstrap.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.cn;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> com.cn.pool.Boss;</span><br><span class="line"><span class="keyword">import</span> com.cn.pool.NioSelectorRunnablePool;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 服务类</span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="comment">//简单看下回到上面的main函数第三行绑定端口</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrap</span> </span>&#123;</span><br><span class="line">private NioSelectorRunnablePool selectorRunnablePool;</span><br><span class="line">public ServerBootstrap(NioSelectorRunnablePool selectorRunnablePool) &#123;</span><br><span class="line"><span class="keyword">this</span>.selectorRunnablePool = selectorRunnablePool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绑定端口</span></span><br><span class="line"><span class="comment"> * @param localAddress</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">void</span> bind(final SocketAddress localAddress)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 获得一个ServerSocket通道</span></span><br><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 设置通道为非阻塞</span></span><br><span class="line">serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 将该通道对应的ServerSocket绑定到port端口</span></span><br><span class="line">serverChannel.socket().bind(localAddress);</span><br><span class="line"><span class="comment">//获取一个boss线程，因为boss线程是专门负责监听端口的</span></span><br><span class="line">Boss nextBoss = selectorRunnablePool.nextBoss();</span><br><span class="line"><span class="comment">//向boss注册一个ServerSocket通道</span></span><br><span class="line"><span class="comment">//注册时间和上面的worker的注册时间类似</span></span><br><span class="line"><span class="comment">//具体看NioServerBoss.java</span></span><br><span class="line">nextBoss.registerAcceptChannelTask(serverChannel);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>boss.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.cn.pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- boss接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public interface Boss &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 加入一个新的ServerSocket</span></span><br><span class="line"><span class="comment">  - @param serverChannel</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    public <span class="keyword">void</span> registerAcceptChannelTask(ServerSocketChannel serverChannel);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>worker.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.cn.pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- worker接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public interface Worker &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 加入一个新的客户端会话</span></span><br><span class="line"><span class="comment">  - @param channel</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    public <span class="keyword">void</span> registerNewChannelTask(SocketChannel channel);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="学到的思想"><a href="#学到的思想" class="headerlink" title="学到的思想"></a>学到的思想</h1><p>上面的process方法被boss和worker继承，boss中除了给新客户端accept之外，还往worker的队列中加入了当前客户端的read任务<br>很多时候都是这样，我不会去操作你的某些东西，而是把任务放到的队列中，具体怎么执行和我无关，能够有效的解决高并发</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;如何提高NIO的工作效率&quot;&gt;&lt;a href=&quot;#如何提高NIO的工作效率&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基于Netty的RPC架构学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84RPC%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Netty" scheme="http://mmmmmm.me/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>基于Netty的RPC架构学习笔记（三）：netty客户端</title>
    <link href="http://mmmmmm.me/2019-03-10-3.html"/>
    <id>http://mmmmmm.me/2019-03-10-3.html</id>
    <published>2019-03-10T02:21:03.000Z</published>
    <updated>2019-03-10T15:08:58.448Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h1><p>Client.java</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package com.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.bootstrap.ClientBootstrap;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelPipelineFactory;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.Channels;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- netty客户端入门</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- =</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//服务类</span></span><br><span class="line">  ClientBootstrap bootstrap = <span class="keyword">new</span>  ClientBootstrap();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//线程池</span></span><br><span class="line">  ExecutorService boss = Executors.newCachedThreadPool();</span><br><span class="line">  ExecutorService worker = Executors.newCachedThreadPool();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//socket工厂</span></span><br><span class="line">  bootstrap.setFactory(<span class="keyword">new</span> NioClientSocketChannelFactory(boss, worker));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//管道工厂</span></span><br><span class="line">  bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public ChannelPipeline getPipeline() throws Exception &#123;</span><br><span class="line">  ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">  pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">  pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">  pipeline.addLast(<span class="string">"hiHandler"</span>, <span class="keyword">new</span> HiHandler());</span><br><span class="line">  <span class="keyword">return</span> pipeline;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//连接服务端</span></span><br><span class="line">  ChannelFuture connect = bootstrap.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">10101</span>));</span><br><span class="line">  Channel channel = connect.getChannel();</span><br><span class="line">  </span><br><span class="line">  System.out.println(<span class="string">"client start"</span>);</span><br><span class="line">  </span><br><span class="line">  Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  System.out.println(<span class="string">"请输入"</span>);</span><br><span class="line">  channel.write(scanner.next());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HiHandler.java<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package com.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelStateEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ExceptionEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.MessageEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.SimpleChannelHandler;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 消息接受处理类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- =</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">HiHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 接收消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> s = (<span class="built_in">String</span>) e.getMessage();</span><br><span class="line">    System.out.println(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.messageReceived(ctx, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 捕获异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">"exceptionCaught"</span>);</span><br><span class="line">    <span class="keyword">super</span>.exceptionCaught(ctx, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 新连接</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">"channelConnected"</span>);</span><br><span class="line">    <span class="keyword">super</span>.channelConnected(ctx, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 必须是链接已经建立，关闭通道的时候才会触发</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">"channelDisconnected"</span>);</span><br><span class="line">    <span class="keyword">super</span>.channelDisconnected(ctx, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - channel关闭的时候触发</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">"channelClosed"</span>);</span><br><span class="line">    <span class="keyword">super</span>.channelClosed(ctx, e);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>channelDisconnected与channelClosed的区别？<br>channelDisconnected只有在连接建立后断开才会调用<br>channelClosed无论连接是否成功都会调用关闭资源<br>在这里验证下：<br>当server没有开启的时候，client去请求，发现报错，然后只打印了channelClosed，而没有打印channelConnected<br>server开启并client和server正常交互后将服务端断开会打印channelDisconnected</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;举个🌰&quot;&gt;&lt;a href=&quot;#举个🌰&quot; class=&quot;headerlink&quot; title=&quot;举个🌰&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基于Netty的RPC架构学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84RPC%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Netty" scheme="http://mmmmmm.me/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>基于Netty的RPC架构学习笔记（二）：netty服务器</title>
    <link href="http://mmmmmm.me/2019-03-10-2.html"/>
    <id>http://mmmmmm.me/2019-03-10-2.html</id>
    <published>2019-03-10T02:21:02.000Z</published>
    <updated>2019-03-10T14:54:23.744Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>netty版本大致版本分为 netty3.x 和 netty4.x、netty5.x</p><p>netty可以运用在那些领域？</p><ol><li><p>分布式进程通信<br>例如: hadoop、dubbo、akka等具有分布式功能的框架，底层RPC通信都是基于netty实现的，这些框架使用的版本通常都还在用netty3.x</p></li><li><p>游戏服务器开发<br>最新的游戏服务器有部分公司可能已经开始采用netty4.x 或 netty5.x</p></li></ol><h1 id="Netty服务端Hello-World案例"><a href="#Netty服务端Hello-World案例" class="headerlink" title="Netty服务端Hello World案例"></a>Netty服务端Hello World案例</h1><h2 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h2><p>server.java<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package com.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelPipelineFactory;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.Channels;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- netty服务端入门</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//服务类</span></span><br><span class="line">  ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//boss线程监听端口，worker线程负责数据读写</span></span><br><span class="line">  ExecutorService boss = Executors.newCachedThreadPool();</span><br><span class="line">  ExecutorService worker = Executors.newCachedThreadPool();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//设置niosocket工厂</span></span><br><span class="line">  bootstrap.setFactory(<span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//设置管道的工厂，管道是服务，相当于装了一大堆的过滤器</span></span><br><span class="line">  bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public ChannelPipeline getPipeline() throws Exception &#123;</span><br><span class="line">  </span><br><span class="line">  ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">  pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">  pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">  <span class="comment">//接收消息</span></span><br><span class="line">  pipeline.addLast(<span class="string">"helloHandler"</span>, <span class="keyword">new</span> HelloHandler());</span><br><span class="line">  <span class="keyword">return</span> pipeline;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//绑定端口</span></span><br><span class="line">  bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">10101</span>));</span><br><span class="line">  </span><br><span class="line">  System.out.println(<span class="string">"start!!!"</span>);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>HelloHandler.java<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package com.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ChannelStateEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.ExceptionEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.MessageEvent;</span><br><span class="line"><span class="keyword">import</span> org.jboss.netty.channel.SimpleChannelHandler;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 消息接受处理类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">HelloHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 接收消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> s = (<span class="built_in">String</span>) e.getMessage();</span><br><span class="line">    System.out.println(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回写数据</span></span><br><span class="line">    ctx.getChannel().write(<span class="string">"hi"</span>);</span><br><span class="line">    <span class="keyword">super</span>.messageReceived(ctx, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 捕获异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">"exceptionCaught"</span>);</span><br><span class="line">    <span class="keyword">super</span>.exceptionCaught(ctx, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 新连接</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">"channelConnected"</span>);</span><br><span class="line">    <span class="keyword">super</span>.channelConnected(ctx, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - 必须是链接已经建立，关闭通道的时候才会触发</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">"channelDisconnected"</span>);</span><br><span class="line">    <span class="keyword">super</span>.channelDisconnected(ctx, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - channel关闭的时候触发</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">"channelClosed"</span>);</span><br><span class="line">    <span class="keyword">super</span>.channelClosed(ctx, e);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>启动Server.java<br>输出<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start!!!</span><br></pre></td></tr></table></figure><p></p><p>telnet<br>输入<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">10101</span></span><br></pre></td></tr></table></figure><p></p><p>回车<br>输出<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channelConnected</span><br></pre></td></tr></table></figure><p></p><p>telnet<br>输入<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send hello</span><br></pre></td></tr></table></figure><p></p><p>回车<br>输出<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">messageReceived</span><br></pre></td></tr></table></figure><p></p><p>在messageReceived方法处加int i = i/10<br>输出<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">messageReceived</span><br><span class="line">exception</span><br></pre></td></tr></table></figure><p></p><p>关闭telnet<br>输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channelDisconnected</span><br><span class="line">channelClosed</span><br></pre></td></tr></table></figure><p>channelDisconnected和channelClosed的区别<br>channelDisconnected：必须是链接已经建立，关闭通道的时候才会触发<br>channelClosed：channel关闭的时候触发<br>客户端连接不成功的话不会触发channelDisconnected，只会触发channelClosed方法</p><h2 id="小改进"><a href="#小改进" class="headerlink" title="小改进"></a>小改进</h2><ul><li>接收数据改进<br>注意messageReceived方法中本应该是</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelBuffer message = (ChannelBuffer)e.getMessage();</span><br><span class="line"><span class="built_in">String</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(message.array());</span><br></pre></td></tr></table></figure><p>实际上应该是Netty进行了封装<br>Server.java中加入<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br></pre></td></tr></table></figure><p></p><p>messageReceived中就可以改成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> s = e.getMessage();</span><br></pre></td></tr></table></figure><p>这样和上面是一样的效果</p><ul><li>回写数据<br>messageReceived方法中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.getChannel().write(<span class="string">"hi"</span>);</span><br></pre></td></tr></table></figure></li></ul><p>这样是会报错的，应该传一个ChannelBuffer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelBuffer copoedBuffer = ChannelBuffers.copiedBuffer(<span class="string">"hi"</span>.getBytes());</span><br><span class="line">ctx.getChannel.write(copoedBuffer);</span><br></pre></td></tr></table></figure><p>可是这样还是挺麻烦的Netty还是帮我们封装好了<br>在Server.java中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br></pre></td></tr></table></figure><p>会写数据就可知直接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.getChannel().write(<span class="string">"hi"</span>);</span><br></pre></td></tr></table></figure><h2 id="重点讲解"><a href="#重点讲解" class="headerlink" title="重点讲解"></a>重点讲解</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelPipeline getPipeline() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"><span class="comment">//接收消息</span></span><br><span class="line">pipeline.addLast(<span class="string">"helloHandler"</span>, <span class="keyword">new</span> HelloHandler());</span><br><span class="line"><span class="keyword">return</span> pipeline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管道分为消息分为了上行和下行<br>StringDecoder继承ChannelIpstreamHandler<br>StringEncoder继承了ChannelDownStreamHandler<br>HelloHandler继承了SimpleChannelHandler<br>上行会经过HelloHandler，然后下行回写数据就会经过StringEncoder，然后再回写数据给客户端</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="netty服务端hello-world案例"><a href="#netty服务端hello-world案例" class="headerlink" title="netty服务端hello world案例"></a>netty服务端hello world案例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SimpleChannelHandler 处理消息接收和写</span><br><span class="line">&#123;</span><br><span class="line">messageReceived接收消息</span><br><span class="line"></span><br><span class="line">channelConnected新连接，通常用来检测IP是否是黑名单，每次做一个统计，</span><br><span class="line">当程序员恶意通过客户端不断地发送请求，</span><br><span class="line">经过识别，就会channel.close关闭掉，通过处理加入黑名单。</span><br><span class="line"></span><br><span class="line">channelDisconnected链接关闭，可以再用户断线的时候清楚用户的缓存数据等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>boss和worker线程池里面其实是一个线程，里面是selector，boss selector是用来监听端口的，worker selector是负责channel的读写任务的</p><h2 id="channelDisconnected与channelClosed的区别？"><a href="#channelDisconnected与channelClosed的区别？" class="headerlink" title="channelDisconnected与channelClosed的区别？"></a>channelDisconnected与channelClosed的区别？</h2><p>channelDisconnected只有在连接建立后断开才会调用<br>channelClosed无论连接是否成功都会调用关闭资源</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基于Netty的RPC架构学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84RPC%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Netty" scheme="http://mmmmmm.me/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>基于Netty的RPC架构学习笔记（一）：NIO</title>
    <link href="http://mmmmmm.me/2019-03-10-1.html"/>
    <id>http://mmmmmm.me/2019-03-10-1.html</id>
    <published>2019-03-10T02:21:01.000Z</published>
    <updated>2019-03-12T11:43:19.815Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="传统的socket分析"><a href="#传统的socket分析" class="headerlink" title="传统的socket分析"></a>传统的socket分析</h1><h2 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package OIO;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传统socket服务端</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(<span class="string">"resource"</span>)</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//创建socket服务,监听10101端口</span></span><br><span class="line">ServerSocket server=<span class="keyword">new</span> ServerSocket(<span class="number">10101</span>);</span><br><span class="line">System.out.println(<span class="string">"服务器启动！"</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//获取一个套接字（阻塞）</span></span><br><span class="line">final Socket socket = server.accept();</span><br><span class="line">System.out.println(<span class="string">"来个一个新客户端！"</span>);</span><br><span class="line">newCachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="comment">//业务处理</span></span><br><span class="line">handler(socket);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取数据</span></span><br><span class="line"><span class="comment"> * @param socket</span></span><br><span class="line"><span class="comment"> * @throws Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> handler(Socket socket)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">byte[] bytes = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">InputStream inputStream = socket.getInputStream();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//读取数据（阻塞）</span></span><br><span class="line">int read = inputStream.read(bytes);</span><br><span class="line"><span class="keyword">if</span>(read != <span class="number">-1</span>)&#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="built_in">String</span>(bytes, <span class="number">0</span>, read));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"socket关闭"</span>);</span><br><span class="line">socket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面为修改后的代码。如果不将handler(socket);放在线程池中</p><p>打开第一个telnet<br>cmd<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">10101</span></span><br></pre></td></tr></table></figure><p></p><p>eclisep终端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务器启动！</span><br><span class="line">来了一个新客户端</span><br></pre></td></tr></table></figure><p>通过断点执行，断点执行到read形成了阻塞<br>再打开第二个telnet<br>cmd<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">10101</span></span><br></pre></td></tr></table></figure><p></p><p>eclipse终端没有任何反应，说明没有连上客户端，因为已经阻塞在第一个客户端的read函数中，所以不能返回到accept（）<br>这个时候在第一个telnet中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send hello</span><br></pre></td></tr></table></figure><p>eclipse终端<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">服务器启动！</span><br><span class="line">来了一个新客户端</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p></p><p>但是第二个还是进不来？</p><p>那是不是可以吧handler修改成一个线程任务呢？来一个socket就为这个socke服务<br>通过线程池，将任务添加进入线程池再看结果<br>重复上面的操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">10101</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务器启动！</span><br><span class="line">来了一个新客户端</span><br></pre></td></tr></table></figure><p>send hello<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">服务器启动！</span><br><span class="line">来了一个新客户端</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p></p><p>再开启一个telnet</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">10101</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">服务器启动！</span><br><span class="line">来了一个新客户端</span><br><span class="line">hello</span><br><span class="line">来了一个新客户端</span><br></pre></td></tr></table></figure><p>send abc<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务器启动！</span><br><span class="line">来了一个新客户端</span><br><span class="line">hello</span><br><span class="line">来了一个新客户端</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p></p><h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><p>上面虽然把handler(socket);放到了线程池中，使得多个socket能够进行连接，可是每个socket需要一个线程，假如把系统比作是一个餐厅的话，来一客人就安排一个服务生专门接待这个客人，又来一个新的客人又安排一个新的服务生，这样的消耗很大，客人越来越多，饭店迟早一天会黄了的<br>所以传统的socket不能做长连接的服务器，但是可以做短连接的服务器。<br>例如老的tomcat，底层是用socket，因为是一问一答机制，客户端发一个消息，服务端回了以后就可以关掉，所以不会出现线程一直被一个客户端占用的情况，一个线程是可以为多个客户端处理任务的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>阻塞点</p><ul><li>server.accept();</li><li>inputStream.read(bytes);</li></ul><p>单线程情况下只能有一个客户端<br>用线程池可以有多个客户端连接，但是非常消耗性能</p><h1 id="NIO代码分析"><a href="#NIO代码分析" class="headerlink" title="NIO代码分析"></a>NIO代码分析</h1><h2 id="举个🌰-1"><a href="#举个🌰-1" class="headerlink" title="举个🌰"></a>举个🌰</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">package NIO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NIO服务端</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"><span class="comment">// 通道管理器</span></span><br><span class="line">private Selector selector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得一个ServerSocket通道，并对该通道做一些初始化的工作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param port</span></span><br><span class="line"><span class="comment"> *            绑定的端口号</span></span><br><span class="line"><span class="comment"> * @throws IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">void</span> initServer(int port) throws IOException &#123;</span><br><span class="line"><span class="comment">// 获得一个ServerSocket通道，ServerSocketChannel想到与普通io的ServerSocket</span></span><br><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 设置通道为非阻塞</span></span><br><span class="line">serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 将该通道对应的ServerSocket绑定到port端口</span></span><br><span class="line">serverChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"><span class="comment">// 获得一个通道管理器</span></span><br><span class="line"><span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line"><span class="comment">// 将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_ACCEPT事件,注册该事件后，</span></span><br><span class="line"><span class="comment">// 当该事件到达时，selector.select()会返回，如果该事件没到达selector.select()会一直阻塞。</span></span><br><span class="line">serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @throws IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">void</span> listen() throws IOException &#123;</span><br><span class="line">System.out.println(<span class="string">"服务端启动成功！"</span>);</span><br><span class="line"><span class="comment">// 轮询访问selector</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 当注册的事件到达时，方法返回；否则,该方法会一直阻塞</span></span><br><span class="line"><span class="comment">//点不进去select方法，因为底层是c写的</span></span><br><span class="line">selector.select();</span><br><span class="line"><span class="comment">// 获得selector中选中的项的迭代器，选中的项为注册的事件</span></span><br><span class="line">Iterator&lt;?&gt; ite = <span class="keyword">this</span>.selector.selectedKeys().iterator();</span><br><span class="line"><span class="keyword">while</span> (ite.hasNext()) &#123;</span><br><span class="line">SelectionKey key = (SelectionKey) ite.next();</span><br><span class="line"><span class="comment">// 删除已选的key,以防重复处理</span></span><br><span class="line">ite.remove();</span><br><span class="line"></span><br><span class="line">handler(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理请求</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @throws IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">void</span> handler(SelectionKey key) throws IOException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端请求连接事件</span></span><br><span class="line"><span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">handlerAccept(key);</span><br><span class="line"><span class="comment">// 获得了可读的事件</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">handelerRead(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理连接请求</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @throws IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">void</span> handlerAccept(SelectionKey key) throws IOException &#123;</span><br><span class="line">ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line"><span class="comment">// 获得和客户端连接的通道，SocketChannel相当于传统io里面的Channel</span></span><br><span class="line">SocketChannel channel = server.accept();</span><br><span class="line"><span class="comment">// 设置成非阻塞</span></span><br><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里可以给客户端发送信息哦</span></span><br><span class="line">System.out.println(<span class="string">"新的客户端连接"</span>);</span><br><span class="line"><span class="comment">// 在和客户端连接成功之后，为了可以接收到客户端的信息，需要给通道设置读的权限。</span></span><br><span class="line">channel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理读的事件</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @throws IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">void</span> handelerRead(SelectionKey key) throws IOException &#123;</span><br><span class="line"><span class="comment">// 服务器可读取消息:得到事件发生的Socket通道</span></span><br><span class="line">SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line"><span class="comment">// 创建读取的缓冲区</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">int read = channel.read(buffer);</span><br><span class="line"><span class="keyword">if</span>(read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">byte[] data = buffer.array();</span><br><span class="line"><span class="built_in">String</span> msg = <span class="keyword">new</span> <span class="built_in">String</span>(data).trim();</span><br><span class="line">System.out.println(<span class="string">"服务端收到信息："</span> + msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//回写数据</span></span><br><span class="line">ByteBuffer outBuffer = ByteBuffer.wrap(<span class="string">"好的"</span>.getBytes());</span><br><span class="line">channel.write(outBuffer);<span class="comment">// 将消息回送给客户端</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"客户端关闭"</span>);</span><br><span class="line">key.cancel();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动服务端测试</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @throws IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">NIOServer server = <span class="keyword">new</span> NIOServer();</span><br><span class="line">server.initServer(<span class="number">8000</span>);</span><br><span class="line">server.listen();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：<br>通过telnet 多次连接，都可以成功</p><h2 id="举个🌰-2"><a href="#举个🌰-2" class="headerlink" title="举个🌰"></a>举个🌰</h2><p>NIO的特点</p><p>ServerSocketChannel 相当于ServerSocket</p><p>SocketChannel相当于Socket</p><p>Selector 使得NIO能够通过单线程为多个客户端服务</p><p>SelectionKey</p><h1 id="图解IO-NIO"><a href="#图解IO-NIO" class="headerlink" title="图解IO/NIO"></a>图解IO/NIO</h1><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p><img alt="在这里插入图片描述" data-original="/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312194241409.png"></p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312194241407.png"><br>selector监控着大门（accept）和客人，待在岗位上等待客人<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector.select();</span><br></pre></td></tr></table></figure><p></p><p>客人进店之后先在大门这里注册一个read事件，相当于说了一声”欢迎光临“，帮助客人走到座位上，然后客人有需求的话随时待命</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><p>然后就接着回到原来的岗位上待命</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector.select();</span><br></pre></td></tr></table></figure><p>然后服务员就可以走了，我点菜（read的时候）了再叫你<br>客人点菜–》tlnet</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//想要连续发送，第一次回撤之后，需要先退出当前页面一次，然后通过终端再次send （win7）</span></span><br><span class="line">send wo yao chi fan</span><br></pre></td></tr></table></figure><p>然后客户端进行读菜单（read操作）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sout（“xxxxxx”）</span><br></pre></td></tr></table></figure><h1 id="关于NIO的一些疑惑"><a href="#关于NIO的一些疑惑" class="headerlink" title="关于NIO的一些疑惑"></a>关于NIO的一些疑惑</h1><h2 id="客户端关闭的时候会抛出异常，死循环"><a href="#客户端关闭的时候会抛出异常，死循环" class="headerlink" title="客户端关闭的时候会抛出异常，死循环"></a>客户端关闭的时候会抛出异常，死循环</h2><p>运行上面的程序，打开tlnet</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send hello</span><br></pre></td></tr></table></figure><p>然后关闭掉当前tlnet窗口<br>报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.IOException:您的主机中的软件终止了一个已建立的连接</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> handelerRead(SelectionKey key) throws IOException &#123;</span><br><span class="line"><span class="comment">// 服务器可读取消息:得到事件发生的Socket通道</span></span><br><span class="line">SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line"><span class="comment">// 创建读取的缓冲区</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">int read = channel.read(buffer);</span><br><span class="line"><span class="keyword">if</span>(read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">byte[] data = buffer.array();</span><br><span class="line"><span class="built_in">String</span> msg = <span class="keyword">new</span> <span class="built_in">String</span>(data).trim();</span><br><span class="line">System.out.println(<span class="string">"服务端收到信息："</span> + msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//回写数据</span></span><br><span class="line">ByteBuffer outBuffer = ByteBuffer.wrap(<span class="string">"好的"</span>.getBytes());</span><br><span class="line">channel.write(outBuffer);<span class="comment">// 将消息回送给客户端</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"客户端关闭"</span>);</span><br><span class="line">key.cancel();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为会写数据这里出错，可以将其注释掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回写数据</span></span><br><span class="line">ByteBuffer outBuffer = ByteBuffer.wrap(<span class="string">"好的"</span>.getBytes());</span><br><span class="line">channel.write(outBuffer);<span class="comment">// 将消息回送给客户端</span></span><br></pre></td></tr></table></figure><p>紧接着原来的错误没有了可是会出现不停的死循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">服务端收到信息：</span><br><span class="line">服务端收到信息：</span><br><span class="line">服务端收到信息：</span><br><span class="line">服务端收到信息：</span><br><span class="line">服务端收到信息：</span><br><span class="line">服务端收到信息：</span><br><span class="line">服务端收到信息：</span><br><span class="line">服务端收到信息：</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int read = channel.read(buffer);</span><br><span class="line"><span class="keyword">if</span>(read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">byte[] data = buffer.array();</span><br><span class="line"><span class="built_in">String</span> msg = <span class="keyword">new</span> <span class="built_in">String</span>(data).trim();</span><br><span class="line">System.out.println(<span class="string">"服务端收到信息："</span> + msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//回写数据</span></span><br><span class="line">ByteBuffer outBuffer = ByteBuffer.wrap(<span class="string">"好的"</span>.getBytes());</span><br><span class="line">channel.write(outBuffer);<span class="comment">// 将消息回送给客户端</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"客户端关闭"</span>);</span><br><span class="line">key.cancel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该对收到的数据做一次判断，如果没有数据，就将key取消。</p><h2 id="selector-select-阻塞，那为什么说nio是非阻塞的IO？"><a href="#selector-select-阻塞，那为什么说nio是非阻塞的IO？" class="headerlink" title="selector.select();阻塞，那为什么说nio是非阻塞的IO？"></a>selector.select();阻塞，那为什么说nio是非阻塞的IO？</h2><p>判断io是不是阻塞的点，不是accept或者selector，而是读取数据的时候是否能够立马返回，从上面的问题知道，即使没有数据输入也是会立即返回的，但是传统的io是会阻塞在哪里的<br>selector.select()<br>select（）可以非阻塞，带有参数即可变成非阻塞<br>selector.select(1000);不阻塞，在一秒内内有发送请求，这个方法也会返回，只不过返回的是零。<br>selector.wakeup();也可以唤醒selector，如果当前的selector是阻塞状态的，用这个方法调用后会立即返回。<br>selector.selectNow();也可以立马返还，视频里忘了讲了，哈，这里补上</p><h2 id="SelectionKey-OP-WRITE是代表什么意思"><a href="#SelectionKey-OP-WRITE是代表什么意思" class="headerlink" title="SelectionKey.OP_WRITE是代表什么意思"></a>SelectionKey.OP_WRITE是代表什么意思</h2><p><strong><font color="red">一般write方法用的很少，写数据的时候也不需要注册write事件。</font></strong></p><p>OP_WRITE表示底层缓冲区是否有空间，是则响应返还true（一般都是有空间的，即一般是true）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"isWriteabl"</span>+key.isWritable)</span><br></pre></td></tr></table></figure><p>输出<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p></p><p>因为没有给selector注册这个事件，所以默认是false<br>比如餐厅里面的筷子掉了，经理没让你管，你就假装不知道，但是经理告诉你筷子掉了（注册），你就需要捡起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.register(<span class="keyword">this</span>.selector,SelectionKey.OP_WRITE)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isWriteabl <span class="literal">true</span></span><br><span class="line">isWriteabl <span class="literal">true</span></span><br><span class="line">isWriteabl <span class="literal">true</span></span><br><span class="line">isWriteabl <span class="literal">true</span></span><br><span class="line">isWriteabl <span class="literal">true</span></span><br><span class="line">isWriteabl <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>就是判断缓冲区有没有空间，所以一般情况下不会注册write事件</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;传统的socket分析&quot;&gt;&lt;a href=&quot;#传统的socket分析&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基于Netty的RPC架构学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84RPC%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Netty" scheme="http://mmmmmm.me/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>JVM内核-原理、诊断与优化学习笔记（十一）：JVM字节码执行</title>
    <link href="http://mmmmmm.me/2019-03-05-1.html"/>
    <id>http://mmmmmm.me/2019-03-05-1.html</id>
    <published>2019-03-05T01:21:02.000Z</published>
    <updated>2019-03-12T12:58:17.913Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h1><h2 id="javap-1"><a href="#javap-1" class="headerlink" title="javap"></a>javap</h2><p>class文件反汇编工具<br><strong><font color="red">生成code区（汇编指令） ，这和class文件中的字节码是不一样的，上一篇文章中的”2A 1B B5 00 20 B1“ 是在字节码文件中映射这具体的汇编指令，可是在字节码文件中仅仅存在的都是十六进制的有映射能力的字节码而非汇编指令。</font></strong></p><p>javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。<br>当然这些信息中，有些信息（如本地变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等等）需要在使用javac编译成class文件时，指定参数才能输出，比如，你直接javac xx.java，就不会在生成对应的局部变量表等信息，如果你使用javac -g xx.java就可以生成所有相关信息了。如果你使用的eclipse，则默认情况下，eclipse在编译时会帮你生成局部变量表、指令和代码行偏移量映射表等信息的。<br>通过反编译生成的汇编代码，我们可以深入的了解java代码的工作机制。比如我们可以查看i++；这行代码实际运行时是先获取变量i的值，然后将这个值加1，最后再将加1后的值赋值给变量i。<br>通过局部变量表，我们可以查看局部变量的作用域范围、所在槽位等信息，甚至可以看到槽位复用等信息。<br>javap的用法格式：<br>javap<options><classes><br>其中classes就是你要反编译的class文件。<br>在命令行中直接输入javap或javap -help可以看到javap的options有如下选项：</classes></options></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-help  --help  -?        输出此用法消息</span><br><span class="line">-version                 版本信息，其实是当前javap所在jdk的版本信息，不是<span class="class"><span class="keyword">class</span>在哪个<span class="title">jdk</span>下生成的。</span></span><br><span class="line"><span class="class">-<span class="title">v</span>  -<span class="title">verbose</span>             输出附加信息（包括行号、本地变量表，反汇编等详细信息）</span></span><br><span class="line"><span class="class">-<span class="title">l</span>                         输出行号和本地变量表</span></span><br><span class="line"><span class="class">-<span class="title">public</span>                    仅显示公共类和成员</span></span><br><span class="line"><span class="class">-<span class="title">protected</span>               显示受保护的/公共类和成员</span></span><br><span class="line"><span class="class">-<span class="title">package</span>                 显示程序包/受保护的/公共类 和成员 (默认)</span></span><br><span class="line"><span class="class">-<span class="title">p</span>  -<span class="title">private</span>             显示所有类和成员</span></span><br><span class="line"><span class="class">-<span class="title">c</span>                       对代码进行反汇编</span></span><br><span class="line"><span class="class">-<span class="title">s</span>                       输出内部类型签名</span></span><br><span class="line"><span class="class">-<span class="title">sysinfo</span>                 显示正在处理的类的系统信息 (路径, 大小, 日期, <span class="title">MD5</span> 散列)</span></span><br><span class="line"><span class="class">-<span class="title">constants</span>               显示静态最终常量</span></span><br><span class="line"><span class="class">-<span class="title">classpath</span> &lt;<span class="title">path</span>&gt;        指定查找用户类文件的位置</span></span><br><span class="line"><span class="class">-<span class="title">bootclasspath</span> &lt;<span class="title">path</span>&gt;    覆盖引导类文件的位置</span></span><br></pre></td></tr></table></figure><p>一般常用的是-v -l -c三个选项。<br>javap -v classxx，不仅会输出行号、本地变量表信息、反编译汇编代码，还会输出当前类用到的常量池等信息。<br>javap -l 会输出行号和本地变量表信息。<br>javap -c 会对当前class字节码进行反编译生成汇编代码。<br>查看汇编代码时，需要知道里面的jvm指令，可以参考官方文档：<br><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html</a><br>另外通过jclasslib工具也可以看到上面这些信息，而且是可视化的，效果更好一些。</p><h2 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Calc</span> </span>&#123;</span><br><span class="line">public int calc() &#123;</span><br><span class="line">int a = <span class="number">500</span>;</span><br><span class="line">int b = <span class="number">200</span>;</span><br><span class="line">int c = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">return</span> (a + b) / c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行命令<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap –verbose Calc</span><br></pre></td></tr></table></figure><p></p><p>得到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int calc();</span><br><span class="line">  Code:</span><br><span class="line">  <span class="comment">//栈大小   局部变量大小 </span></span><br><span class="line">   Stack=<span class="number">2</span>, Locals=<span class="number">4</span>, Args_size=<span class="number">1</span></span><br><span class="line">   <span class="comment">//前面的数字可以理解为广义上的行号，但不是真正的行号，</span></span><br><span class="line">   <span class="comment">//因为这是反编译过来的，这是偏移量的意思。</span></span><br><span class="line">   <span class="comment">//sipush、istore_1等就是字节码本身，就是方法体在运行的时候</span></span><br><span class="line">   <span class="comment">//会执行的指令</span></span><br><span class="line">   <span class="number">0</span>:   sipush  <span class="number">500</span></span><br><span class="line">   <span class="number">3</span>:   istore_1</span><br><span class="line">   <span class="number">4</span>:   sipush  <span class="number">200</span></span><br><span class="line">   <span class="number">7</span>:   istore_2</span><br><span class="line">   <span class="number">8</span>:   bipush  <span class="number">50</span></span><br><span class="line">   <span class="number">10</span>:  istore_3</span><br><span class="line">   <span class="number">11</span>:  iload_1</span><br><span class="line">   <span class="number">12</span>:  iload_2</span><br><span class="line">   <span class="number">13</span>:  iadd</span><br><span class="line">   <span class="number">14</span>:  iload_3</span><br><span class="line">   <span class="number">15</span>:  idiv</span><br><span class="line">   <span class="number">16</span>:  ireturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简单的字节码执行过程"><a href="#简单的字节码执行过程" class="headerlink" title="简单的字节码执行过程"></a>简单的字节码执行过程</h1><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312204327835.png"><br>每个线程都有一个程序计数器，指向当前运行的这条指令的位置<br>局部变量表和操作数栈都是在帧栈中产生的数据</p><p>sipush 500因为当前是一个实例方法，所以this作为参数放在局部变量表的第0个位置，同时将500操作数压入到操作数栈中<br>istore 1 从操作数栈中取出一个数弹出到局部变量表中 1的位置<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312204327763.png"><br>同上<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312204424511.png"><br>bipush 50 将50压入到操作数栈当中<br>istore 3 将操作数栈顶端的数压入到局部变量表的第3个位置<br>执行完以上指令局部变量表中欧冠0123都有了数字，同时操作数栈是空的<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312204415025.png"><br>iload 1 将局部变量表的数据压入到操作数栈中，将局部变量表的第1个位置的整数，压入到操作数栈中<br>iload 2 同上<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312204438689.png"><br>iadd 相加操作，从操作数栈中。弹出两个操作数，做累加，将数据之和再压入操作数栈，所以在iadd执行完之后，200+500=700<br>iload 3 将局部变量表的第3个位置的整数50压入操作数栈的顶端<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312204448364.png"><br>idiv 表示整数的除法，从操作数栈中弹出两个数，做除法，700/50=14<br>ireturn 返回操作数栈的栈顶的元素即14<br>至此函数运行完毕。<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312204501689.png"><br>之前这个图中黑色框中的内容没有详细的介绍。<br>即</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>A1B B5 <span class="number">00</span> <span class="number">20</span> B1</span><br></pre></td></tr></table></figure><p>其实就是函数真正的字节码</p><p><strong><font color="red">字节码指令为一个byte整数</font></strong></p><table><thead><tr><th>指令</th><th>整数</th><th>解释</th></tr></thead><tbody><tr><td>_nop</td><td>= 0, // 0x00</td><td>空指令</td></tr><tr><td>_aconst_null</td><td>= 1, // 0x01</td><td></td></tr><tr><td>_iconst_0</td><td>= 3, // 0x03</td><td></td></tr><tr><td>_iconst_1</td><td>= 4, // 0x04</td><td></td></tr><tr><td>_dconst_1</td><td>= 15, // 0x0f</td><td></td></tr><tr><td>_bipush</td><td>= 16, // 0x10</td><td></td></tr><tr><td>_iload_0</td><td>= 26, // 0x1a</td><td></td></tr><tr><td>_iload_1</td><td>= 27, // 0x1b</td><td></td></tr><tr><td>_aload_0</td><td>= 42, // 0x2a</td><td></td></tr><tr><td>_istore</td><td>= 54, // 0x36</td><td></td></tr><tr><td>_pop</td><td>= 87, // 0x57</td><td></td></tr><tr><td>_imul</td><td>= 104, // 0x68</td><td></td></tr><tr><td>_idiv</td><td>= 108, // 0x6c</td></tr></tbody></table><p>指令是方便阅读和理解的，右半部分是文件中、计算机内真正的表示方式</p><p>上面的字节码解析<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>A1B B5 <span class="number">00</span> <span class="number">20</span> B1</span><br></pre></td></tr></table></figure><p></p><ul><li>void setAge(int) 方法的字节码<br>2A 1B B5 00 20 B1</li><li>2A _aload_0<br>无参<br>将局部变量slot0 （this）作为引用 压入操作数栈</li><li>1B _iload_1<br>无参<br>将局部变量slot1 作为整数 压入操作数栈</li><li>B5 _putfield<br>设置对象中字段的值<br>参数为2bytes (00 20) (指明了字段名称)</li></ul><ol><li>指向常量池的引用</li><li>Constant_Fieldref</li><li>此处为User.age<br>弹出栈中2个对象:objectref（iload_0中的值，即this对象）, value（load_1中的值）<br>将栈中的value赋给objectref的给定字段</li></ol><ul><li>简而言之：就是讲load_1压入的值赋值给this对象中的age字段</li><li>B1 _return 没有返回值，返回void</li></ul><h1 id="常用的字节码"><a href="#常用的字节码" class="headerlink" title="常用的字节码"></a>常用的字节码</h1><h2 id="常量入栈"><a href="#常量入栈" class="headerlink" title="常量入栈"></a>常量入栈</h2><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>aconst_null</td><td>null对象入栈</td></tr><tr><td>iconst_m1</td><td>int常量-1入栈</td></tr><tr><td>iconst_0</td><td>int常量0入栈</td></tr><tr><td>iconst_5</td><td></td></tr><tr><td>lconst_1</td><td>long常量1入栈</td></tr><tr><td>fconst_1</td><td>float 1.0入栈</td></tr><tr><td>dconst_1</td><td>double 1.0 入栈</td></tr><tr><td>bipush</td><td>8位带符号整数入栈</td></tr><tr><td>sipush</td><td>16位带符号整数入栈</td></tr><tr><td>ldc</td><td>常量池中的项入栈</td></tr></tbody></table><p>前面是<br>a表示对象的引用，<br>i表示int，<br>l表示long，<br>f表示float，<br>d表示double，<br>bi表示8位带符号整数（128以下），<br>si表示16位带符号整数，<br>ldc表示常量池中的对象某一项入栈</p><h2 id="局部变量压栈"><a href="#局部变量压栈" class="headerlink" title="局部变量压栈"></a>局部变量压栈</h2><p>局部变量包括方法中的局部变量和方法的参数</p><ul><li>xload(x为i l f d a)<br>分别表示int，long，float，double，object ref</li><li>xload_n(n为0 1 2 3)</li><li>xaload(x为i l f d a b c s) x后面的a表示数组<br>分别表示int, long, float, double, obj ref ,byte,char,short<br>从数组中取得给定索引的值，将该值压栈<br>iaload</li></ul><ol><li>执行前，栈：…, arrayref, index，栈顶元素是数组下表，第二个元素是整数数组的索引</li><li>它取得arrayref所在数组的index的值，并将值压栈，并将arrayref和index从栈顶弹出来</li><li>执行后，栈：…, valu，最后只剩下给定数组的index索引的数值<h2 id="出栈装载入局部变量"><a href="#出栈装载入局部变量" class="headerlink" title="出栈装载入局部变量"></a>出栈装载入局部变量</h2></li></ol><ul><li>xstore(x为i l f d a)<br>出栈，存入局部变量</li><li>xstore_n(n 0 1 2 3)<br>出栈，将值存入第n个局部变量</li><li>xastore(x为i l f d a b c s)<br>将值存入数组中<br>iastore</li></ul><ol><li>执行前，栈：…,arrayref, index, value</li><li>执行后，栈：…</li><li>将value值存入arrayref[index]<h2 id="通用栈操作（无类型，不指定数据类型）"><a href="#通用栈操作（无类型，不指定数据类型）" class="headerlink" title="通用栈操作（无类型，不指定数据类型）"></a>通用栈操作（无类型，不指定数据类型）</h2></li></ol><ul><li>nop 空指令，什么都不做</li><li>pop<br>弹出栈顶1个字长</li><li>dup<br>复制栈顶1个字长，复制内容压入栈<h2 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h2></li></ul><table><thead><tr><th>-</th></tr></thead><tbody><tr><td>i2l</td></tr><tr><td>i2f</td></tr><tr><td>l2i</td></tr><tr><td>l2f</td></tr><tr><td>l2d</td></tr><tr><td>f2i</td></tr><tr><td>f2d</td></tr><tr><td>d2i</td></tr><tr><td>d2l</td></tr><tr><td>d2f</td></tr><tr><td>i2b</td></tr><tr><td>i2c</td></tr></tbody></table><h3 id="i2l"><a href="#i2l" class="headerlink" title="i2l"></a>i2l</h3><p>将int转为long<br>执行前，栈：…, value value是int<br>执行后，栈：…,result.word1,result.word2 将原来的int变成了long的前半部分和后半部分<br>弹出int，扩展为long，并入栈</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>iadd</td><td>加</td></tr><tr><td>ladd</td></tr><tr><td>isub</td><td>减</td></tr><tr><td>lsub</td></tr><tr><td>idiv</td><td>除</td></tr><tr><td>ldiv</td></tr><tr><td>imul</td><td>乘</td></tr><tr><td>lmul</td></tr><tr><td>iinc</td><td>整数加加</td></tr><tr><td>i–》int l–》long</td></tr></tbody></table><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><table><thead><tr><th>-</th></tr></thead><tbody><tr><td>fadd</td></tr><tr><td>dadd</td></tr><tr><td>fsub</td></tr><tr><td>dsub</td></tr><tr><td>fdiv</td></tr><tr><td>ddiv</td></tr><tr><td>fmul</td></tr><tr><td>dmul</td></tr><tr><td>f–》float d–》double</td></tr></tbody></table><h2 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h2><table><thead><tr><th>-</th></tr></thead><tbody><tr><td>new</td><td>生成对象</td></tr><tr><td>getfield</td><td>拿到实例对象给定字段的值</td></tr><tr><td>putfield</td><td>设置实例对象给定字段的值</td></tr><tr><td>getstatic</td><td>拿到静态字段的值</td></tr><tr><td>putstatic</td><td>设置静态字段的值</td></tr></tbody></table><h2 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h2><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>feq</td><td>如果为0，则跳转</td></tr><tr><td>fne</td><td>如果不为0，则跳转</td></tr><tr><td>flt</td><td>如果小于0 ，则跳转</td></tr><tr><td>fge</td><td>如果大于0，则跳转</td></tr><tr><td>f_icmpeq</td><td>如果两个int相同，则跳转</td></tr></tbody></table><h3 id="举个🌰-1"><a href="#举个🌰-1" class="headerlink" title="举个🌰"></a>举个🌰</h3><ul><li>ifeq<br>参数 byte1,byte2<br>value出栈 ，如果栈顶value为0则跳转到(byte1&lt;&lt;8)|byte2 byte1左移8位，再和byte2取或<br>执行前，栈：…,value<br>执行后，栈：…<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2></li></ul><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>invokevirtual</td><td>普通的实例的类方法调用（动态调用，运行的时候根据目前的实际类型，获取调用的方法）</td></tr><tr><td>invokespecial</td><td>父类方法调用，编译的时候表名的类型的方法，所以不会有多态的作用</td></tr><tr><td>invokestatic</td><td>静态方法的调用</td></tr><tr><td>invokeinterface</td><td>接口方法的调用</td></tr><tr><td>xreturn(x为 i l f d a 或为空)</td><td>x为返回值类型，空位void</td></tr></tbody></table><h1 id="使用ASM生成Java字节码"><a href="#使用ASM生成Java字节码" class="headerlink" title="使用ASM生成Java字节码"></a>使用ASM生成Java字节码</h1><ul><li>Java字节码操作框架</li><li>可以用于修改现有类或者动态产生新类(从无到有)</li><li>用户（都用到了ASM技术）<br>AspectJ<br>Clojure<br>Ecplise<br>spring<br>cglib(hibernate)</li></ul><p>ASM通过访问者模式访问class文件，最终生成class文件，生产class文件的时候使用的是ClassWriter这个类，visit访问class文件</p><h2 id="举个🌰-2"><a href="#举个🌰-2" class="headerlink" title="举个🌰"></a>举个🌰</h2><p>一个class从无到有的过程<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成一个ClassWeiter，写class文件的对象</span></span><br><span class="line">ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS|ClassWriter.COMPUTE_FRAMES);  </span><br><span class="line"><span class="comment">//让ClassWriter访问一个类，生成类的名字的Example，访问权限public，父类是Object</span></span><br><span class="line">cw.visit(V1_7, ACC_PUBLIC, <span class="string">"Example"</span>, <span class="literal">null</span>, <span class="string">"java/lang/Object"</span>, <span class="literal">null</span>); </span><br><span class="line"><span class="comment">//visitMEthod动态产生一个init方法，权限public，即构造方法，参数返回值都是空的</span></span><br><span class="line">MethodVisitor mw = cw.visitMethod(ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="literal">null</span>,  <span class="literal">null</span>);  </span><br><span class="line"><span class="comment">//this 入栈</span></span><br><span class="line">mw.visitVarInsn(ALOAD, <span class="number">0</span>);  </span><br><span class="line"><span class="comment">//调用给定对象的方法，静态绑定，也就是访问了父类object的init函数</span></span><br><span class="line">mw.visitMethodInsn(INVOKESPECIAL, <span class="string">"java/lang/Object"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);  </span><br><span class="line"><span class="comment">//return 没有返回值</span></span><br><span class="line">mw.visitInsn(RETURN);  </span><br><span class="line"><span class="comment">//对访问的帧栈和局部变量表做一个自动的计算</span></span><br><span class="line">mw.visitMaxs(<span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line"><span class="comment">//访问结束</span></span><br><span class="line">mw.visitEnd();  </span><br><span class="line"><span class="comment">//访问main方法，方法参数是String数组，[表示数组L表示对象 返回值void</span></span><br><span class="line">mw = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, <span class="string">"main"</span>,  <span class="string">"([Ljava/lang/String;)V"</span>, <span class="literal">null</span>, <span class="literal">null</span>);  </span><br><span class="line"><span class="comment">//得到名为java.lang.system的static属性，这个成员是一个类型为java.io.pritStream的out</span></span><br><span class="line">mw.visitFieldInsn(GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>,  <span class="string">"Ljava/io/PrintStream;"</span>);  </span><br><span class="line"><span class="comment">//压栈Ldc将常量池中的常量压入堆栈</span></span><br><span class="line">mw.visitLdcInsn(<span class="string">"Hello world!"</span>);  </span><br><span class="line"><span class="comment">//调用实例对象的方法，将前面GWTSTATIC拿到的值压入堆栈，将helloworld压入堆栈，所以</span></span><br><span class="line"><span class="comment">//堆栈的前两位就是system.out对象的引用和println方法的参数”Hello World“，</span></span><br><span class="line"><span class="comment">//INVOKEVOTUAL就将压入堆栈的system.out 的prontln调用了一次，并传入了一个参数”Hello World“</span></span><br><span class="line"><span class="comment">//所以完成了一个system.println HelloWorld的操作</span></span><br><span class="line">mw.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>,  <span class="string">"(Ljava/lang/String;)V"</span>);  </span><br><span class="line"><span class="comment">//return  void</span></span><br><span class="line">mw.visitInsn(RETURN);  </span><br><span class="line"><span class="comment">//自动生成帧栈局部变量的大小</span></span><br><span class="line">mw.visitMaxs(<span class="number">0</span>,<span class="number">0</span>);  </span><br><span class="line"><span class="comment">//结束</span></span><br><span class="line">mw.visitEnd();  </span><br><span class="line"><span class="comment">//将整个类变成一个byte数组</span></span><br><span class="line">byte[] code = cw.toByteArray();  </span><br><span class="line"></span><br><span class="line">AsmHelloWorld loader = <span class="keyword">new</span> AsmHelloWorld();  </span><br><span class="line"><span class="comment">//通过classloader定义一个类，将刚刚的byte数组传入，通过defineClass生成类</span></span><br><span class="line">Class exampleClass = loader  </span><br><span class="line">    .defineClass(<span class="string">"Example"</span>, code, <span class="number">0</span>, code.length);  </span><br><span class="line"> <span class="comment">//通过反射执行刚刚生成的main方法</span></span><br><span class="line">exampleClass.getMethods()[<span class="number">0</span>].invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">Object</span>[] &#123; <span class="literal">null</span> &#125;);</span><br></pre></td></tr></table></figure><p></p><p>输出结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure><h2 id="模拟实现AOP字节码织入"><a href="#模拟实现AOP字节码织入" class="headerlink" title="模拟实现AOP字节码织入"></a>模拟实现AOP字节码织入</h2><p>在函数开始部分或者结束部分嵌入字节码<br>可用于进行鉴权（查看用户是否有权限调用这个方法）、日志（方法被调用的时候记录一些额外的日志）等</p><h3 id="举个🌰-3"><a href="#举个🌰-3" class="headerlink" title="举个🌰"></a>举个🌰</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123; </span><br><span class="line"> public <span class="keyword">void</span> operation() &#123; </span><br><span class="line"> System.out.println(<span class="string">"operation...."</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在操作前加上鉴权或者日志<br>我们要嵌入的内容<br>安全检查：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SecurityChecker</span> </span>&#123; </span><br><span class="line"> public <span class="keyword">static</span> boolean checkSecurity() &#123; </span><br><span class="line"> System.out.println(<span class="string">"SecurityChecker.checkSecurity ..."</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承一个ClassVisitor，表示对类进行一些访问</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddSecurityCheckClassAdapter</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line"><span class="comment">//给class加上SecurityChecker类的checkSecurity功能</span></span><br><span class="line">    public AddSecurityCheckClassAdapter( ClassVisitor cv) &#123;</span><br><span class="line"><span class="keyword">super</span>(Opcodes.ASM5, cv);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 重写 visitMethod，访问到 "operation" 方法时，</span></span><br><span class="line">    <span class="comment">// 给出自定义 MethodVisitor，实际改写方法内容</span></span><br><span class="line">    <span class="comment">//name是method的名字</span></span><br><span class="line">    public MethodVisitor visitMethod(final int access, final <span class="built_in">String</span> name, </span><br><span class="line">        final <span class="built_in">String</span> desc, final <span class="built_in">String</span> signature, final <span class="built_in">String</span>[] exceptions) &#123; </span><br><span class="line">        MethodVisitor mv = cv.visitMethod(access, name, desc, signature,exceptions);</span><br><span class="line">        MethodVisitor wrappedMv = mv; </span><br><span class="line">        <span class="keyword">if</span> (mv != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 对于 "operation" 方法，当name叫做opration的时候</span></span><br><span class="line">            <span class="keyword">if</span> (name.equals(<span class="string">"operation"</span>)) &#123; </span><br><span class="line">                <span class="comment">// 使用自定义 MethodVisitor，实际改写方法内容</span></span><br><span class="line">                wrappedMv = <span class="keyword">new</span> AddSecurityCheckMethodAdapter(mv); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> wrappedMv; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AddSecurityCheckMethodAdapter<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MethodVIsitor专门用来访问方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddSecurityCheckMethodAdapter</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> </span>&#123; </span><br><span class="line"> public AddSecurityCheckMethodAdapter(MethodVisitor mv) &#123; </span><br><span class="line"> <span class="keyword">super</span>(Opcodes.ASM5,mv); </span><br><span class="line"> &#125; </span><br><span class="line"> public <span class="keyword">void</span> visitCode() &#123; </span><br><span class="line"> <span class="comment">//先执行geym/jvm/ch10/asm/SecurityChecker空参的返回值是boolean的checkSecurity方法</span></span><br><span class="line"> visitMethodInsn(Opcodes.INVOKESTATIC, <span class="string">"geym/jvm/ch10/asm/SecurityChecker"</span>, </span><br><span class="line"><span class="string">"checkSecurity"</span>, <span class="string">"()Z"</span>); </span><br><span class="line"><span class="comment">//然后再执行真正的操作，即在class文件中有一个Attribute是code</span></span><br><span class="line"><span class="comment">//即将原原本本的其他的一些字节码再运行一遍</span></span><br><span class="line"> <span class="keyword">super</span>.visitCode();</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>将字节码织入<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Generator</span></span>&#123; </span><br><span class="line"> public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span> args[]) throws Exception &#123; </span><br><span class="line"> <span class="comment">//通过ClassReader将Account类读进来，生成一个ClassReader实例</span></span><br><span class="line"> ClassReader cr = <span class="keyword">new</span> ClassReader(<span class="string">"geym.jvm.ch10.asm.Account"</span>); </span><br><span class="line"> ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS|ClassWriter.COMPUTE_FRAMES); </span><br><span class="line"> AddSecurityCheckClassAdapter classAdapter = <span class="keyword">new</span> AddSecurityCheckClassAdapter(cw); </span><br><span class="line"> <span class="comment">//cr接受一个访问者classAdapter，即AddSecurityCheckClassAdapter</span></span><br><span class="line"> <span class="comment">//由classReader作为一个引导对这个class文件做一个访问</span></span><br><span class="line"> <span class="comment">//在访问的过程中就会做一些自己的织入</span></span><br><span class="line"> cr.accept(classAdapter, ClassReader.SKIP_DEBUG); </span><br><span class="line"> <span class="comment">//将修改过的字节码做一个输出</span></span><br><span class="line"> byte[] data = cw.toByteArray(); </span><br><span class="line"> File file = <span class="keyword">new</span> File(<span class="string">"bin/geym/jvm/ch10/asm/Account.class"</span>); </span><br><span class="line"> FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(file); </span><br><span class="line"> <span class="comment">//通过data即cw.toByteArray覆盖原来的Account文件</span></span><br><span class="line"> fout.write(data); </span><br><span class="line"> fout.close(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在operation执行之前会先执行checkSecurity</span></span><br><span class="line">SecurityChecker.checkSecurity ...</span><br><span class="line">operation....</span><br></pre></td></tr></table></figure><h1 id="JIT及其相关参数"><a href="#JIT及其相关参数" class="headerlink" title="JIT及其相关参数"></a>JIT及其相关参数</h1><ul><li>字节码执行性能较差，所以可以对于热点代码编译成机器码再执行，在运行时的编译，<br>叫做JIT Just-In-Time</li><li>JIT的基本思路是，将热点代码，就是执行比较频繁的代码，编译成机器码，当再次执行的时候就不做解释执行，而是直接执行机器码。<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312204328017.png"><br>即使是在循环体中被多次调用也会被认为热点代码，可能方法被即时调用并没有返回，这种情况下依然能够促进被编译完的代码的使用，这个过程叫做”栈上替换“，在方法的执行栈上直接替换成机器码<br>CompileThreadshld 设置阈值，方法被调用多少次之后将其设置成机器码<br>PrintCompilatoin 打出JIT的一些编译的信息，哪些方法已经完成了编译<h2 id="举个🌰-4"><a href="#举个🌰-4" class="headerlink" title="举个🌰"></a>举个🌰</h2></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JITTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> met()&#123;</span><br><span class="line">        int a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">        b=a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            met();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:CompileThreshold=<span class="number">1000</span></span><br><span class="line">-XX:+PrintCompilation</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有被编译的方法都有一个输出</span></span><br><span class="line"><span class="number">56</span>    <span class="number">1</span>             java.lang.String::hashCode (<span class="number">55</span> bytes)</span><br><span class="line"><span class="number">56</span>    <span class="number">2</span>             java.lang.String::equals (<span class="number">81</span> bytes)</span><br><span class="line"><span class="number">57</span>    <span class="number">3</span>             java.lang.String::indexOf (<span class="number">70</span> bytes)</span><br><span class="line"><span class="number">60</span>    <span class="number">4</span>             java.lang.String::charAt (<span class="number">29</span> bytes)</span><br><span class="line"><span class="number">61</span>    <span class="number">5</span>             java.lang.String::length (<span class="number">6</span> bytes)</span><br><span class="line"><span class="number">61</span>    <span class="number">6</span>             java.lang.String::lastIndexOf (<span class="number">52</span> bytes)</span><br><span class="line"><span class="number">61</span>    <span class="number">7</span>             java.lang.String::toLowerCase (<span class="number">472</span> bytes)</span><br><span class="line"><span class="number">67</span>    <span class="number">8</span>             geym.jvm.ch2.jit.JITTest::met (<span class="number">9</span> bytes)</span><br></pre></td></tr></table></figure><p></p><h2 id="JIT相关参数"><a href="#JIT相关参数" class="headerlink" title="JIT相关参数"></a>JIT相关参数</h2><p>默认是解释和编译混合的，何时解释和编译，取决于被调用的次数和热点代码的分布情况</p><p>编译器是把源程序的每一条语句都编译成机器语言,并保存成二进制文件,这样运行时计算机可以直接以机器语言来运行此程序,速度很快;</p><p>而解释器则是只在执行程序时,才一条一条的解释成机器语言给计算机来执行,所以运行速度是不如编译后的程序运行的快的.</p><p>这是因为计算机不能直接认识并执行我们写的语句,它只能认识机器语言(是二进制的形式)</p><ul><li>-Xint<br>解释执行<br>执行性能比较差</li><li>-Xcomp<br>全部编译执行<br>启动初期，所有的方法都还没有被编译完之前，这时候的编译量是非常巨大的，这个时候的性能比较差，可是全部编译完成之后，会比解释执行快很多。</li><li>-Xmixed<br>默认，混合</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;javap&quot;&gt;&lt;a href=&quot;#javap&quot; class=&quot;headerlink&quot; title=&quot;javap&quot;&gt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM内核-原理、诊断与优化学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM%E5%86%85%E6%A0%B8-%E5%8E%9F%E7%90%86%E3%80%81%E8%AF%8A%E6%96%AD%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="http://mmmmmm.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内核-原理、诊断与优化学习笔记（十）：Class文件结构</title>
    <link href="http://mmmmmm.me/2019-03-04-1.html"/>
    <id>http://mmmmmm.me/2019-03-04-1.html</id>
    <published>2019-03-04T02:21:02.000Z</published>
    <updated>2019-03-12T12:14:09.313Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="语言无关性"><a href="#语言无关性" class="headerlink" title="语言无关性"></a>语言无关性</h1><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190304160708704.png"><br>.class文件能够在JVM上运行，上图可以看出许多语言rb、groovy等都能编译成.class文件，所以java和JVM是相对独立的两部分。<br>同样能得出结论：class文件是JVM的基石</p><h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>描述</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>1</td><td>魔数，也叫magic number，数字表示是否是一个java文件</td></tr><tr><td>u2</td><td>minor_version</td><td>1</td><td>小版本</td></tr><tr><td>u2</td><td>major_version</td><td>1</td><td>大版本</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>1</td><td>常量池数量的属性</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>constant_pool_count - 1</td><td>常量池的内容，就是常量池的个数减一</td></tr><tr><td>u2</td><td>access_flags</td><td>1</td><td>访问修饰符 public private等</td></tr><tr><td>u2</td><td>this_class</td><td>1</td><td>当前类</td></tr><tr><td>u2</td><td>super_class</td><td>1</td><td>超类，单继承</td></tr><tr><td>u2</td><td>interfaces_count</td><td>1</td><td>接口数量的属性</td></tr><tr><td>u2</td><td>interfaces</td><td>interfaces_count</td><td>接口</td></tr><tr><td>u2</td><td>fields_count</td><td>1</td><td>字段数量的属性</td></tr><tr><td>field_info</td><td>fields</td><td>fields_count</td><td>字段</td></tr><tr><td>u2</td><td>methods_count</td><td>1</td><td>方法数量的属性</td></tr><tr><td>method_info</td><td>methods</td><td>methods_count</td><td>方法的信息</td></tr><tr><td>u2</td><td>attribute_count</td><td>1</td><td>属性数量的属性</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td><td>属性的信息</td></tr></tbody></table><p>u1 u2 u3 u4表示无符号的整数，u1表示1个byte的整数，u2表示2个byte的整数，数字表示整数的长度。</p><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>magic u4</p><ul><li><p>0xCAFEBABE</p><p>4个byte的一个数字，用来表示当前文件是一个class文件</p></li></ul><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>minor_version u2<br>major_version u2<br>当进行编译的时候用什么版本的javac编译出来的class文件<br>-target目标版本是多少</p><p>JDK 编译器版本| target 参数 |六进制 minor.major |十进制major.minor<br>|–|–|–|–|<br>jdk1.1.8| 不能带 target 参数 |00 03 00 2D |45.3<br>jdk1.2.2| 不带(默认为 -target 1.1) | 00 03 00 2D |45.3<br>jdk1.2.2| -target 1.2 | 00 00 00 2E | 46.0<br>jdk1.3.1_19| 不带(默认为 -target 1.1) | 00 03 00 2D | 45.3<br>jdk1.3.1_19| -target 1.3 | 00 00 00 2F | 47.0<br>j2sdk1.4.2_| 不带(默认为 -target 1.2) | 00 00 00 2E |46.0<br>j2sdk1.4.2_| -target 1.4 | 00 00 00 30 | 48.0<br>jdk1.5.0_11| 不带(默认为 -target 1.5) | 00 00 00 31 | 49.0<br>jdk1.5.0_11| -target 1.4 -source 1.4| 00 00 00 30| 48.0<br>jdk1.6.0_01| 不带(默认为 -target 1.6) | 00 00 00 32 | 50.0<br>jdk1.6.0_01| -target 1.5 | 00 00 00 31| 49.0<br>jdk1.6.0_01| -target 1.4 -source 1.4| 00 00 00 30| 48.0<br>jdk1.7.0| 不带(默认为 -target 1.6) | 00 00 00 32 |50.0<br>jdk1.7.0| -target 1.7 | 00 00 00 33 | 51.0<br>jdk1.7.0| -target 1.4 -source 1.4 | 00 00 00 30 | 48.0</p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p><strong><font color="red">基本上所有的数据都是存在这里，后面的类名方法名等都是通过索引的方式指向这里，一切数据的基石。</font></strong></p><ul><li>constant_pool_count u2</li><li><p>constant_pool cp_info</p><p>|-|-|-|<br>|–|–|–|<br>CONSTANT_Utf8 |1|UTF-8编码的Unicode字符串<br>CONSTANT_Integer |3| int类型的字面值<br>CONSTANT_Float |4|float类型的字面值<br>CONSTANT_Long |5|long类型的字面值<br>CONSTANT_Double |6|double类型的字面值<br>CONSTANT_Class |7|对一个类或接口的符号引用<br>CONSTANT_String |8|String类型字面值的引用<br>CONSTANT_Fieldref |9| 对一个字段的符号引用<br>CONSTANT_Methodref |10|对一个类中方法的符号引用<br>CONSTANT_InterfaceMethodref |11| 对一个接口中方法的符号引用<br>CONSTANT_NameAndType |12| 对一个字段或方法的部分符号引用</p><h3 id="CONSTANT-Utf8"><a href="#CONSTANT-Utf8" class="headerlink" title="CONSTANT_Utf8"></a>CONSTANT_Utf8</h3></li><li>tag 1 (常量标识符 1代表UTF-8)</li><li>length u2 （UFT-8这个字符串byte数组的长度）</li><li>bytes[length]（UTF-8的实际的内容）<br><img alt="在这里插入图片描述" data-original="../images/20190304071517995.png"><br>三个UTF-8类型的常量：先显示字符串的长度，()I 表示空参返回值是int的数，()Ljava/lang/Object表示空参返回值是Object，compareTo表示方法的名称<h3 id="CONSTANT-Integer"><a href="#CONSTANT-Integer" class="headerlink" title="CONSTANT_Integer"></a>CONSTANT_Integer</h3><ul><li>tag 3</li><li>byte u4</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> final int sid=<span class="number">99</span>;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-original="../images/20190304072028605.png"></p><h3 id="CONSTANT-String"><a href="#CONSTANT-String" class="headerlink" title="CONSTANT_String"></a>CONSTANT_String</h3><ul><li>tag 8</li><li>string_index u2 (指向utf8的索引)<br>内部不直接存储内容而是指向UFT-8，实际的内容保存在UTF-8中</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> final <span class="built_in">String</span> sname=<span class="string">"geym"</span>;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190304072138569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"></p><h3 id="CONSTANT-NameAndType"><a href="#CONSTANT-NameAndType" class="headerlink" title="CONSTANT_NameAndType"></a>CONSTANT_NameAndType</h3><ul><li>tag 12</li><li>name_index u2 (名字，指向utf8)</li><li>descriptor_index u2 (描述符类型，指向utf8)<br>名字和类型都是指向UTF-8描述的，本身是没有内容的</li></ul><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70.png"><br>上图表示了名字为init，空参，返回值为void的方法，即默认的构造函数的表示。</p><h3 id="CONSTANT-Class"><a href="#CONSTANT-Class" class="headerlink" title="CONSTANT_Class"></a>CONSTANT_Class</h3><ul><li>tag 7</li><li>name_index u2 (名字，指向utf8)</li></ul><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190304160706491.png"></p><h3 id="CONSTANT-Fieldref-CONSTANT-Methodref-CONSTANT-InterfaceMethodref"><a href="#CONSTANT-Fieldref-CONSTANT-Methodref-CONSTANT-InterfaceMethodref" class="headerlink" title="CONSTANT_Fieldref ,CONSTANT_Methodref ,CONSTANT_InterfaceMethodref"></a>CONSTANT_Fieldref ,CONSTANT_Methodref ,CONSTANT_InterfaceMethodref</h3><p>字段、方法、接口方法</p><ul><li>tag 9 ,10, 11</li><li>class_index u2 (指向CONSTANT_Class)属于哪个类</li><li>name_and_type_index u2 (指向CONSTANT_NameAndType)本身的名字和类型</li></ul><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190304160706283.png"><br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190304073503808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"></p><h2 id="访问标识符"><a href="#访问标识符" class="headerlink" title="访问标识符"></a>访问标识符</h2><p>access flag u2：类的标示符<br>根据value的值做区分</p><p>Flag Name |Value |Interpretation<br>|-|-|-|<br>ACC_PUBLIC |0x0001 |public<br>ACC_FINAL |0x0010 |final,不能被继承.<br>ACC_SUPER |0x0020 |是否允许使用invokespecial指令，JDK1.2后，该值为true<br>ACC_INTERFACE |0x0200 |是否是接口<br>ACC_ABSTRACT |0x0400 |抽象类<br>ACC_SYNTHETIC |0x1000 |该类不是由用户代码生成,运行时生成的，没有源码<br>ACC_ANNOTATION |0x2000 |是否为注解<br>ACC_ENUM |0x4000 |是否是枚举</p><h2 id="类、超类、接口"><a href="#类、超类、接口" class="headerlink" title="类、超类、接口"></a>类、超类、接口</h2><ul><li>this_class u2<br>指向常量池的Class</li><li>super_class u2<br>指向常量池的Class</li><li>interface_count u2<br>接口数量</li><li>interfaces<br>interface_count 个 interface u2<br>每个interface是指向CONSTANT_Class的索引<h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2></li><li>field_count<br>字段数量</li><li>fields<br>field_count个field_info</li><li>field<br>access_flags u2<br>name_index u2<br>descriptor_index u2<br>attributes_count u2<br>attribute_info attributes[attributes_count];<h3 id="access-flags"><a href="#access-flags" class="headerlink" title="access_flags"></a>access_flags</h3>Flag Name |Value |Interpretat<br>|–|–|–|<br>ACC_PUBLIC |0x0001 |public<br>ACC_PRIVATE |0x0002 |private<br>ACC_PROTECTED |0x0004 |protected<br>ACC_STATIC |0x0008 |static.<br>ACC_FINAL |0x0010 |final<br>ACC_VOLATILE |0x0040 |volatile<br>ACC_TRANSIENT |0x0080 |transient<br>ACC_SYNTHETIC |0x1000 |synthetic;<br>ACC_ENUM |0x4000 |枚举类型<ul><li>name_index u2<br>常量池引用 ，表示字段的名字</li></ul></li><li>descriptor_index<br>表示字段的类型<br>为了尽量少的占用空间，简单表示</li></ul><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td></td><td>B</td><td>byte</td><td></td></tr><tr><td></td><td>C</td><td>char</td><td></td></tr><tr><td></td><td>D</td><td>double</td><td></td></tr><tr><td></td><td>F</td><td>float</td><td></td></tr><tr><td></td><td>I</td><td>int</td><td></td></tr><tr><td></td><td>J</td><td>long</td><td></td></tr><tr><td></td><td>S</td><td>short</td><td></td></tr><tr><td></td><td>Z</td><td>boolean</td><td></td></tr><tr><td></td><td>V</td><td>void</td><td></td></tr><tr><td></td><td>L</td><td>对象Ljava/lang/Object;</td><td></td></tr><tr><td></td><td>[</td><td>数组 [[Ljava/lang/String; = String[][] 二维数组[[</td><td></td></tr></tbody></table><h3 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h3><p>descriptor_index的字符串存放位置在哪里？</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>methods_count<br>方法数量</li><li>methods<br>methods_count个method_info<h3 id="method-info"><a href="#method-info" class="headerlink" title="method_info"></a>method_info</h3>access_flags u2<br>name_index u2<br>descriptor_index u2<br>attributes_count u2<br>attribute_info attributes[attributes_count];<h4 id="access-flag"><a href="#access-flag" class="headerlink" title="access flag"></a>access flag</h4>|-|-|-|<br>|–|–|–|<br>Flag Name | Value |Interpretation<br>ACC_PUBLIC | 0x0001 |public<br>ACC_PRIVATE | 0x0002 |private<br>ACC_PROTECTED | 0x0004 |protected<br>ACC_STATIC | 0x0008 |static<br>ACC_FINAL | 0x0010 |final<br>ACC_SYNCHRONIZED| 0x0020 |synchronized<br>ACC_BRIDGE | 0x0040 |编译器产生 桥接方法<br>ACC_VARARGS | 0x0080 |可变参数<br>ACC_NATIVE | 0x0100 |native<br>ACC_ABSTRACT | 0x0400 |abstract<br>ACC_STRICT | 0x0800 |strictfp<br>ACC_SYNTHETIC | 0x1000 |不在源码中，由编译器产<h4 id="name-index-u2"><a href="#name-index-u2" class="headerlink" title="name_index u2"></a>name_index u2</h4>方法名字，常量池UTF-8索引<h4 id="descriptor-index-u2"><a href="#descriptor-index-u2" class="headerlink" title="descriptor_index u2"></a>descriptor_index u2</h4>描述符，用于表达方法的参数和返回值</li><li>方法描述符<br>void inc() ()V<br>void setId(int) (I)V<br>int indexOf(char[],int ) ([CI)I<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2></li><li>在field和method中，可以有若干个attribute，类文件也有attribute，用于描述一些额外的信息<br>attribute_name_index u2<br>名字，指向常量池UTF-8<br>attribute_length u4<br>长度<br>info[attribute_length] u1<br>内容</li><li>attribute本身也可以包含其他attribute(即可嵌套的)</li><li>随着JDK的发展不断有新的attribute加入</li></ul><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>u2 |methods_count | 1 |<br>method_info |methods | methods_count |<br>u2 |attribute_count | 1 |<br>attribute_info |attributes | attributes_count |</p><table><thead><tr><th>名称</th><th>使用者</th><th>描述</th></tr></thead><tbody><tr><td>Deprecated</td><td>field method</td><td>字段、方法、类被废弃</td></tr><tr><td>ConstantValue</td><td>field</td><td>final常量</td></tr><tr><td>Code</td><td>method</td><td>方法的字节码和其他数据</td></tr><tr><td>ptions</td><td>method</td><td>方法的异常</td></tr><tr><td>LineNumberTable</td><td>Code_Attribute</td><td>方法行号和字节码映射</td></tr><tr><td>LocalVaribleTable</td><td>Code_Attribute</td><td>方法局部变量表描述</td></tr><tr><td>ceFile</td><td>Class file</td><td>源文件名</td></tr><tr><td>hetic</td><td>field method</td><td>编译器产生的方法或字段</td></tr></tbody></table><p>LineNUmberTable和LocalVatibleTable是Code_attribute的，即Attribute是可以嵌套使用的</p><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h3><p>attribute_name_index u2<br>attribute_length u4</p><ul><li>attribute_name_index<br>指向包含Deprecated的UTF-8常量</li><li>attribute_length<br>为0<h3 id="ConstantantValue"><a href="#ConstantantValue" class="headerlink" title="ConstantantValue"></a>ConstantantValue</h3>attribute_name_index u2<br>attribute_length u4<br>constantvalue_index u2</li><li>attribute_name_index<br>包含ConstantantValue字面量的UTF-8索引</li><li>attribute_length<br>为2</li><li>constantvalue_index<br>常量值，指向常量池，可以是UTF-8，Float, Double 等</li></ul><p>public static final int sid=99;<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190304160706370.png"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;<span class="comment">//Code</span></span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 max_stack;</span><br><span class="line">    u2 max_locals;</span><br><span class="line">    u4 code_length;<span class="comment">//字节码长度</span></span><br><span class="line">    u1 code[code_length];<span class="comment">//字节码</span></span><br><span class="line">    u2 exception_table_length;<span class="comment">//异常表长度</span></span><br><span class="line">    &#123;   u2 start_pc;<span class="comment">//异常处理的开始位置</span></span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc;<span class="comment">//处理这个异常的字节码位置</span></span><br><span class="line">        <span class="comment">//如果出现异常处理代码的指针就会偏移到这里</span></span><br><span class="line">        u2 catch_type;<span class="comment">//处理的异常类型，指向Constant_Class的指针</span></span><br><span class="line">        <span class="comment">//是什么类型的异常</span></span><br><span class="line">    &#125; exception_table[exception_table_length];</span><br><span class="line">    u2 attributes_count;<span class="comment">//属性数量</span></span><br><span class="line">    <span class="comment">//在code基础上封装的属性，比如LineNumberTable</span></span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LineNumberTable-Code属性的属性-字节码的偏移量和对应的行号"><a href="#LineNumberTable-Code属性的属性-字节码的偏移量和对应的行号" class="headerlink" title="LineNumberTable - Code属性的属性(字节码的偏移量和对应的行号)"></a>LineNumberTable - Code属性的属性(字节码的偏移量和对应的行号)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;<span class="comment">//UTF-8常量池，字面量LineNumberTable</span></span><br><span class="line"></span><br><span class="line">    u4 attribute_length;</span><br><span class="line"></span><br><span class="line">    u2 line_number_table_length;<span class="comment">//表项</span></span><br><span class="line"></span><br><span class="line">    &#123;   u2 start_pc;<span class="comment">//字节码偏移量和对应的行号</span></span><br><span class="line">        u2 line_number;</span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LocalVariableTable-Code属性的属性-局部变量表"><a href="#LocalVariableTable-Code属性的属性-局部变量表" class="headerlink" title="LocalVariableTable -  Code属性的属性(局部变量表)"></a>LocalVariableTable - Code属性的属性(局部变量表)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;<span class="comment">//UTF-8常量池，字面量LocalVariableTable</span></span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line"></span><br><span class="line">    &#123;   u2 start_pc;<span class="comment">//局部变量作用域，从哪里开始</span></span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;<span class="comment">//局部变量名称</span></span><br><span class="line">        u2 descriptor_index;<span class="comment">//类型</span></span><br><span class="line">        u2 index;<span class="comment">//局部变量的Slot位置</span></span><br><span class="line">        <span class="comment">//局部变量的slot是能够重用的，为了节省空间，后面局部变量会重用前面局部变量的slot</span></span><br><span class="line">        <span class="comment">//slot的意思是”变量槽“</span></span><br><span class="line">    &#125; local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h3><p>和Code属性平级<br>表示方法抛出的异常 <strong><font color="red">(不是try catch部分，而是 throws部分)</font></strong></p><ul><li>结构<br>attribute_name_index u2<br>attribute_length u4<br>number_of_exceptions u2<br>exception_index_table[number_of_exceptions] u2 这个class就是要抛出的异常的类<br>指向Constant_Class的索引<h4 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h4></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> setAge(int age)  throws IOException&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IllegalStateException e)&#123;</span><br><span class="line"><span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190304160710163.png"><br>code里面的Exception即try catch的是第五个字节码如果发生了异常，就跳转到第八个字节码，上小节有讲到。</p><h3 id="SourceFile"><a href="#SourceFile" class="headerlink" title="SourceFile"></a>SourceFile</h3><p>描述生成Class文件的源码文件名称</p><ul><li>结构<br>attribute_name_index u2<br>attribute_length u4<br>固定为2<br>soucefile_index u2文件名<br>UTF-8常量索引<h1 id="class文件结构🌰"><a href="#class文件结构🌰" class="headerlink" title="class文件结构🌰"></a>class文件结构🌰</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">private int id;</span><br><span class="line">private <span class="built_in">String</span> name;</span><br><span class="line">private int age;</span><br><span class="line">public int getId() &#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">void</span> setId(int id) &#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="built_in">String</span> getName() &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">void</span> setName(<span class="built_in">String</span> name) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public int getAge() &#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">void</span> setAge(int age) &#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190304160709322.png"><br>0123 魔数，表示是class文件<br>45 小版本<br>67 大版本<br>89 常量池的个数0025表示36个常量<br>接着开始描述常量池里面的内容<br>A 07 表示class类型的常量（上面有对应的表格）<br>class类型的常量里有0002，表示指向常量池的指针，这个类的utf-8的描述是常量池的第二个，第二个是什么呢？看D 发现是01类型的就是utf-8。然后是长度001B，即27，内容是geym/————User，至此完整描述了一个类</p><p>常量池里面一共36个，这里不一一的进行分析<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190304160708880.png"><br>access_flag访问权限 0021表示public和super<br>然后thisclass，跟上常量池的第一个，第一个就是类本身<br>superclass，父类<br>interface，接口，没有实现接口，所以是0，<br>field count 0003三个，确实是三个字段<br>0002 第一个字段开始描述了，field count 之后就是具体信息的描述，这里的0002表示field是private的即私有的<br>0005 field名字的索引在常量池中的索引是第五个<br>0006 描述符，大写的I 表示这个field的类型是一个int类型<br>0000 attribute 没有attribute</p><p>以此类推将三个field解读一下。<br>0007,field描述完之后开始描述方法method count 7个方法上面一共有六个，7个因为还有一个构造函数<br>0001 public方法<br>000A方法名字的索引表示的是init方法。<br>000B方法描述<br>0001attribute count属性的值</p><p>离散的标出了几个方法的开始<br>00010013<br>00010017<br>000100<br>0001001D<br>0001001F</p><p>00010022表示最后一个方法setAge<br>0018方法的descritor方法的描述签名<br>0001attribute count 1<br>000c code属性<br>0000003E changdu 62<br>0002max stack最大栈的大小<br>0002max locals最大局部变量表的大小<img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190304160707218.png"><br>上图表示code<br>00000006 6个byte<br>2A1BB50020B1系统中真正运行的字节码<br>0000异常表因为没有异常所以为空<br>0002属性属性<br>000Flinenumbertable<br>0000000A长度为10<br>0002linenumber table lenth表象<br>0000 0017 0005 0018 分别为偏移量和行号<br>0010 局部变量表<br>00000016 长度22<br>。。。<br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190304134755173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>0002局部变量表的表象的长度<br>0000偏移量<br>0006长度作用范围<br>0011第一局部变量的名字，this<br>0012局部变量的类型user<br>0000slot第一个slot被它所占<br>00000006另一个局部变量的信息<br>0001attribute其他的属性 还有一个<br>0023哪个源文件声称出来的<br>00000002长度2<br>0024指向索引，类是由User.java编译出来的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;语言无关性&quot;&gt;&lt;a href=&quot;#语言无关性&quot; class=&quot;headerlink&quot; title=&quot;语言无关性&quot;&gt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM内核-原理、诊断与优化学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM%E5%86%85%E6%A0%B8-%E5%8E%9F%E7%90%86%E3%80%81%E8%AF%8A%E6%96%AD%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="http://mmmmmm.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内核-原理、诊断与优化学习笔记（九）：锁</title>
    <link href="http://mmmmmm.me/2019-03-03-2.html"/>
    <id>http://mmmmmm.me/2019-03-03-2.html</id>
    <published>2019-03-03T08:21:02.000Z</published>
    <updated>2019-03-03T14:19:57.064Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="多线程网站统计访问人数"><a href="#多线程网站统计访问人数" class="headerlink" title="多线程网站统计访问人数"></a>多线程网站统计访问人数</h2><p>使用锁，维护计数器的串行访问与安全性<br>当然如果网站的任务精确度要求不是很高，并发量不是很大，可以不加锁，以此提升性能，具体怎样取舍看实际情况</p><h2 id="多线程访问ArrayList"><a href="#多线程访问ArrayList" class="headerlink" title="多线程访问ArrayList"></a>多线程访问ArrayList</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> List&lt;Integer&gt; numberList =<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddToList</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">int startnum=<span class="number">0</span>;</span><br><span class="line">public AddToList(int startnumber)&#123;</span><br><span class="line">startnum=startnumber;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line">int count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(count&lt;<span class="number">1000000</span>)&#123;</span><br><span class="line">numberList.add(startnum);</span><br><span class="line">startnum+=<span class="number">2</span>;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AddToList(<span class="number">0</span>));</span><br><span class="line">Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AddToList(<span class="number">1</span>));</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line"><span class="keyword">while</span>(t1.isAlive() || t2.isAlive())&#123;</span><br><span class="line">Thread.sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(numberList.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190303210402250.png"><br>根据上上面的代码命名应该会有200000的容量，ArrayList是会自己扩容的，为什么最后报错ArrayIistOutOfBoundsException（下标越界）的错误呢？<br>ArrayList不是线程安全的，虽然它自己会扩容，但是如果它如果容量不够需要扩展的情况下，实际上它是一个不可用的状态，这个时候，如果另一个线程突然往里面插数据，又没有对ArrayList做线程保护， ArrayList本身是不可用的，因此抛出这个异常。</p><p>所以很可能线程不仅仅是不能精确统计的问题，很可能整个程序根本无法正常的执行。</p><h1 id="对象头Mark"><a href="#对象头Mark" class="headerlink" title="对象头Mark"></a>对象头Mark</h1><h2 id="Mark-Word，对象头的标记，32位"><a href="#Mark-Word，对象头的标记，32位" class="headerlink" title="Mark Word，对象头的标记，32位"></a>Mark Word，对象头的标记，32位</h2><h2 id="描述对象的hash、锁信息，垃圾回收标记，年龄"><a href="#描述对象的hash、锁信息，垃圾回收标记，年龄" class="headerlink" title="描述对象的hash、锁信息，垃圾回收标记，年龄"></a>描述对象的hash、锁信息，垃圾回收标记，年龄</h2><p>指向锁记录的指针<br>指向monitor的指针<br>GC标记<br>偏向锁线程ID</p><h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><ul><li>大部分情况是没有竞争的，或者竞争不激烈的，所以可以通过偏向来提高性能</li><li>所谓的偏向，就是偏心，即锁会偏向于当前已经占有锁的线程</li><li>将对象头Mark的标记设置为偏向，并将线程ID写入对象头Mark</li><li>只要没有竞争，获得偏向锁的线程，在将来进入同步块，不需要做同步</li><li>当其他线程请求相同的锁时，偏向模式结束</li><li>-XX:+UseBiasedLocking 默认启用</li><li><strong><font color="red">在竞争激烈的场合，偏向锁会增加系统负担</font></strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> List&lt;Integer&gt; numberList =<span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">long begin=System.currentTimeMillis();</span><br><span class="line">int count=<span class="number">0</span>;</span><br><span class="line">int startnum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(count&lt;<span class="number">10000000</span>)&#123;</span><br><span class="line">numberList.add(startnum);</span><br><span class="line">startnum+=<span class="number">2</span>;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">long end=System.currentTimeMillis();</span><br><span class="line">System.out.println(end-begin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表面上看起来没有加锁，但是Vector是通过加锁保证线程安全的。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开偏向锁，因为jvm刚启动的时候竞争是比较激烈的，所以系统默认是过几秒钟在开启偏向锁的</span></span><br><span class="line"><span class="comment">//这里BiasedLockingStartupDelay=0是希望jvm刚起动就打开偏向锁</span></span><br><span class="line"><span class="comment">//因为这个程序执行的很快</span></span><br><span class="line">-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=<span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭偏向锁</span></span><br><span class="line">-XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure><p>本例中，使用偏向锁，可以获得5%以上的性能提升</p><h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><h2 id="BasicObjectLock"><a href="#BasicObjectLock" class="headerlink" title="BasicObjectLock"></a>BasicObjectLock</h2><p>嵌入在 <strong><font color="red">线程栈</font></strong>中的对象<br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190303212517541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>BasicLock就是对象头，ptr to obj holdd the lock 指向持有这个锁的对象的指针</p><h2 id="为什么要有轻量级锁"><a href="#为什么要有轻量级锁" class="headerlink" title="为什么要有轻量级锁"></a>为什么要有轻量级锁</h2><ul><li>普通的锁处理性能不够理想，轻量级锁是一种快速的锁定方法。</li><li>如果对象没有被锁定<br>将对象头的Mark指针保存到锁对象（BasicObjectLock）中<br>将对象头设置为指向锁的指针（在线程栈空间中）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁里面有displaced_header（对象头）</span></span><br><span class="line">lock-&gt;set_displaced_header(mark);</span><br><span class="line"><span class="comment">//对象交换，将lock（锁）本身放到对象头当中去</span></span><br><span class="line"><span class="comment">//如果成功了就表示锁拿到了，lock是位于线程栈中的，因此如何判断线程持有这个锁</span></span><br><span class="line"><span class="comment">//只需要判断对象头的指针，是不是在线程的栈当中，</span></span><br><span class="line"><span class="comment">//是就是持有这把锁，不是就没有持有这把锁</span></span><br><span class="line"> <span class="keyword">if</span> (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;mark_addr(), mark)) &#123;</span><br><span class="line">      TEVENT (slow_enter: release stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果轻量级锁失败，表示存在竞争，升级为重量级锁（常规锁）<br>在没有锁竞争的前提下，减少传统锁使用OS互斥量产生的性能损耗<br>在竞争激烈时，轻量级锁会多做很多额外操作（无用功），导致性能下降</p><h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>当竞争存在时，如果线程可以很快获得锁，那么可以不在OS层挂起线程，让线程做几个空操作（自旋）<br>JDK1.6中-XX:+UseSpinning开启<br>JDK1.7中，去掉此参数，改为内置实现<br>如果同步块很长，需要自旋很久，还没有拿到锁，自旋失败，会降低系统性能<br>如果同步块很短，很快就拿到了锁，自旋成功，节省线程挂起切换时间，提升系统性能</p><h1 id="偏向锁，轻量级锁，自旋锁总结"><a href="#偏向锁，轻量级锁，自旋锁总结" class="headerlink" title="偏向锁，轻量级锁，自旋锁总结"></a>偏向锁，轻量级锁，自旋锁总结</h1><ul><li>不是Java语言层面的锁优化方法</li><li><p>内置于JVM中的获取锁的优化方法和获取锁的步骤<br>偏向锁可用会先尝试偏向锁<br>轻量级锁可用会先尝试轻量级锁<br>以上都失败，尝试自旋锁<br>再失败，尝试普通锁，使用OS互斥量在操作系统层挂起</p><p><strong><font color="red">线面开始是jvm级别的锁的优化</font></strong></p><h1 id="减少锁持有时间"><a href="#减少锁持有时间" class="headerlink" title="减少锁持有时间"></a>减少锁持有时间</h1></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public synchronized <span class="keyword">void</span> syncMethod()&#123;</span><br><span class="line">othercode1();</span><br><span class="line">mutextMethod();</span><br><span class="line">othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变成：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> syncMethod2()&#123;</span><br><span class="line">othercode1();</span><br><span class="line">synchronized(<span class="keyword">this</span>)&#123;</span><br><span class="line">mutextMethod();</span><br><span class="line">&#125;</span><br><span class="line">othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>没有必要做同步的就不要放到同步代码块中</p><h1 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h1><ul><li>将大对象，拆成小对象，大大增加并行度，降低锁竞争</li><li>偏向锁，轻量级锁成功率提高（因为希望在短时间内得到锁）</li><li>ConcurrentHashMap</li><li>HashMap的同步实现<br>Collections.synchronizedMap(Map&lt;K,V&gt; m)<br>返回SynchronizedMap对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public V get(<span class="built_in">Object</span> key) &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.get(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ConcurrentHashMap<br>若干个Segment ：Segment&lt;K,V&gt;[] segments<br>Segment中维护HashEntry&lt;K,V&gt;<br>put操作时<br>先定位到Segment，锁定一个Segment，执行put</li><li><p>在减小锁粒度后， ConcurrentHashMap允许若干个线程同时进入</p><h2 id="小问题？"><a href="#小问题？" class="headerlink" title="小问题？"></a>小问题？</h2><p>减少锁粒度后，可能会带来什么负面影响呢？以ConcurrentHashMap为例，说明分割为多个<br>Segment后，在什么情况下，会有性能损耗？</p><h1 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h1><p>根据功能进行锁分离<br>ReadWriteLock<br>读多写少的情况，可以提高性能<br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190303214844901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>ArrayLIst在写的时候可能需要做一些扩展，这个时候禁止其他任何线程对它做访问。</p></li><li><p>读写分离思想可以延伸，只要操作互不影响，锁就可以分离</p></li><li>LinkedBlockingQueue<br>队列<br>链表<br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190303215307471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>take和put操作互补影响，就可以进行分离。<h1 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h1>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短（比如自旋），即在使用完公共资源后，应该立即释放锁。只有这样，等待在这个锁上的其他线程才能尽早的获得资源执行任务。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化<h2 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> demoMethod()&#123;</span><br><span class="line">synchronized(lock)&#123;</span><br><span class="line"><span class="comment">//do sth.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//做其他不需要的同步的工作，但能很快执行完毕</span></span><br><span class="line">synchronized(lock)&#123;</span><br><span class="line"><span class="comment">//do sth.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>变成：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> demoMethod()&#123;</span><br><span class="line"><span class="comment">//整合成一次锁请求</span></span><br><span class="line">synchronized(lock)&#123;</span><br><span class="line"><span class="comment">//do sth.</span></span><br><span class="line"><span class="comment">//做其他不需要的同步的工作，但能很快执行完毕</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;CIRCLE;i++)&#123;</span><br><span class="line">synchronized(lock)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变成：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized(lock)&#123;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;CIRCLE;i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h1><p>在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span> args[]) throws InterruptedException &#123;</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; CIRCLE; i++) &#123;</span><br><span class="line">craeteStringBuffer(<span class="string">"JVM"</span>, <span class="string">"Diagnosis"</span>);</span><br><span class="line">&#125;</span><br><span class="line">long bufferCost = System.currentTimeMillis() - start;</span><br><span class="line">System.out.println(<span class="string">"craeteStringBuffer: "</span> + bufferCost + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="built_in">String</span> craeteStringBuffer(<span class="built_in">String</span> s1, <span class="built_in">String</span> s2) &#123;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(s1);</span><br><span class="line">sb.append(s2);</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>append是同步的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CIRCLE= <span class="number">2000000</span></span><br></pre></td></tr></table></figure><p>DoEscapeAnalysis逃逸分析，因为这个变量能够被其他的代码块访问，就不能确定究竟是不是需要线程安全了<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createStringBuffer: <span class="number">187</span> ms</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -XX:+DoEscapeAnalysis -XX:-EliminateLocks</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createStringBuffer: <span class="number">254</span> ms</span><br></pre></td></tr></table></figure><h1 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h1><ul><li>锁是悲观的操作</li><li>无锁是乐观的操作</li><li>无锁的一种实现方式<br>CAS(Compare And Swap)<br>非阻塞的同步<br>CAS(V,E,N)v要更新的变量e期望值，n如果达到期望值，赋给新值</li><li>在应用层面判断多线程的干扰，如果有干扰，则通知线程重试</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.atomic.AtomicInteger</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndSet(int newValue) &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        int current = get();</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, newValue))</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置新值，返回旧值<br>public final boolean compareAndSet(int expect, int update)<br>更新成功返回true<br>java.util.concurrent.atomic包使用无锁实现，性能高于一般的有锁操作</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM内核-原理、诊断与优化学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM%E5%86%85%E6%A0%B8-%E5%8E%9F%E7%90%86%E3%80%81%E8%AF%8A%E6%96%AD%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="http://mmmmmm.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内核-原理、诊断与优化学习笔记（八）：JAVA堆分析</title>
    <link href="http://mmmmmm.me/2019-03-03-1.html"/>
    <id>http://mmmmmm.me/2019-03-03-1.html</id>
    <published>2019-03-03T02:22:02.000Z</published>
    <updated>2019-03-12T12:14:09.334Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="内存溢出-OOM-的原因"><a href="#内存溢出-OOM-的原因" class="headerlink" title="内存溢出(OOM)的原因"></a>内存溢出(OOM)的原因</h1><h2 id="在JVM中，有哪些内存区间？"><a href="#在JVM中，有哪些内存区间？" class="headerlink" title="在JVM中，有哪些内存区间？"></a>在JVM中，有哪些内存区间？</h2><p>堆、永久区、线程栈、直接内存，此外还有code cache等，但是不会出现OOM。<br>这几块空间的总和是不能超过计算机分配给jvm的内存空间的，一般在32位的计算机中不能超过2g，总体上来说不能超过物理内存，如果任何一个内存空间没有办法得到足够的分配，都有可能会OOM</p><h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><p>使用堆中的空间，对其中无用的对象，没有进行及时的释放，导致堆溢出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span> args[])&#123;</span><br><span class="line">    ArrayList&lt;byte[]&gt; list=<span class="keyword">new</span> ArrayList&lt;byte[]&gt;();</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">1024</span>;i++)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> byte[<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为arrayList是持有byte数组，也就是说这些byte数组都是有引用的，所以byte数组不会被认为是垃圾对象，无法被系统回收。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">占用大量堆空间，直接溢出</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at geym.jvm.ch8.oom.SimpleHeapOOM.main(SimpleHeapOOM.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure><p><strong><font color="red">注意： Java heap space</font></strong><br>解决方法：增大堆空间，及时释放内存</p><h2 id="永久区"><a href="#永久区" class="headerlink" title="永久区"></a>永久区</h2><p>永久区存着类的元信息，所以当类很多的时候，永久区也会空间不足。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    for(int i=0;i&lt;100000;i++)&#123;</span><br><span class="line">        CglibBean bean = new CglibBean(&quot;geym.jvm.ch3.perm.bean&quot;+i,new HashMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里new了很多类<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">[Full GC[Tenured: <span class="number">2523</span>K-&gt;<span class="number">2523</span>K(<span class="number">10944</span>K), <span class="number">0.0125610</span> secs] <span class="number">2523</span>K-&gt;<span class="number">2523</span>K(<span class="number">15936</span>K), </span><br><span class="line">[Perm : <span class="number">4095</span>K-&gt;<span class="number">4095</span>K(<span class="number">4096</span>K)], <span class="number">0.0125868</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total <span class="number">4992</span>K, used <span class="number">89</span>K [<span class="number">0x28280000</span>, <span class="number">0x287e0000</span>, <span class="number">0x2d7d0000</span>)</span><br><span class="line">  eden space <span class="number">4480</span>K,   <span class="number">2</span>% used [<span class="number">0x28280000</span>, <span class="number">0x282966d0</span>, <span class="number">0x286e0000</span>)</span><br><span class="line">  <span class="keyword">from</span> space <span class="number">512</span>K,   <span class="number">0</span>% used [<span class="number">0x286e0000</span>, <span class="number">0x286e0000</span>, <span class="number">0x28760000</span>)</span><br><span class="line">  to   space <span class="number">512</span>K,   <span class="number">0</span>% used [<span class="number">0x28760000</span>, <span class="number">0x28760000</span>, <span class="number">0x287e0000</span>)</span><br><span class="line"> tenured generation   total <span class="number">10944</span>K, used <span class="number">2523</span>K [<span class="number">0x2d7d0000</span>, <span class="number">0x2e280000</span>, <span class="number">0x38280000</span>)</span><br><span class="line">   the space <span class="number">10944</span>K,  <span class="number">23</span>% used [<span class="number">0x2d7d0000</span>, <span class="number">0x2da46cf0</span>, <span class="number">0x2da46e00</span>, <span class="number">0x2e280000</span>)</span><br><span class="line"> compacting perm gen  total <span class="number">4096</span>K, used <span class="number">4095</span>K [<span class="number">0x38280000</span>, <span class="number">0x38680000</span>, <span class="number">0x38680000</span>)</span><br><span class="line">   the space <span class="number">4096</span>K,  <span class="number">99</span>% used [<span class="number">0x38280000</span>, <span class="number">0x3867fff0</span>, <span class="number">0x38680000</span>, <span class="number">0x38680000</span>)</span><br><span class="line">    ro space <span class="number">10240</span>K,  <span class="number">44</span>% used [<span class="number">0x38680000</span>, <span class="number">0x38af73f0</span>, <span class="number">0x38af7400</span>, <span class="number">0x39080000</span>)</span><br><span class="line">    rw space <span class="number">12288</span>K,  <span class="number">52</span>% used [<span class="number">0x39080000</span>, <span class="number">0x396cdd28</span>, <span class="number">0x396cde00</span>, <span class="number">0x39c80000</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong><font color="red">注意： PermGen space</font></strong><br>解决方法：<br>增大Perm区<br>允许Class回收（在JVM中可以设置为允许回收Class元数据）</p><h2 id="Java栈溢出"><a href="#Java栈溢出" class="headerlink" title="Java栈溢出"></a>Java栈溢出</h2><p>这里的栈溢出指，在创建线程的时候，需要为线程分配栈空间，这个栈空间是向操作系统请求的，如果操作系统无法给出足够的空间，就会抛出OOM<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190303194124779.png"><br>从上图可以看出对空间和线程栈空间是不能超过操作系统可分配的总空间的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepThread</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    public <span class="keyword">void</span> run()&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span> args[])&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepThread(),<span class="string">"Thread"</span>+i).start();</span><br><span class="line">        System.out.println(<span class="string">"Thread"</span>+i+<span class="string">" created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1g -Xss1m</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.OutOfMemoryError: </span><br><span class="line">unable to create <span class="keyword">new</span> native thread</span><br></pre></td></tr></table></figure><p><strong><font color="red">注意： unable to create new native thread</font></strong><br>解决方法：<br>减少堆内存<br>减少线程栈大小</p><p>解析：因为这里的问题是线程sleep时间太久，有太多的线程存在于栈中，所以没有足够的空间新建新的线程，从上面得知，操作系统的总空间是堆内存和线程栈空间的大小，所以这里可以减小堆内存，也可以减小单个线程栈的大小，就能够产生更多的线程。</p><h2 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h2><p>ByteBuffer.allocateDirect()无法从操作系统获得足够的空间<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190303194124379.png"><br>对空间、线程栈空间、直接内存加起来是不能大于操作系统可分配空间的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">1024</span>;i++)&#123;</span><br><span class="line">    ByteBuffer.allocateDirect(<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">      System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用ByteBuffer分配了一些直接的内存区域，这些内存是在堆外的，是操作系统直接分配给jvm内存的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1g -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>分配了一个g的堆空间<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190303194127250.png"><br>可以看到报错的直接原因是DirectByteBuffer分配的memory没有办法分配到，从最后面的堆中的信息可以看到堆的空间是十分富裕的，所以可以断定，就是因为使用直接内存过度导致的。</p><p>解决方法：<br>减少堆内存<br>有意触发GC</p><p>解析：同上面的栈空间解析一样，这三者加起来不能超过系统可分配的总空间，所以减小堆内存，能够解决直接内存堆栈溢出的问题。直接内存分配不会引起GC，只有堆和永久区会导致GC的发生，虽然直接内存是能够被jvm回收的，但是不能够自动触发GC。</p><h2 id="小问题？"><a href="#小问题？" class="headerlink" title="小问题？"></a>小问题？</h2><p>遇到内存溢出后，应该如何思考和处理问题？</p><h1 id="MAT使用基础"><a href="#MAT使用基础" class="headerlink" title="MAT使用基础"></a>MAT使用基础</h1><p>Memory Analyzer（MAT）内存分析的工具<br>基于Eclipse的软件（能够在eclipse官网进行下载）<br><a href="http://www.eclipse.org/mat/" target="_blank" rel="noopener">http://www.eclipse.org/mat/</a></p><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190303194126243.png"></p><h2 id="柱状图显示"><a href="#柱状图显示" class="headerlink" title="柱状图显示"></a>柱状图显示</h2><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190303194126228.png"><br>柱状图显示，显示每个类的使用情况，<br>比如类的数量，所占空间等</p><h2 id="支配树"><a href="#支配树" class="headerlink" title="支配树"></a>支配树</h2><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190303194128576.png"><br>显示支配树</p><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190303194126646.png"><br>上图可以看到，左边是对象引用图（a引用c，b引用c，等等略），右边是支配树（图中有支配树的解释），我认为更确切的解释是“所有指向对象B的路径都 <strong><font color="red">必须并且只能 </font></strong>经过A，则认为对象A支配对象B”，这里可以看到c可以通过a过来可以通过b过来，所以a、b与c之间没有支配关系，同样，可以退出上面的支配关系，但是注意h不能被f和g支配但是被c支配着，所以看似c和h之间离得很远，其实是直接支配的关系。</p><p>支配者被回收，被支配对象也会被回收：c被回收则d、e、f、g、h都会被回收<br>因为达到我的唯一路径被回收了，所以没有其他路径能过到达被支配对象了。<br><strong><font color="red">所以当一个对象被回收之后，究竟有多少内存空间能被释放掉，这个是个支配树直接相关的。</font></strong></p><h2 id="显示线程信息"><a href="#显示线程信息" class="headerlink" title="显示线程信息"></a>显示线程信息</h2><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190303194127422.png"><br>这里不是指线程堆栈的信息，而是每个线程在堆中的对象，比如这里就能看到主线程的一些信息，从而看到主线程的一些引用。</p><h2 id="显示堆总体信息，比如消耗最大的一些对象等"><a href="#显示堆总体信息，比如消耗最大的一些对象等" class="headerlink" title="显示堆总体信息，比如消耗最大的一些对象等"></a>显示堆总体信息，比如消耗最大的一些对象等</h2><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190303194128723.png"></p><h2 id="入引用和出引用"><a href="#入引用和出引用" class="headerlink" title="入引用和出引用"></a>入引用和出引用</h2><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190303194130304.png"></p><h2 id="浅堆、深堆"><a href="#浅堆、深堆" class="headerlink" title="浅堆、深堆"></a>浅堆、深堆</h2><p><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190303194129545.png"></p><h3 id="浅堆"><a href="#浅堆" class="headerlink" title="浅堆"></a>浅堆</h3><p>一个对象结构所占用的内存大小</p><p><img alt="在这里插入图片描述" data-original="../images/20190303182629113.png"><br>3个int类型以及一个引用类型合计占用内存3*4+4=16个字节。再加上对象头的8个字节，因此String对象占用的空间，即浅堆的大小是16+8=24字节<br>对象大小按照8字节对齐<br><strong><font color="red">浅堆大小和对象的内容无关，只和对象的结构有关</font></strong></p><h3 id="深堆"><a href="#深堆" class="headerlink" title="深堆"></a>深堆</h3><p>一个对象被GC回收后，可以真实释放的内存大小（是对象实际占用的空间的大小）<br><strong><font color="red">只能通过对象访问到的（直接或者间接）所有对象的浅堆之和 （支配树）</font></strong></p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190303183606703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190303194128788.png"><br>将b、a、c、d、e设置为null，f、g不设置为null<br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190303183714843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>可以看到f和g不仅在下面的dline有引用，而且被main引用因为没有被设置为null，所以能够被main当做局部变量（上图中local）使用。<br>右边的第一列是浅堆，第二列是深堆，每一个浅堆（point和line，因为line中是两个引用， <strong><font color="red">引用是四个字节 </font></strong>）都是16，f和g是没有引用任何人，所以也是16，<br>aline的深堆是32，因为aline被释放掉之后point a还被bline引用这，所以aline本身释放能释放16，再加上自己支配树上的b点，一共能释放32<br>bline能够释放本身（只能释放b点，因为a在aline中也有，所以是没有支配a点的）所以能够释放b点，一共也是32<br>cline除了自己的16，还有自己支配的d和e，所以一共48<br>dline只能释放16，因为除了释放自己，在mian的局部变量中还有f和g的引用，所以深堆是16</p><p>通过上面的分析：深堆就是 <strong><font color="red">对象被回收之后，实际能够释放的内存空间</font></strong></p><h1 id="使用Visual-VM分析堆"><a href="#使用Visual-VM分析堆" class="headerlink" title="使用Visual VM分析堆"></a>使用Visual VM分析堆</h1><h2 id="java自带的多功能分析工具，可以用来分析堆Dump"><a href="#java自带的多功能分析工具，可以用来分析堆Dump" class="headerlink" title="java自带的多功能分析工具，可以用来分析堆Dump"></a>java自带的多功能分析工具，可以用来分析堆Dump</h2><p><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190303185307711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>通过使用Visual VM可以知道哪个类的实例数是最多的，占用的空间大小是最多的，方便定位。<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190303194130385.png"><br>下面的过滤框方便过滤率类<br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190303185546546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>点击point实例，右边显示详细信息，和引用信息<br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190303185922764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>上图为使用OQL语句进行分析，通过类似于SQL语句的方式，进行查询，比如上面的OQL语句的含义就是将所有的point 对象通过{x:p.x,y:p.y}的json形式显示出来。<br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/201903031902354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>reference，返回引用了某个变量的对象<br>返回引用了(0,0)这个点的所有对象，发现有两条引用了（0，0）的点</p><h1 id="Tomcat-OOM分析案例"><a href="#Tomcat-OOM分析案例" class="headerlink" title="Tomcat OOM分析案例"></a>Tomcat OOM分析案例</h1><ul><li>Tomcat OOM<br>Tomcat 在接收大量请求时（可能通过jmeter压力测试）发生OOM，获取堆Dump文件，进行分析。</li><li>使用MAT打开堆<br>-分析目的：<br>找出OOM的原因<br>推测系统OOM时的状态<br>给出解决这个OOM的方法<br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190303191028721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>堆的大小是29m，推断当时，使用可30m左右堆的大小，所以29m的时候就发生了OOM的问题，还看到RetainedSize是16.4m，RetainedSize是释放掉对象后所能得到的空间，这个对象就是StandardManager，位于catalina.session包下，可以推断和session有关系，从图中可以看到最大的就是她16.4m<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190303194132727.png"><br>右击查看出引用（引用了谁）<br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190303191648238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>可以看到sessions深堆远远大于其他，推断是因为session中保存了大量的数据。<br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/201903031918118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>通过上图，打开sessions，发现有很多的segements，concurrentHashMap是一个高并发的HashMap，通过“锁分离”将HashMap的数组分成多份，每次加锁，只锁住其中的一个小锁，达到优化性能的作用。<br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190303192252199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>接着打开segement发现里面就是普通的table–》entry（表象）–》key、value，所以推断就是在保存了过多的session没有被释放</li></ul><p><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190303192507719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>验证是否是因为存放了过多的session<br>visual VM的OQL和MAT的OQL是有一定的区别的，但是也是支持的。<br>通过上面的OQL将所有的standerdSession对象查找出来，查询的最后发现返回了9941个对象，每个对象的深堆将近1.6k。所以断定OOM的时候系统中存在大量的访问，所以持有大量的session没有被释放掉。<br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190303192908964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>点击任意一个session，左边有详细的信息：<br>thisAccessedTime，当前访问的时间<br>maxInactiveInterval，最大的过期时间间隔，大约二十分钟<br>expiring，是否过期<br>creationTime，session创建的时间<br><img alt="在这里插入图片描述" data-original="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190303194135596.png"><br>上图中最后一个session创建时间减去第一个session创建时间/1000就是一个再多少秒之内是有请求的，9941/这个数值，就是每秒有创建了多少个，即多少次请求，所以得出了上图的结论。</p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><ol><li>OOM由于保存session过多引起，可以考虑增加堆大小</li><li>如果应用允许，缩短session的过期时间，使得session可以及时过期，并回收</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;内存溢出-OOM-的原因&quot;&gt;&lt;a href=&quot;#内存溢出-OOM-的原因&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM内核-原理、诊断与优化学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM%E5%86%85%E6%A0%B8-%E5%8E%9F%E7%90%86%E3%80%81%E8%AF%8A%E6%96%AD%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="http://mmmmmm.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内核-原理、诊断与优化学习笔记（七）：性能监控工具</title>
    <link href="http://mmmmmm.me/2019-03-03.html"/>
    <id>http://mmmmmm.me/2019-03-03.html</id>
    <published>2019-03-03T02:21:02.000Z</published>
    <updated>2019-03-12T12:14:09.309Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="系统性能监控"><a href="#系统性能监控" class="headerlink" title="系统性能监控"></a>系统性能监控</h1><p>确定系统运行的整体状态，基本定位问题所在</p><h2 id="系统性能监控-linux"><a href="#系统性能监控-linux" class="headerlink" title="系统性能监控- linux"></a>系统性能监控- linux</h2><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ uptime</span><br><span class="line"> <span class="number">7</span>:<span class="number">38</span>  up <span class="number">11</span> days, <span class="number">14</span>:<span class="number">06</span>, <span class="number">14</span> users, load averages: <span class="number">2.60</span> <span class="number">2.06</span> <span class="number">1.96</span></span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>系统时间</li><li>运行时间<br>例子中为7分钟</li><li>连接数<br>每一个终端算一个连接</li><li>1,5,15分钟内的系统平均负载<br>运行队列中的平均进程数，这个数越大负载越大。<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">top - <span class="number">07</span>:<span class="number">43</span>:<span class="number">53</span> up <span class="number">168</span> days, <span class="number">13</span>:<span class="number">16</span>,  <span class="number">2</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.00</span></span><br><span class="line">Tasks: <span class="number">110</span> total,   <span class="number">1</span> running, <span class="number">109</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie</span><br><span class="line">Cpu(s):  <span class="number">0.3</span>%us,  <span class="number">0.3</span>%sy,  <span class="number">0.0</span>%ni, <span class="number">99.3</span>%id,  <span class="number">0.0</span>%wa,  <span class="number">0.0</span>%hi,  <span class="number">0.0</span>%si,  <span class="number">0.0</span>%st</span><br><span class="line">Mem:    <span class="number">520132</span>k total,   <span class="number">425620</span>k used,    <span class="number">94512</span>k free,    <span class="number">91668</span>k buffers</span><br><span class="line">Swap:   <span class="number">135164</span>k total,     <span class="number">9164</span>k used,   <span class="number">126000</span>k free,   <span class="number">136948</span>k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line"> <span class="number">4694</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">440</span>m  <span class="number">77</span>m  <span class="number">14</span>m S  <span class="number">0.3</span> <span class="number">15.2</span> <span class="number">144</span>:<span class="number">14.78</span> java</span><br><span class="line"><span class="number">21796</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">12292</span> <span class="number">6332</span> <span class="number">5516</span> S  <span class="number">0.3</span>  <span class="number">1.2</span>   <span class="number">0</span>:<span class="number">00.14</span> sshd</span><br><span class="line">    <span class="number">1</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">2964</span>  <span class="number">624</span>  <span class="number">504</span> S  <span class="number">0.0</span>  <span class="number">0.1</span>   <span class="number">0</span>:<span class="number">01.14</span> init</span><br><span class="line">    <span class="number">2</span> root      <span class="number">20</span>   <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kthreadd</span><br><span class="line">    <span class="number">4</span> root       <span class="number">0</span> <span class="number">-20</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">0</span>:<span class="number">0</span>H</span><br><span class="line">    <span class="number">6</span> root      <span class="number">20</span>   <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">26.37</span> ksoftirqd/<span class="number">0</span></span><br><span class="line">    <span class="number">7</span> root      <span class="number">20</span>   <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2</span>:<span class="number">47.42</span> rcu_sched</span><br><span class="line">    <span class="number">8</span> root      <span class="number">20</span>   <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcu_bh</span><br><span class="line">    <span class="number">9</span> root      RT   <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> migration/<span class="number">0</span></span><br><span class="line">   <span class="number">10</span> root       <span class="number">0</span> <span class="number">-20</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> lru-add-drain</span><br><span class="line">   <span class="number">11</span> root      RT   <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">47.40</span> watchdog/<span class="number">0</span></span><br><span class="line">   <span class="number">12</span> root      <span class="number">20</span>   <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> cpuhp/<span class="number">0</span></span><br><span class="line">   <span class="number">13</span> root      <span class="number">20</span>   <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kdevtmpfs</span><br><span class="line">   <span class="number">14</span> root       <span class="number">0</span> <span class="number">-20</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> netns</span><br><span class="line">   <span class="number">15</span> root      <span class="number">20</span>   <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">15.88</span> khungtaskd</span><br><span class="line">   <span class="number">16</span> root      <span class="number">20</span>   <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> oom_reaper</span><br><span class="line">   <span class="number">17</span> root       <span class="number">0</span> <span class="number">-20</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> writeback</span><br><span class="line">   <span class="number">18</span> root      <span class="number">20</span>   <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">01.28</span> kcompactd0</span><br></pre></td></tr></table></figure><p>第一行的功能同uptime，然后包块CPU的使用情况、内存的使用情况、交换空间的使用情况，下面的表格是每个进程占CPU的情况。</p><h2 id="vmstat（虚拟内存统计）"><a href="#vmstat（虚拟内存统计）" class="headerlink" title="vmstat（虚拟内存统计）"></a>vmstat（虚拟内存统计）</h2><p>可以统计系统的CPU，内存，swap，io等情况<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1s采样一次，输出4次就结束了。</span></span><br><span class="line">[root@host ~]# vmstat 1 4</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>   <span class="number">9164</span>  <span class="number">94768</span>  <span class="number">91668</span> <span class="number">136948</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>    <span class="number">1</span>    <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>   <span class="number">9164</span>  <span class="number">94656</span>  <span class="number">91668</span> <span class="number">136972</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">12</span>   <span class="number">61</span>  <span class="number">108</span>  <span class="number">1</span>  <span class="number">0</span> <span class="number">99</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>   <span class="number">9164</span>  <span class="number">94656</span>  <span class="number">91668</span> <span class="number">136972</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">45</span>   <span class="number">87</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>   <span class="number">9164</span>  <span class="number">94688</span>  <span class="number">91668</span> <span class="number">136972</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">46</span>   <span class="number">90</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><p>java空间的使用情况：memory:free剩余内存，<br>io：bi、bo即输入输出，<br>system：多少个终中断，多少个上下文切换（cs， 每秒的环境（上下文）切换次数），用户占用的cpu是多少，上下文切换的越多，表示线程之间的切换比较频繁， us，用户CPU时间(非内核进程占用时间)（单位为百分比）。 us的值比较高时，说明用户进程消耗的CPU时间多</p><h2 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h2><ul><li>细致观察进程</li><li>需要安装<br>sudo apt-get install sysstat</li><li>监控CPU</li><li>监控IO</li><li>监控内存</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-p 指定进程 –u 监控CPU 每秒采样 一共3次</span></span><br><span class="line">[root@host ~]# pidstat -p  4694 -u 1 3</span><br><span class="line">Linux <span class="number">4.10</span><span class="number">.4</span><span class="number">-1.</span>el6.elrepo.i686 (host.localdomain) <span class="number">03</span>/<span class="number">02</span>/<span class="number">2019</span> _i686_(<span class="number">1</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="number">08</span>:<span class="number">11</span>:<span class="number">25</span> AM       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line"><span class="number">08</span>:<span class="number">11</span>:<span class="number">26</span> AM      <span class="number">4694</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  java</span><br><span class="line"><span class="number">08</span>:<span class="number">11</span>:<span class="number">27</span> AM      <span class="number">4694</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  java</span><br><span class="line"><span class="number">08</span>:<span class="number">11</span>:<span class="number">28</span> AM      <span class="number">4694</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  java</span><br><span class="line">Average:         <span class="number">4694</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     -  java</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-t 显示线程</span></span><br><span class="line">[root@host ~]# pidstat -p  4694 -u 1 3 -t</span><br><span class="line">Linux <span class="number">4.10</span><span class="number">.4</span><span class="number">-1.</span>el6.elrepo.i686 (host.localdomain) <span class="number">03</span>/<span class="number">02</span>/<span class="number">2019</span> _i686_(<span class="number">1</span> CPU)</span><br><span class="line"><span class="comment">//%usr看当前线程占用的cpu   参数”CPU“是指当前线程运行在哪个cpu上，</span></span><br><span class="line"><span class="comment">//一般有两个cpu的话，是轮着用的</span></span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">05</span> AM      TGID       TID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">06</span> AM      <span class="number">4694</span>         -    <span class="number">1.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">1.00</span>     <span class="number">0</span>  java</span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">06</span> AM         -      <span class="number">4694</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">06</span> AM         -      <span class="number">4695</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">06</span> AM         -      <span class="number">4696</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">06</span> AM         -      <span class="number">4697</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">06</span> AM         -      <span class="number">4698</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">06</span> AM         -      <span class="number">4699</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">06</span> AM         -      <span class="number">4700</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">06</span> AM         -      <span class="number">4701</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">06</span> AM         -      <span class="number">4702</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">06</span> AM         -      <span class="number">4703</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">06</span> AM         -      <span class="number">4704</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  |__java</span><br><span class="line"></span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">06</span> AM      TGID       TID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">07</span> AM      <span class="number">4694</span>         -    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  java</span><br><span class="line"><span class="number">08</span>:<span class="number">12</span>:<span class="number">07</span> AM         -      <span class="number">4694</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0</span>  |__java</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-d   io情况</span></span><br><span class="line">[root@host ~]# pidstat -p  4694  1 3 -d -t</span><br><span class="line">Linux <span class="number">4.10</span><span class="number">.4</span><span class="number">-1.</span>el6.elrepo.i686 (host.localdomain) <span class="number">03</span>/<span class="number">02</span>/<span class="number">2019</span> _i686_(<span class="number">1</span> CPU)</span><br><span class="line"><span class="comment">//PID：进程id</span></span><br><span class="line"><span class="comment">//kB_rd/s：每秒从磁盘读取的KB</span></span><br><span class="line"><span class="comment">//kB_wr/s：每秒写入磁盘KB</span></span><br><span class="line"><span class="comment">//kB_ccwr/s：任务取消的写入磁盘的KB。当任务截断脏的pagecache的时候会发生。</span></span><br><span class="line"><span class="comment">//COMMAND:task的命令名</span></span><br><span class="line"><span class="number">08</span>:<span class="number">13</span>:<span class="number">55</span> AM      TGID       TID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line"><span class="number">08</span>:<span class="number">13</span>:<span class="number">56</span> AM      <span class="number">4694</span>         -      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>  java</span><br><span class="line"><span class="number">08</span>:<span class="number">13</span>:<span class="number">56</span> AM         -      <span class="number">4694</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">13</span>:<span class="number">56</span> AM         -      <span class="number">4695</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">13</span>:<span class="number">56</span> AM         -      <span class="number">4696</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">13</span>:<span class="number">56</span> AM         -      <span class="number">4697</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">13</span>:<span class="number">56</span> AM         -      <span class="number">4698</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">13</span>:<span class="number">56</span> AM         -      <span class="number">4699</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">13</span>:<span class="number">56</span> AM         -      <span class="number">4700</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">13</span>:<span class="number">56</span> AM         -      <span class="number">4701</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">13</span>:<span class="number">56</span> AM         -      <span class="number">4702</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">13</span>:<span class="number">56</span> AM         -      <span class="number">4703</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>  |__java</span><br><span class="line"><span class="number">08</span>:<span class="number">13</span>:<span class="number">56</span> AM         -      <span class="number">4704</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>  |__java</span><br><span class="line"></span><br><span class="line"><span class="number">08</span>:<span class="number">13</span>:<span class="number">56</span> AM      TGID       TID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line"><span class="number">08</span>:<span class="number">13</span>:<span class="number">57</span> AM      <span class="number">4694</span>         -      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>  java</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="系统性能监控-windows"><a href="#系统性能监控-windows" class="headerlink" title="系统性能监控 - windows"></a>系统性能监控 - windows</h2><h3 id="任务管理器"><a href="#任务管理器" class="headerlink" title="任务管理器"></a>任务管理器</h3><p>描述每一个进程，右边是选择功能。<br><img alt="" data-original="../images/15515830761606.png"></p><h3 id="Perfmon"><a href="#Perfmon" class="headerlink" title="Perfmon"></a>Perfmon</h3><p>Windows自带多功能性能监控工具，windows+r-》输入perfmon<br><img alt="" data-original="../images/15515831007888.png"><br><img alt="" data-original="../images/15515831073180.png"><br><img alt="" data-original="../images/15515831108264.png"></p><p>如上图：右击-》添加计数器-》选择对象实例（进程），关键字java-》确定-》将原来的线条显示的方式变成报告的形式</p><p>可以看到最后的java进程中线程id为2368000的线程cpu占用时间100%。<br>% Processor Time<br>% Processor Time 指处理器用来执行非闲置线程时间的百分比。计算方法是，测量范例间隔内非闲置线程活动的时间，用范例间隔减去该值。这个计数器是处理器活动的主要说明器，显示在范例间隔时所观察的繁忙时间平均百分比。<br>% User Time<br>% User Time 指处理器处于用户模式的时间百分比。用户模式是为应用程序、环境分系统和整数分系统设计的有限处理模式。</p><h2 id="Process-Explorer"><a href="#Process-Explorer" class="headerlink" title="Process Explorer"></a>Process Explorer</h2><p>进程管理器<br><img alt="" data-original="../images/15515831220858.png"></p><p>右击-》属性，查看具体的线程使用情况，最消耗性能的是3132<br><img alt="" data-original="../images/15515831289177.png"></p><h3 id="小问题？"><a href="#小问题？" class="headerlink" title="小问题？"></a>小问题？</h3><p>找到系统内最消耗CPU的线程</p><h2 id="pslist"><a href="#pslist" class="headerlink" title="pslist"></a>pslist</h2><p>为什么介绍windows下命令行的形式？用于写一些脚本自动化测试。<br>需要安装<br>命令行工具<br>可用于自动化数据收集<br>显示java程序的运行情况<br><img alt="" data-original="../images/15515831368171.png"></p><p>cmd-》PsList javaw（查看javaw这个进程的使用情况）</p><ul><li>Cpu Time cpu时间<br>CPU时间就是单纯的消耗cpu的时间，这个值越大代表占用的cpu时间越多</li><li>Elapsed Time消耗的时间<br>占用的cpu时间，io或者网络上的读写，都有等待时间，这些时间不能算到cpu时间上去，也就是一些流失的时间，流失的时间等于cpu的时间，实际上cpu的时间加上等待时间。<br>但是这里的cpu时间大于流失时间，因为这个计算机是一个多核计算机，在多核计算机上，如果有两个核，第一个核流占用一分钟，第二个核也占用一分钟，最后还是一分钟，</li></ul><h3 id="pslist-javaw-d-查看javaw这个进程中的线程信息"><a href="#pslist-javaw-d-查看javaw这个进程中的线程信息" class="headerlink" title="pslist javaw -d(查看javaw这个进程中的线程信息)"></a>pslist javaw -d(查看javaw这个进程中的线程信息)</h3><p><img alt="" data-original="../images/15515831518900.png"></p><p>user time和kernel time分别是系统在用户模式和内核模式占用的cpu时间，应用程序在用户模式下运行，核心操作系统组件在内核模式下运行。<br>线程5756 上下文切换是9235</p><h1 id="Java自带的工具"><a href="#Java自带的工具" class="headerlink" title="Java自带的工具"></a>Java自带的工具</h1><p>查看Java程序运行细节，进一步定位问题，查看java程序本身的。<br>一般出了问题都先通过系统级别的性能监控工具，如果确定了是java程序本身除了问题，再用java自带的性能监控工具。<br><img alt="" data-original="../images/15515831681694.png"></p><p>这些工具在jdk中的tools.jar/sun/tools目录下面</p><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>列出java进程，类似于ps命令<br>参数-q可以指定jps只输出进程ID ，不输出类的短名称<br>参数-m可以用于输出传递给Java进程（主函数）的参数<br>参数-l可以用于输出主函数的完整路径<br>参数-v可以显示传递给JVM的参数</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jps</span><br><span class="line"><span class="number">16821</span></span><br><span class="line"><span class="number">31612</span> Jps</span><br><span class="line"><span class="number">26588</span> OsxApp</span><br><span class="line">➜  ~ jps -q</span><br><span class="line"><span class="number">16821</span></span><br><span class="line"><span class="number">31624</span></span><br><span class="line"><span class="number">26588</span></span><br><span class="line">➜  ~ jps -m</span><br><span class="line"><span class="number">31634</span> Jps -m</span><br><span class="line"><span class="number">16821</span></span><br><span class="line"><span class="number">26588</span> OsxApp</span><br><span class="line">➜  ~ jps -l</span><br><span class="line"><span class="number">16821</span></span><br><span class="line"><span class="number">31639</span> sun.tools.jps.Jps</span><br><span class="line"><span class="number">26588</span> org.jd.gui.OsxApp</span><br><span class="line">➜  ~ jps -v</span><br><span class="line"><span class="number">16821</span>  -Xms128m -Xmx750m -XX:ReservedCodeCacheSize=<span class="number">240</span>m -XX:+UseCompressedOops -Dfile.encoding=UTF<span class="number">-8</span> -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=<span class="number">50</span> -ea -Dsun.io.useCanonCaches=<span class="literal">false</span> -Djava.net.preferIPv4Stack=<span class="literal">true</span> -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -Xverify:none -XX:ErrorFile=<span class="regexp">/Users/</span>leesin/java_error_in_idea_%p.log -XX:HeapDumpPath=<span class="regexp">/Users/</span>leesin/java_error_in_idea.hprof -javaagent:<span class="regexp">/Applications/</span>IntelliJ IDEA.app/Contents/bin/JetbrainsCrack.jar -Djb.vmOptionsFile=<span class="regexp">/Applications/</span>IntelliJ IDEA.app/Contents/bin/idea.vmoptions -Didea.java.redist=jdk-bundled -Didea.home.path=<span class="regexp">/Applications/</span>IntelliJ IDEA.app/Contents -Didea.executable=idea -Didea.paths.selector=IntelliJIdea2018<span class="number">.1</span></span><br><span class="line"><span class="number">31644</span> Jps -Dapplication.home=<span class="regexp">/Library/</span>Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0</span>_202.jdk/Contents/Home -Xms8m</span><br><span class="line"><span class="number">26588</span> OsxApp -Dapple.laf.useScreenMenuBar=<span class="literal">true</span> -Xms512m</span><br></pre></td></tr></table></figure><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>可以用来查看正在运行的Java应用程序的扩展参数，甚至支持在运行时，修改部分参数<br>-flag<name>：打印指定JVM的参数值<br>-flag [+|-]<name>：设置指定JVM参数的布尔值<br>-flag<name>=<value>：设置指定JVM参数的值</value></name></name></name></p><h3 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>2972是进程号<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">显示了新生代对象晋升到老年代对象的最大年龄</span><br><span class="line">jinfo -flag MaxTenuringThreshold <span class="number">2972</span></span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">15</span></span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">显示是否打印GC详细信息</span><br><span class="line">jinfo -flag PrintGCDetails  <span class="number">2972</span></span><br><span class="line">-XX:-PrintGCDetails</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行时修改参数，控制是否输出GC日志</span><br><span class="line">jinfo -flag PrintGCDetails  <span class="number">2972</span></span><br><span class="line">-XX:-PrintGCDetails</span><br><span class="line"></span><br><span class="line">jinfo -flag +PrintGCDetails  <span class="number">2972</span></span><br><span class="line"></span><br><span class="line">jinfo -flag PrintGCDetails  <span class="number">2972</span></span><br><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>生成Java应用程序的堆快照和对象的统计信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将信息输出到s.txt</span></span><br><span class="line">jmap -histo <span class="number">2972</span> &gt;c:\s.txt</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   <span class="number">1</span>:          <span class="number">4983</span>        <span class="number">6057848</span>  [I</span><br><span class="line">   <span class="number">2</span>:         <span class="number">20929</span>        <span class="number">2473080</span>  &lt;constMethodKlass&gt;</span><br><span class="line">……………….</span><br><span class="line"><span class="number">1932</span>:             <span class="number">1</span>              <span class="number">8</span>  sun.java2d.pipe.AlphaColorPipe</span><br><span class="line"><span class="number">1933</span>:             <span class="number">1</span>              <span class="number">8</span>  sun.reflect.GeneratedMethodAccessor64</span><br><span class="line">Total        <span class="number">230478</span>       <span class="number">22043360</span></span><br></pre></td></tr></table></figure><p>打开s.txt发现，[I 占用了将近6m的空间</p><h3 id="Dump堆"><a href="#Dump堆" class="headerlink" title="Dump堆"></a>Dump堆</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将堆信息dump到系统的文件中   hprof文件通过特殊的工具打开</span></span><br><span class="line">jmap -dump:format=b,file=c:\heap.hprof <span class="number">2972</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dumping heap to C:\heap.hprof ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><p><img alt="" data-original="../images/15515831988264.png"></p><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>打印线程dump<br>-l 打印锁信息<br>-m 打印java和native的帧信息<br>-F 强制dump，当jstack没有响应时使用</p><h3 id="举个栗子-2"><a href="#举个栗子-2" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack <span class="number">120</span> &gt;&gt;C:\a.txt</span><br></pre></td></tr></table></figure><p>tid是java中的tid，操作系统中本线程的id是nid<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">"main" #1 prio=6 os_prio=0 tid=0x0831c400 nid=0xecc runnable [0x0018f000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at org.eclipse.swt.internal.win32.OS.WaitMessage(Native Method)</span><br><span class="line">at org.eclipse.swt.widgets.Display.sleep(Display.java:<span class="number">4657</span>)</span><br><span class="line">at org.eclipse.ui.application.WorkbenchAdvisor.eventLoopIdle(WorkbenchAdvisor.java:<span class="number">364</span>)</span><br><span class="line">at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor.eventLoopIdle(IDEWorkbenchAdvisor.java:<span class="number">917</span>)</span><br><span class="line">at org.eclipse.ui.internal.Workbench$<span class="number">3.</span>eventLoopIdle(Workbench.java:<span class="number">487</span>)</span><br><span class="line">at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$<span class="number">9.</span>run(PartRenderingEngine.java:<span class="number">1117</span>)</span><br><span class="line">at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:<span class="number">332</span>)</span><br><span class="line">at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:<span class="number">997</span>)</span><br><span class="line">at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:<span class="number">140</span>)</span><br><span class="line">at org.eclipse.ui.internal.Workbench$<span class="number">5.</span>run(Workbench.java:<span class="number">611</span>)</span><br><span class="line">at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:<span class="number">332</span>)</span><br><span class="line">at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:<span class="number">567</span>)</span><br><span class="line">at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:<span class="number">150</span>)</span><br><span class="line">at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:<span class="number">124</span>)</span><br><span class="line">at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:<span class="number">196</span>)</span><br><span class="line">at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:<span class="number">110</span>)</span><br><span class="line">at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:<span class="number">79</span>)</span><br><span class="line">at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:<span class="number">354</span>)</span><br><span class="line">at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:<span class="number">181</span>)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)</span><br><span class="line">at java.lang.reflect.Method.invoke(Unknown Source)</span><br><span class="line">at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:<span class="number">636</span>)</span><br><span class="line">at org.eclipse.equinox.launcher.Main.basicRun(Main.java:<span class="number">591</span>)</span><br><span class="line">at org.eclipse.equinox.launcher.Main.run(Main.java:<span class="number">1450</span>)</span><br></pre></td></tr></table></figure><p></p><h2 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h2><p>java自带的<br>图形化监控工具<br>可以查看Java应用程序的运行概况，监控堆信息、永久区使用情况、类加载情况等</p><ul><li>打开方式<br>win：jdk/bin下双击JConsole.exe<br>linux/mac：运行命令<code>$JAVA_HOME/bin/jconsole</code>(这里的$JAVA_HOME是jdk的路径)<br><img alt="" data-original="../images/15515832176371.png"></li></ul><p>选中-》连接<br><img alt="" data-original="../images/15515832271783.png"><br><img alt="" data-original="../images/15515832324623.png"></p><p>code cache是编译完的native的代码。<br>右上角有执行gc的按钮。<br><img alt="" data-original="../images/15515832402734.png"></p><p>所以建议以后写代码都给线程起一个比较好听，方便排查问题的名字。</p><h2 id="Visual-VM"><a href="#Visual-VM" class="headerlink" title="Visual VM"></a>Visual VM</h2><p>Visual VM是一个功能强大的多合一故障诊断和性能监控的可视化工具<br>-打开方式<br>win：jdk/bin下双击jvisualvm.exe<br>linux/mac：运行命令<code>$JAVA_HOME/bin/jvisualvm</code>(这里的$JAVA_HOME是jdk的路径)<br>本地-》VisualVM-》概述<br><img alt="" data-original="../images/15515832489585.png"></p><p>本地-》VisualVM-》监视</p><p><img alt="" data-original="../images/15515832594207.png"><br>右上角有强制执行gc和堆dump的按钮<br>本地-》VisualVM-》线程<br><img alt="" data-original="../images/15515832693242.png"></p><p>红色部分可以显示死锁，包括右上角有线程dump的按钮</p><p>性能监控：找到占用CPU时间最长的方法<br>本地-》VisualVM-》抽样器-》cpu</p><p><img alt="" data-original="../images/15515832853326.png"><br>根据cpu的时间自动进行排序<br>invocation调用次数</p><p>分析堆Dump<br>visualVm本身就是一个能够查看Dump堆文件的工具，下图就是通过VisualVm打开的Dump文件的内容<br><img alt="" data-original="../images/15515832936691.png"></p><p>小问题？<br>观察Java线程打印</p><h1 id="实战分析"><a href="#实战分析" class="headerlink" title="实战分析"></a>实战分析</h1><h2 id="运行一程序ThreadBlockMain，期望输出Hello-World-，结果在程序运行后，程序卡死，没有预期输出。"><a href="#运行一程序ThreadBlockMain，期望输出Hello-World-，结果在程序运行后，程序卡死，没有预期输出。" class="headerlink" title="运行一程序ThreadBlockMain，期望输出Hello,World ，结果在程序运行后，程序卡死，没有预期输出。"></a>运行一程序ThreadBlockMain，期望输出Hello,World ，结果在程序运行后，程序卡死，没有预期输出。</h2><p><img alt="" data-original="../images/15515833015880.png"></p><p>先通过jps命令找到进程id，然后将jstack dump到文件中，打开文件。<br>发现：线程还是RUNNABLE的状态，说明还在运行<br>在等待一个socketReceiverOrPeekData说明在等待接受一个网络io<br>再往下有一个DatagramSocketImpl说明是在等待一个UDP的socket</p><h2 id="Java程序HoldCPUMain运行后，发现占用CPU很高，希望能找到原因。"><a href="#Java程序HoldCPUMain运行后，发现占用CPU很高，希望能找到原因。" class="headerlink" title="Java程序HoldCPUMain运行后，发现占用CPU很高，希望能找到原因。"></a>Java程序HoldCPUMain运行后，发现占用CPU很高，希望能找到原因。</h2><p><img alt="" data-original="../images/15515833093962.png"></p><p>先通过jps找到进程id–》通过uptime发现load average（系统平均负载）比较大–》通过top命令发现java进程占用的cpu是百分之百<br><img alt="" data-original="../images/15515833167429.png"></p><p>通过pidstat命令查看pid为3455的进程的cpu使用情况并以线程的形式输出<br><strong><font color="red">注意这里的3467 </font></strong>：因为下面将会用到jstack命令，发现里面显示的都是用了十六进制表示的，所以应该将它转化成十六进制，即D8B<br><img alt="" data-original="../images/15515833243569.png"></p><p>通过jstack命令查看3455进程，找到了d8b这个线程，得知里面的第八行出现了问题。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁的结果是，程序卡死<br>可以用jstack查找死锁</p><h3 id="如何从jstack的输出中找出死锁"><a href="#如何从jstack的输出中找出死锁" class="headerlink" title="如何从jstack的输出中找出死锁"></a>如何从jstack的输出中找出死锁</h3><p><img alt="" data-original="../images/15515833390623.png"><br><img alt="" data-original="../images/15515833429657.png"></p><p>如果非常明显的能够找打一个简单的死锁，会自动输出如下：<br><img alt="" data-original="../images/15515833486715.png"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;系统性能监控&quot;&gt;&lt;a href=&quot;#系统性能监控&quot; class=&quot;headerlink&quot; title=&quot;系统性能监
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM内核-原理、诊断与优化学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM%E5%86%85%E6%A0%B8-%E5%8E%9F%E7%90%86%E3%80%81%E8%AF%8A%E6%96%AD%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="http://mmmmmm.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内核-原理、诊断与优化学习笔记（六）：类装载器</title>
    <link href="http://mmmmmm.me/2019-03-01.html"/>
    <id>http://mmmmmm.me/2019-03-01.html</id>
    <published>2019-03-01T02:21:02.000Z</published>
    <updated>2019-03-12T12:14:09.325Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="class装载验证流程"><a href="#class装载验证流程" class="headerlink" title="class装载验证流程"></a>class装载验证流程</h1><h2 id="class装载验证流程-1"><a href="#class装载验证流程-1" class="headerlink" title="class装载验证流程"></a>class装载验证流程</h2><p>加载<br>链接（验证、准备、解析）<br>初始化</p><h2 id="class装载验证流程-加载"><a href="#class装载验证流程-加载" class="headerlink" title="class装载验证流程 -加载"></a>class装载验证流程 -加载</h2><p>装载类的第一个阶段<br>取得类的二进制流<br>转为方法区数据结构<br>在Java堆中生成对应的java.lang.Class对象</p><h2 id="class装载验证流程-链接-验证"><a href="#class装载验证流程-链接-验证" class="headerlink" title="class装载验证流程 -链接 验证"></a>class装载验证流程 -链接 验证</h2><h3 id="链接-gt-验证"><a href="#链接-gt-验证" class="headerlink" title="链接 -&gt; 验证"></a>链接 -&gt; 验证</h3><p>目的：保证Class流的格式是正确的</p><h4 id="文件格式的验证"><a href="#文件格式的验证" class="headerlink" title="文件格式的验证"></a>文件格式的验证</h4><p>是否以0xCAFEBABE开头<br>版本号是否合理</p><h4 id="元数据验证（class文件简单语义的验证）"><a href="#元数据验证（class文件简单语义的验证）" class="headerlink" title="元数据验证（class文件简单语义的验证）"></a>元数据验证（class文件简单语义的验证）</h4><p>是否有父类（比如某个类继承了某个类，可是这个类根本就是不存在的。）<br>继承了final类？（继承了final的方法或者修改了final属性）<br>非抽象类实现了所有的抽象方法（非抽象类实现接口中所有的非抽象方法）</p><h4 id="字节码验证-很复杂"><a href="#字节码验证-很复杂" class="headerlink" title="字节码验证 (很复杂)"></a>字节码验证 (很复杂)</h4><p>运行检查<br>栈数据类型和操作码数据参数吻合（分配了两个字的空间，可是运行的时候可能不只是两个字、分配了两个局部变量，可是运行的时候发现很多的局部变量）<br>跳转指令指定到合理的位置（跳转至零跳转到字节码的一个偏移量上面，比如本来就五十个字节，结果跳转到第五十一个字节上去了。）</p><h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>常量池中描述类是否存在（比如一个类继承了某个类，可是这个接口或者类实际上是不存在。）<br>访问的方法或字段是否存在且有足够的权限（访问的方法或者字段的权限是否足够（public private等））</p><h2 id="class装载验证流程-链接-准备"><a href="#class装载验证流程-链接-准备" class="headerlink" title="class装载验证流程 -链接 准备"></a>class装载验证流程 -链接 准备</h2><h4 id="分配内存，并为类设置初始值-（方法区中）"><a href="#分配内存，并为类设置初始值-（方法区中）" class="headerlink" title="分配内存，并为类设置初始值 （方法区中）"></a>分配内存，并为类设置初始值 （方法区中）</h4><p>public static int v=1;<br>在准备阶段中，v会被设置为0<br>在初始化的<clinit>中才会被设置为1<br>对于static final类型，在准备阶段就会被赋上正确的值<br>public static final int v=1;</clinit></p><h2 id="class装载验证流程-链接-解析"><a href="#class装载验证流程-链接-解析" class="headerlink" title="class装载验证流程 -链接 解析"></a>class装载验证流程 -链接 解析</h2><h4 id="符号引用替换为直接引用"><a href="#符号引用替换为直接引用" class="headerlink" title="符号引用替换为直接引用"></a>符号引用替换为直接引用</h4><p>符号引用就是字符串，默认的超类就是java.lang.Object，符号引用就是在常亮池里面有个字符串，字符串的内容就是java.lang.Object，符号引用并不能被用，只是一种表示的方式，直接就是指针或者地址偏移量，因为最后一定是指向一个内存地址，替换为直接引用之后，class才能够用自己需要引用的内容。</p><p>符号引用：字符串引用对象不一定被加载<br>直接引用：指针或者地址偏移量引用对象一定在内存</p><h2 id="class装载验证流程-–-初始化"><a href="#class装载验证流程-–-初始化" class="headerlink" title="class装载验证流程 – 初始化"></a>class装载验证流程 – 初始化</h2><p>执行类构造器<clinit><br>static变量 赋值语句<br>static{}语句<br>子类的<clinit>调用前保证父类的<clinit>被调用</clinit></clinit></clinit></p><p><clinit>是线程安全的（一个线程进去之后其他的等待）</clinit></p><h2 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h2><p>Java.lang.NoSuchFieldError错误可能在什么阶段抛出？</p><h1 id="什么是类装载器ClassLoader"><a href="#什么是类装载器ClassLoader" class="headerlink" title="什么是类装载器ClassLoader"></a>什么是类装载器ClassLoader</h1><p>ClassLoader是一个抽象类<br>ClassLoader的实例将读入Java字节码将类装载到JVM中<br>ClassLoader可以定制，满足不同的字节码流获取方式（网络中、文件中）<br>ClassLoader负责类装载过程中的加载阶段（连接和初始化阶段是和ClassLoader是没有关系的）</p><h2 id="ClassLoader的重要方法"><a href="#ClassLoader的重要方法" class="headerlink" title="ClassLoader的重要方法"></a>ClassLoader的重要方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(<span class="built_in">String</span> name) throws ClassNotFoundException</span><br></pre></td></tr></table></figure><p>根据名字加载一个class，并返回这个class类的信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(byte[] b, int off, int len)</span><br></pre></td></tr></table></figure><p>定义一个类，参数：byte数组、偏移量、长度，不公开调用，byte数组中是二进制的字节码，二进制的流信息，就是class文件里面的内容，把二进制文件的信息转化成class文件的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(<span class="built_in">String</span> name) throws ClassNotFoundException</span><br></pre></td></tr></table></figure><p>loadClass回调该方法，即loadClass里面会调用findClass方法，去做类的查找。自定义ClassLoader的推荐做法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; findLoadedClass(<span class="built_in">String</span> name)</span><br></pre></td></tr></table></figure><p>寻找已经加载的类，只有查找不到才会做加载，如果已经加载了不会做二次的加载。</p><h1 id="JDK中ClassLoader默认设计模式"><a href="#JDK中ClassLoader默认设计模式" class="headerlink" title="JDK中ClassLoader默认设计模式"></a>JDK中ClassLoader默认设计模式</h1><p>BootStrap ClassLoader （启动ClassLoader）<br>Extension ClassLoader （扩展ClassLoader）<br>App ClassLoader （应用ClassLoader/系统ClassLoader）<br>Custom ClassLoader(自定义ClassLoader)</p><p>每个ClassLoader都有一个Parent作为父亲</p><h2 id="JDK中ClassLoader默认设计模式-–-协同工作"><a href="#JDK中ClassLoader默认设计模式-–-协同工作" class="headerlink" title="JDK中ClassLoader默认设计模式 – 协同工作"></a>JDK中ClassLoader默认设计模式 – 协同工作</h2><p><img alt="" data-original="../images/15514529271718.png"></p><p><strong><font color="red">注意：向上查找，不是查找这个类存在不存在，而是查找类被加载了没有！！！</font></strong><br><strong><font color="red">注意：向上查找，不是查找这个类存在不存在，而是查找类被加载了没有！！！</font></strong><br><strong><font color="red">注意：向上查找，不是查找这个类存在不存在，而是查找类被加载了没有！！！</font></strong><br>当找类的时候在当前的classloder找，即AppClassLoader，如果没有找到会将查找的请求给父类，ExtensionClassLoader，如果有则ExtensionClassLoader做加载，如果还没有，将查找的请求给BootsTrapClassLoader，有则加载，如果没有则说明这个类的整个ClassLoader的整个系列中都没有这个类，它就会尝试去加载。<br>加载的方法是从上往下的，并不是APPClassLoader找不到就让APPClassLoader做加载，先由BootsTrapClassLoader做加载，如果BootsTrapClassLoader加载成功了，下面的ClassLoader就不做事情，如果BootsTrapClassLoader没有加载成功，就让ExtensionClassLoader，做加载，如果ExtensionClassLoader没有加载成功，再让APPClassLoader加载。由此可见，如果一个class由BootsTrapClassLoader加载之后，再去询问，在ExtensionClassLoader中是没有的，因为不是第一个尝试加载的ClassLoader</p><ul><li>BootsTrapClassLoader 中是$JAVA_HOME/jre/lib/rt.jar中的内容，通常是java中的系统核心类，同样可以再启动jar的时候通过-Xbootsclasspath，使得后面的class文件通过BootsTrapClassLoader加载</li><li>ExtensionClassLoader加载$JAVAHOME/lib/ext/*.jar中的class内容</li><li>APPClassLoader加载来自在命令java中的classpath或者java.class.path系统属性或者CLASSPATH操作系统属性所指定的JAR类包和类路径，也就是我们经常用到的classpath路径<br><strong><font color="red">classpath的默认路径是当前路径</font></strong><h2 id="JDK中ClassLoader默认设计模式-–-协同工作-1"><a href="#JDK中ClassLoader默认设计模式-–-协同工作-1" class="headerlink" title="JDK中ClassLoader默认设计模式 – 协同工作"></a>JDK中ClassLoader默认设计模式 – 协同工作</h2></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized Class&lt;?&gt; loadClass(<span class="built_in">String</span> var1, boolean var2) throws ClassNotFoundException &#123;</span><br><span class="line"><span class="comment">//查看是否加载了类var1，加载过的话返回class，确保类只加载一次。</span></span><br><span class="line">        Class var3 = <span class="keyword">this</span>.findLoadedClass(var1);</span><br><span class="line">        <span class="comment">//如果找不到</span></span><br><span class="line">        <span class="keyword">if</span> (var3 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//请求父类做加载</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    var3 = <span class="keyword">this</span>.parent.loadClass(var1, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    var3 = <span class="keyword">this</span>.findBootstrapClassOrNull(var1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var5) &#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var3 == <span class="literal">null</span>) &#123;</span><br><span class="line">                var3 = <span class="keyword">this</span>.findClass(var1);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p><img alt="" data-original="../images/15514529527185.png"><br>描述:起初是左边的HelloLoader在如图的包下面，之后再在本机的clz目录下新建一个HelloLoader(红色部分)</p><ul><li>直接运行以上代码：<br>输出：I am in apploader</li><li>加上参数 -Xbootclasspath/a:D:/tmp/clz<br>输出：I am in bootloader<br>此时AppLoader中不会加载HelloLoader<br>I am in apploader 在classpath中却没有加载<br>说明类加载是从上往下的</li></ul><p>解析：<br><strong><font color="red">注意：向上查找，不是查找这个类存在不存在，而是查找类被加载了没有！！！</font></strong><br><strong><font color="red">注意：向上查找，不是查找这个类存在不存在，而是查找类被加载了没有！！！</font></strong><br><strong><font color="red">注意：向上查找，不是查找这个类存在不存在，而是查找类被加载了没有！！！</font></strong><br><strong><font color="red">classpath的默认路径是当前路径 </font></strong>，</p><ul><li><p>没有加入-Xbootclasspath/a:D:/tmp/clz命令的时候<br>首次肯定都没有被加载，这个时候，依次通过BootsTrapClassLoader（rt.jar/- XbootClasspath，发现没有），ExtensionClassLoader （lib/ext，还是没有），最后加载APPCLassLoader（因为 <strong><font color="red">classpath的默认路径是当前路径 </font></strong>，所以能够加载到），最后输出了I am in apploader</p></li><li><p>加入-Xbootclasspath/a:D:/tmp/clz参数<br>查找同上，首次加载查找一圈都没有查找到被加载，然后从上往下加载，这个时候由于设置了BootsTrapClassLoader的参数，所以在BootsTrapClassLoader层面就已经能够被加载到了，下面也不会再被加载，所以输出I am in bootloader</p></li></ul><h3 id="强制在apploader中加载"><a href="#强制在apploader中加载" class="headerlink" title="强制在apploader中加载"></a>强制在apploader中加载</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span> args[]) throws Exception &#123;</span><br><span class="line">ClassLoader cl=FindClassOrder2.class.getClassLoader();</span><br><span class="line"><span class="comment">//得到geym.jvm.ch6.findorder.HelloLoader的字节码</span></span><br><span class="line">byte[] bHelloLoader=loadClassBytes(<span class="string">"geym.jvm.ch6.findorder.HelloLoader"</span>);</span><br><span class="line"><span class="comment">//为甚么通过反射得到这个函数？因为这个函数是protect的</span></span><br><span class="line">Method md_defineClass=ClassLoader.class.getDeclaredMethod(<span class="string">"defineClass"</span>, byte[].class,int.class,int.class);</span><br><span class="line"><span class="comment">//set为true能够使用</span></span><br><span class="line"><span class="comment">//将此对象的 accessible 标志设置为指示的布尔值。</span></span><br><span class="line"><span class="comment">//值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。</span></span><br><span class="line"><span class="comment">//值为 false 则指示反射的对象应该实施 Java 语言访问检查。 </span></span><br><span class="line">md_defineClass.setAccessible(<span class="literal">true</span>);</span><br><span class="line">md_defineClass.invoke(cl, bHelloLoader,<span class="number">0</span>,bHelloLoader.length);</span><br><span class="line">md_defineClass.setAccessible(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">HelloLoader loader = <span class="keyword">new</span> HelloLoader();</span><br><span class="line">System.out.println(loader.getClass().getClassLoader());</span><br><span class="line">loader.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依然添加参数-Xbootclasspath/a:D:/tmp/clz<br>输出：I am in apploader</p><p>在查找类的时候，先在底层的Loader查找，是从下往上的。因为在APPLoader已经加载了，所以Apploader能找到，就不会去上层加载器加载</p><h3 id="小问题-1"><a href="#小问题-1" class="headerlink" title="小问题"></a>小问题</h3><p>能否只用反射，仿照上面的写法，将类注入启动ClassLoader呢？</p><h2 id="JDK中ClassLoader默认设计模式-–-问题"><a href="#JDK中ClassLoader默认设计模式-–-问题" class="headerlink" title="JDK中ClassLoader默认设计模式 – 问题"></a>JDK中ClassLoader默认设计模式 – 问题</h2><p><img alt="" data-original="../images/15514529646549.png"></p><p>如上图，接口位于rt.jar,实现类位于APPClassLoader，如果想要实现这个类，必须要在BootsTrapClassLoader中知道下面即APPClassLoader中的内容，可是这种双亲委派的机制，自底向上检查是否被夹在，APPClassLoader可以知道BootsTrapClassLoader中的内容，加载是自顶向下，加载了BootsTrapClassLoader之后就不能再加载ExtensionClassLoader和APPClassLoader，也就不能知道APPClassLoader中的内容，所以永远无法知道。</p><h2 id="JDK中ClassLoader默认设计模式-–-解决"><a href="#JDK中ClassLoader默认设计模式-–-解决" class="headerlink" title="JDK中ClassLoader默认设计模式 – 解决"></a>JDK中ClassLoader默认设计模式 – 解决</h2><ul><li>Thread. setContextClassLoader()<br>上下文加载器<br><strong><font color="red">是一个角色</font></strong><br>解释：角色是什么意思？小明是班里的一个成员，他的职务是班长，小明是ClassLoader，班长就是角色。<br>用以解决顶层ClassLoader无法访问底层ClassLoader的类的问题<br>基本思想是，在顶层ClassLoader中，传入底层ClassLoader的实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">tatic private Class getProviderClass(<span class="built_in">String</span> className, ClassLoader cl,</span><br><span class="line">        boolean doFallback, boolean useBSClsLoader) throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cl == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (useBSClsLoader) &#123;</span><br><span class="line">                <span class="keyword">return</span> Class.forName(className, <span class="literal">true</span>, FactoryFinder.class.getClassLoader());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cl = ss.getContextClassLoader();</span><br><span class="line">                <span class="keyword">if</span> (cl == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> cl.loadClass(className); <span class="comment">//使用上下文ClassLoader</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cl.loadClass(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException e1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doFallback) &#123;</span><br><span class="line">            <span class="comment">// Use current class loader - should always be bootstrap CL</span></span><br><span class="line">            <span class="keyword">return</span> Class.forName(className, <span class="literal">true</span>, FactoryFinder.class.getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">…..</span><br></pre></td></tr></table></figure><p>注意上面代码中的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> cl.loadClass(className);</span><br></pre></td></tr></table></figure><p>中的cl就是ContextClassLoader</p><p>代码来自于rt.jar中的<br>javax.xml.parsers.FactoryFinder<br>展示如何在启动类加载器加载AppLoader的类</p><p>上下文ClassLoader可以突破双亲模式的局限性</p><h2 id="双亲模式的破坏"><a href="#双亲模式的破坏" class="headerlink" title="双亲模式的破坏"></a>双亲模式的破坏</h2><p><strong><font color="red">双亲模式是默认的模式，但不是必须这么做</font></strong><br>Tomcat的WebappClassLoader 就会先加载自己的Class，找不到再委托parent<br>OSGi的ClassLoader形成网状结构，根据需要自由加载Class，因为他是热加载，一会加载了一会又不加载了，所以就是网状结构。</p><h3 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>破坏双亲模式例子- 先从底层ClassLoader加载<br>OrderClassLoader的部分实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized Class&lt;?&gt; loadClass(<span class="built_in">String</span> name, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">    <span class="comment">//现在自己的层面查找，</span></span><br><span class="line">    Class re=findClass(name);</span><br><span class="line">    <span class="comment">//找不到再去找父类</span></span><br><span class="line">    <span class="keyword">if</span>(re==<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(“无法载入类:”+name+“ 需要请求父加载器<span class="string">");</span></span><br><span class="line"><span class="string">        return super.loadClass(name,resolve);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return re;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(<span class="built_in">String</span> className) throws ClassNotFoundException &#123;</span><br><span class="line"><span class="comment">//在自己层面上找是否加载了类</span></span><br><span class="line">Class clazz = <span class="keyword">this</span>.findLoadedClass(className);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == clazz) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">String</span> classFile = getClassFile(className);</span><br><span class="line">        <span class="comment">//没有的话就在自己的层面上加载某个文件</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(classFile);</span><br><span class="line">        FileChannel fileC = fis.getChannel();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        WritableByteChannel outC = Channels.newChannel(baos);</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">         省略部分代码</span><br><span class="line">        fis.close();</span><br><span class="line">        byte[] bytes = baos.toByteArray();</span><br><span class="line"><span class="comment">//定义某个类</span></span><br><span class="line">        clazz = defineClass(className, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以达到了从自己开始加载的目的<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OrderClassLoader myLoader=<span class="keyword">new</span> OrderClassLoader(<span class="string">"D:/tmp/clz/"</span>);</span><br><span class="line">Class clz=myLoader.loadClass(<span class="string">"geym.jvm.ch6.classloader.DemoA"</span>);</span><br><span class="line">System.out.println(clz.getClassLoader());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"==== Class Loader Tree ===="</span>);</span><br><span class="line">ClassLoader cl=myLoader;</span><br><span class="line"><span class="keyword">while</span>(cl!=<span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.println(cl);</span><br><span class="line">    cl=cl.getParent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ava.io.FileNotFoundException: D:\tmp\clz\java\lang\<span class="built_in">Object</span>.class (系统找不到指定的路径。)</span><br><span class="line">at java.io.FileInputStream.open(Native Method)</span><br><span class="line">.....</span><br><span class="line">at geym.jvm.ch6.classloader.ClassLoaderTest.main(ClassLoaderTest.java:<span class="number">7</span>)</span><br><span class="line">无法载入类:java.lang.Object需要请求父加载器</span><br><span class="line">geym.jvm.ch6.classloader.OrderClassLoader@<span class="number">18</span>f5824</span><br><span class="line">==== Class Loader Tree ====</span><br><span class="line">geym.jvm.ch6.classloader.OrderClassLoader@<span class="number">18</span>f5824</span><br><span class="line">sun.misc.Launcher$AppClassLoader@f4f44a</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">1</span>d256fa</span><br></pre></td></tr></table></figure><p>因为所有的类都继承自Object，前面知道验证的过程需要先检查自己的父类是否加载，先从OrderClassLoader加载，即从文件中加载Object，找不到Object，之后使用appLoader加载Object<br>DemoA在ClassPath中，但由OrderClassLoader加载，而不是由APPClassLoader加载</p><p>如果OrderClassLoader不重载loadClass()，只重载findClass，还是双亲委派机制，那么程序输出为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@b23210</span><br><span class="line">==== Class Loader Tree ====</span><br><span class="line">geym.jvm.ch6.classloader.OrderClassLoader@<span class="number">290</span>fbc</span><br><span class="line">sun.misc.Launcher$AppClassLoader@b23210</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@f4f44a</span><br></pre></td></tr></table></figure><p>DemoA由AppClassLoader加载，Object也能加载到了</p><h1 id="热替换"><a href="#热替换" class="headerlink" title="热替换"></a>热替换</h1><ul><li>含义：<br>当一个class被替换后，系统无需重启，替换的类立即生效<br>php就是热替换的。<br>例子：<br>geym.jvm.ch6.hot.CVersionA</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CVersionA</span> </span>&#123;</span><br><span class="line">public <span class="keyword">void</span> sayHello() &#123;</span><br><span class="line">System.out.println(<span class="string">"hello world! (version A)"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DoopRun 不停调用CVersionA . sayHello()方法，因此有输出：<br>hello world! (version A)</li><li>在DoopRun 的运行过程中，替换CVersionA 为：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CVersionA</span> </span>&#123;</span><br><span class="line">public <span class="keyword">void</span> sayHello() &#123;</span><br><span class="line">System.out.println(<span class="string">"hello world! (version B)"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>替换后， DoopRun 的输出变为<br>hello world! (version B)<br>思考：应该如何做？</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;class装载验证流程&quot;&gt;&lt;a href=&quot;#class装载验证流程&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM内核-原理、诊断与优化学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM%E5%86%85%E6%A0%B8-%E5%8E%9F%E7%90%86%E3%80%81%E8%AF%8A%E6%96%AD%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="http://mmmmmm.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内核-原理、诊断与优化学习笔记（五）：GC参数</title>
    <link href="http://mmmmmm.me/2019-02-26.html"/>
    <id>http://mmmmmm.me/2019-02-26.html</id>
    <published>2019-02-26T02:21:02.000Z</published>
    <updated>2019-03-12T12:14:09.319Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="堆的回顾"><a href="#堆的回顾" class="headerlink" title="堆的回顾"></a>堆的回顾</h1><p><img alt="" data-original="../images/15511509832393.png"></p><h1 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h1><ul><li>最古老，最稳定</li><li>效率高</li><li>可能会产生较长的停顿（因为只有一个线程）<br>-XX:+UseSerialGC<br>新生代、老年代使用串行回收<br>新生代复制算法<br>老年代标记-压缩<br><img alt="" data-original="../images/15511510020884.png"></li></ul><p>GC关键字：新生代gc日志<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.844</span>: [GC <span class="number">0.844</span>: [DefNew: <span class="number">17472</span>K-&gt;<span class="number">2176</span>K(<span class="number">19648</span>K), <span class="number">0.0188339</span> secs] <span class="number">17472</span>K-&gt;<span class="number">2375</span>K(<span class="number">63360</span>K),</span><br><span class="line"> <span class="number">0.0189186</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></table></figure><p></p><p>Full GC关键字：老年代gc日志<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8.259</span>: [Full GC <span class="number">8.259</span>: [Tenured: <span class="number">43711</span>K-&gt;<span class="number">40302</span>K(<span class="number">43712</span>K), <span class="number">0.2960477</span> secs] <span class="number">63350</span>K-&gt;<span class="number">40302</span>K(<span class="number">63360</span>K), </span><br><span class="line">[Perm : <span class="number">17836</span>K-&gt;<span class="number">17836</span>K(<span class="number">32768</span>K)], <span class="number">0.2961554</span> secs] [Times: user=<span class="number">0.28</span> sys=<span class="number">0.02</span>, real=<span class="number">0.30</span> secs]</span><br></pre></td></tr></table></figure><p></p><h1 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h1><h2 id="ParNew（par-并行的缩写，new-新生代，所以只是新生代并行）"><a href="#ParNew（par-并行的缩写，new-新生代，所以只是新生代并行）" class="headerlink" title="ParNew（par-并行的缩写，new-新生代，所以只是新生代并行）"></a>ParNew（par-并行的缩写，new-新生代，所以只是新生代并行）</h2><ul><li>-XX:+UseParNewGC<br>新生代并行<br>老年代串行</li><li>Serial收集器新生代的并行版本</li><li>复制算法</li><li>多线程，需要多核支持</li><li>-XX:ParallelGCThreads 限制线程数量</li></ul><p>和串行收集器的区别是，通过多核支持多线程。</p><p><img alt="" data-original="../images/15511510178352.png"><br>多线程不一定快哦！<br>如果是多核用ParNew速度快一点，如果是单线程的话，还是建议串行收集器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.834</span>: [GC <span class="number">0.834</span>: [ParNew: <span class="number">13184</span>K-&gt;<span class="number">1600</span>K(<span class="number">14784</span>K), <span class="number">0.0092203</span> secs] <span class="number">13184</span>K-&gt;<span class="number">1921</span>K(<span class="number">63936</span>K), </span><br><span class="line"><span class="number">0.0093401</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure><p><strong><font color="red">注意：有ParNew关键字表示ParNew收集器</font></strong></p><h2 id="Parallel收集器"><a href="#Parallel收集器" class="headerlink" title="Parallel收集器"></a>Parallel收集器</h2><ul><li>类似ParNew</li><li>新生代复制算法</li><li>老年代 标记-压缩</li><li>更加关注吞吐量（和ParNew时候的区别）</li><li>-XX:+UseParallelGC<br>使用Parallel收集器+ 老年代串行+新生代并行</li><li>-XX:+UseParallelOldGC<br>使用Parallel收集器+ 并行老年代+新生代并行<br><img alt="" data-original="../images/15511510299020.png"></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.500</span>: [Full GC [PSYoungGen: <span class="number">2682</span>K-&gt;<span class="number">0</span>K(<span class="number">19136</span>K)] [ParOldGen: <span class="number">28035</span>K-&gt;<span class="number">30437</span>K(<span class="number">43712</span>K)] <span class="number">30717</span>K-&gt;<span class="number">30437</span>K(<span class="number">62848</span>K) </span><br><span class="line">[PSPermGen: <span class="number">10943</span>K-&gt;<span class="number">10928</span>K(<span class="number">32768</span>K)], </span><br><span class="line"><span class="number">0.2902791</span> secs] [Times: user=<span class="number">1.44</span> sys=<span class="number">0.03</span>, real=<span class="number">0.30</span> secs]</span><br></pre></td></tr></table></figure><p><strong><font color="red">注意：PSYoungGen 、ParOldGen关键字</font></strong></p><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><h3 id="XX-MaxGCPauseMills"><a href="#XX-MaxGCPauseMills" class="headerlink" title="-XX:MaxGCPauseMills"></a>-XX:MaxGCPauseMills</h3><p>最大停顿时间，单位毫秒<br>GC尽力保证回收时间不超过设定值</p><h3 id="XX-GCTimeRatio"><a href="#XX-GCTimeRatio" class="headerlink" title="-XX:GCTimeRatio"></a>-XX:GCTimeRatio</h3><p>0-100的取值范围<br>垃圾收集时间占总时间的比<br>默认99，即最大允许1%时间做GC</p><p>这两个参数是矛盾的。因为停顿时间和吞吐量不可能同时调优。</p><p>对于这句话的理解：<br>在gc的时候，垃圾回收的工作总量是一定的，所以就是花一定的时间做一定的事情，如果gc的频率提高，每次gc花的时间就会变少，可是系统的性能会受到损伤，就会导致停顿的时间比较短，可是总体的性能并不是很好。但是，为了追求高性能，gc少做几次，也就是XX:GCTimeRatio比值会比较大，gc时间较少，所以每次的gc停顿的时间就会比较长。<br>吞吐量：一般认为系统的性能是和吞吐量息息相关的，单位时间内cpu是分配到了应用程序还是gc，如果cpu是分配到应用程序越多，吞吐量越高。<br>吞吐量高-&gt;gc占用cpu时间短-&gt;gc停顿的时间长。<br>这里既希望gc的停顿时间短一点，又希望吞吐量大一点，所以是矛盾的，所以不能同时调优，所以有侧重的调优。</p><h1 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h1><h2 id="CMS收集器-1"><a href="#CMS收集器-1" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>Concurrent Mark Sweep 并发标记清除（ <strong><font color="red">与用户线程一起执行 </font></strong>）<br>试图和应用程序线程一起执行。<br>标记-清除算法<br>与标记-压缩相比（因为是并行的，所以不能使标记-压缩的方式）<br>并发阶段会降低吞吐量（停顿减少了，吞吐量就会降低）<br>老年代收集器（新生代使用ParNew，这里CMS是一个单纯的老年代的收集器）<br>-XX:+UseConcMarkSweepGC</p><h2 id="CMS运行过程比较复杂，着重实现了标记的过程，可分为"><a href="#CMS运行过程比较复杂，着重实现了标记的过程，可分为" class="headerlink" title="CMS运行过程比较复杂，着重实现了标记的过程，可分为"></a>CMS运行过程比较复杂，着重实现了标记的过程，可分为</h2><ul><li>初始标记<br>根可以直接关联到的对象<br>速度快<br>会产生全局停顿</li><li>并发标记（和用户线程一起）<br>主要标记过程，标记全部对象</li><li>重新标记<br>由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正<br>会产生全局停顿</li><li>并发清除（和用户线程一起）<br>基于标记结果，直接清理对象</li></ul><p>可以看到初始标记、重新标记都会产生全局的停顿，所以CMS还是没有办法去掉所有的全局停顿，但是已经大大的减小了全局停顿。<br><img alt="" data-original="../images/15511510454444.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.662</span>: [GC [<span class="number">1</span> CMS-initial-mark: <span class="number">28122</span>K(<span class="number">49152</span>K)] <span class="number">29959</span>K(<span class="number">63936</span>K), <span class="number">0.0046877</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="number">1.666</span>: [CMS-concurrent-mark-start]</span><br><span class="line"><span class="number">1.699</span>: [CMS-concurrent-mark: <span class="number">0.033</span>/<span class="number">0.033</span> secs] [Times: user=<span class="number">0.25</span> sys=<span class="number">0.00</span>, real=<span class="number">0.03</span> secs] </span><br><span class="line"><span class="number">1.699</span>: [CMS-concurrent-preclean-start]</span><br><span class="line"><span class="number">1.700</span>: [CMS-concurrent-preclean: <span class="number">0.000</span>/<span class="number">0.000</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="number">1.700</span>: [GC[YG occupancy: <span class="number">1837</span> K (<span class="number">14784</span> K)]<span class="number">1.700</span>: [Rescan (parallel) , <span class="number">0.0009330</span> secs]<span class="number">1.701</span>: [weak refs processing, <span class="number">0.0000180</span> secs] [<span class="number">1</span> CMS-remark: <span class="number">28122</span>K(<span class="number">49152</span>K)] <span class="number">29959</span>K(<span class="number">63936</span>K), <span class="number">0.0010248</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="number">1.702</span>: [CMS-concurrent-sweep-start]</span><br><span class="line"><span class="number">1.739</span>: [CMS-concurrent-sweep: <span class="number">0.035</span>/<span class="number">0.037</span> secs] [Times: user=<span class="number">0.11</span> sys=<span class="number">0.02</span>, real=<span class="number">0.05</span> secs] </span><br><span class="line"><span class="number">1.739</span>: [CMS-concurrent-reset-start]</span><br><span class="line"><span class="number">1.741</span>: [CMS-concurrent-reset: <span class="number">0.001</span>/<span class="number">0.001</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure><p>关键字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMS-initial-mark</span><br><span class="line">CMS-concurrent-mark</span><br><span class="line">CMS-remark</span><br><span class="line">CMS-concurrent-sweep</span><br><span class="line">CMS-concurrent-reset</span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>尽可能降低停顿</li><li>会影响系统整体吞吐量和性能<br>比如，在用户线程运行过程中，分一半CPU去做GC，系统性能在GC阶段，反应速度就下降一半</li><li>清理不彻底<br>因为在清理阶段，用户线程还在运行，会产生新的垃圾，无法清理</li><li>因为和用户线程一起运行，不能在空间快满时再清理<br>如果是串行清理、并行清理，gc的时候会停顿，gc完成之后有足够的空间来申请，但是CMS是和应用程序同时进行的，当空间快满时没有足够的空间供申请。<br>-XX:CMSInitiatingOccupancyFraction设置触发GC的阈值<br>如果不幸内存预留空间不够，就会引起concurrent mode failure</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33.348</span>: [Full GC <span class="number">33.348</span>: [CMS33<span class="number">.357</span>: [CMS-concurrent-sweep: <span class="number">0.035</span>/<span class="number">0.036</span> secs] [Times: user=<span class="number">0.11</span> sys=<span class="number">0.03</span>, real=<span class="number">0.03</span> secs] </span><br><span class="line"> (concurrent mode failure): <span class="number">47066</span>K-&gt;<span class="number">39901</span>K(<span class="number">49152</span>K),</span><br><span class="line">  <span class="number">0.3896802</span> secs] <span class="number">60771</span>K-&gt;<span class="number">39901</span>K(<span class="number">63936</span>K), [CMS Perm : <span class="number">22529</span>K-&gt;<span class="number">22529</span>K(<span class="number">32768</span>K)],</span><br><span class="line">  <span class="number">0.3897989</span> secs] [Times: user=<span class="number">0.39</span> sys=<span class="number">0.00</span>, real=<span class="number">0.39</span> secs]</span><br></pre></td></tr></table></figure><p>上面出现concurrent mode failure错误，表示在CMS的时候，内存申请失败。<br>使用串行收集器作为后备，及时将CMS收集转化为串行收集，但是因为出现这个错误说明内存已经到了消耗殆尽的状态，所以切换为串行收集的时候可能会出现长时间的停顿。</p><h2 id="有关碎片"><a href="#有关碎片" class="headerlink" title="有关碎片"></a>有关碎片</h2><p>标记-清除和标记-压缩<br><img alt="" data-original="../images/15511510634628.png"></p><p>上图可以看到，标记清除之后会出现碎片，如果要申请五个连续单位的空间，是申请不到的，而标记压缩清理之后是能够申请到，所以串行收集和并行收集都是标记压缩的，而标记清理算法之后一般对剩余的空间一般还要进行一次压缩。<br>可是为什么CMS是使用的标记清除？因为希望和用户线程同时进行，标记压缩在清理的时候需要移动可用的对象的空间，应用层的线程可能找不到对象在哪里，为了能够和应用程序并发执行， 就需要可用的对象位置是没有改变的。</p><p>所以出现如下的配置：</p><h3 id="XX-UseCMSCompactAtFullCollection"><a href="#XX-UseCMSCompactAtFullCollection" class="headerlink" title="-XX:+ UseCMSCompactAtFullCollection"></a>-XX:+ UseCMSCompactAtFullCollection</h3><p>Full GC后，进行一次整理<br>整理过程是独占的，会引起停顿时间变长</p><h3 id="XX-CMSFullGCsBeforeCompaction"><a href="#XX-CMSFullGCsBeforeCompaction" class="headerlink" title="-XX:+CMSFullGCsBeforeCompaction"></a>-XX:+CMSFullGCsBeforeCompaction</h3><p>设置进行几次Full GC后，进行一次碎片整理，当碎片很多的时候，还是会停顿很长的时间，所以不能从根本上解决问题。</p><h3 id="XX-ParallelCMSThreads"><a href="#XX-ParallelCMSThreads" class="headerlink" title="-XX:ParallelCMSThreads"></a>-XX:ParallelCMSThreads</h3><p>设定CMS的线程数量，一般约等于CPU的数量。</p><h1 id="GC参数整理"><a href="#GC参数整理" class="headerlink" title="GC参数整理"></a>GC参数整理</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC：在新生代和老年代使用串行收集器</span><br><span class="line">-XX:SurvivorRatio：设置eden区大小和survivior区大小的比例</span><br><span class="line">-XX:NewRatio:新生代和老年代的比</span><br><span class="line">-XX:+UseParNewGC：在新生代使用并行收集器</span><br><span class="line">-XX:+UseParallelGC ：新生代使用并行回收收集器</span><br><span class="line">-XX:+UseParallelOldGC：老年代使用并行回收收集器</span><br><span class="line">-XX:ParallelGCThreads：设置用于垃圾回收的线程数</span><br><span class="line">-XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS+串行收集器</span><br><span class="line">-XX:ParallelCMSThreads：设定CMS的线程数量</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction：设置CMS收集器在老年代空间被使用多少后触发</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection：设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction：设定进行多少次CMS垃圾回收后，进行一次内存压缩</span><br><span class="line">-XX:+CMSClassUnloadingEnabled：允许对类元数据进行回收</span><br><span class="line">-XX:CMSInitiatingPermOccupancyFraction：当永久区占用率达到这一百分比时，启动CMS回收</span><br><span class="line">-XX:UseCMSInitiatingOccupancyOnly：表示只在到达阀值的时候，才进行CMS回收</span><br></pre></td></tr></table></figure><h1 id="Tomcat实例演示"><a href="#Tomcat实例演示" class="headerlink" title="Tomcat实例演示"></a>Tomcat实例演示</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Tomcat 7<br>JSP 网站<br>测试网站吞吐量和延时</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>JMeter</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>让Tomcat有一个不错的吞吐量</p><h2 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h2><p><img alt="" data-original="../images/15511510781198.png"></p><p>通过局域网连接，将JMeter和Tomcat放在两个电脑上，防止Jmeter对Tomcat的运行产生影响</p><h2 id="Jmeter"><a href="#Jmeter" class="headerlink" title="Jmeter"></a>Jmeter</h2><p>性能测试工具<br>建立10个线程，每个线程请求Tomcat 1000次 共10000次请求<br><img alt="" data-original="../images/15511510864168.png"></p><p>设置ip、端口、请求地址。</p><h2 id="JDK6：使用32M堆处理请求"><a href="#JDK6：使用32M堆处理请求" class="headerlink" title="JDK6：使用32M堆处理请求"></a>JDK6：使用32M堆处理请求</h2><p>参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set CATALINA_OPTS=-server -Xloggc:gc.log -XX:+PrintGCDetails -Xmx32M -Xms32M </span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:+UseSerialGC -XX:PermSize=<span class="number">32</span>M</span><br></pre></td></tr></table></figure><p>Average：在一万次请求中平均的返回速度是6毫秒，<br>Median：一半的请求都能在4毫秒内返回<br>90%line：90%请求在7毫秒返回，<br>min：最小延时2毫秒<br>max：最大演示135毫秒<br>Throughput：540每秒（）吞吐量<br><img alt="" data-original="../images/15511510986927.png"></p><p>上述截图显示的是，系统运行到后期大量的请求，占据了一些内存，从而会导致系统产生大量的full gc，在32-33秒之间就产生了四次full gc。</p><h2 id="JDK6：使用最大堆512M堆处理请求，未设置Xms"><a href="#JDK6：使用最大堆512M堆处理请求，未设置Xms" class="headerlink" title="JDK6：使用最大堆512M堆处理请求，未设置Xms"></a>JDK6：使用最大堆512M堆处理请求，未设置Xms</h2><p>为了有更好的性能，最简单的方法就是直接增大堆的数量。<br>参数：<br>set CATALINA_OPTS=-Xmx512m -XX:MaxPermSize=32M -Xloggc:gc.log -XX:+PrintGCDetails</p><p>结果：FULL GC很少，基本上是Minor GC<br><img alt="" data-original="../images/15511511093088.png"></p><p>吞吐量变成了651，因为没有设置最小初始化堆的大小，所以最小初始化堆就变成了可以扩展的空间，在系统运行时，系统只有16m的内存，但是系统运行到后面，内存在不停的往上涨，到达了60m，整个过程中没有full gc的产生，因为没有full gc的产生，所以吞吐量有一个很好的效果。</p><h2 id="JDK6：使用最大堆512M堆处理请求，设置Xms为64m"><a href="#JDK6：使用最大堆512M堆处理请求，设置Xms为64m" class="headerlink" title="JDK6：使用最大堆512M堆处理请求，设置Xms为64m"></a>JDK6：使用最大堆512M堆处理请求，设置Xms为64m</h2><p>上面看到最后会扩展到60m，这里直接将Xms设置为64m。<br>参数：<br>set CATALINA_OPTS=-Xmx512m -Xms64m -XX:MaxPermSize=32M -Xloggc:gc.log -XX:+PrintGCDetails</p><p>结果 GC数量减少 大部分是Minor GC<br><img alt="" data-original="../images/15511511253053.png"></p><p>因为堆越大gc越少，如果堆很小的话，系统希望将工作维持在一个很小的堆上做，必然会不断的进行gc。</p><h2 id="JDK6：使用最大堆512M堆处理请求，改为并行收集器"><a href="#JDK6：使用最大堆512M堆处理请求，改为并行收集器" class="headerlink" title="JDK6：使用最大堆512M堆处理请求，改为并行收集器"></a>JDK6：使用最大堆512M堆处理请求，改为并行收集器</h2><p>参数：<br>set CATALINA_OPTS=-Xmx512m -Xms64m -XX:MaxPermSize=32M -Xloggc:gc.log -XX:+PrintGCDetails -XX:+UseParallelGC -XX:+UseParallelOldGC -XX:ParallelGCThreads=4</p><p>将新生代和年老代换成并行回收的方式，因为堆很大，所以GC压力原本就不大。<br>结果：GC压力原本不大，修改GC方式影响很小<br><img alt="" data-original="../images/15511511485451.png"></p><h2 id="JDK-6，减小堆，串行收集器"><a href="#JDK-6，减小堆，串行收集器" class="headerlink" title="JDK 6，减小堆，串行收集器"></a>JDK 6，减小堆，串行收集器</h2><p>set CATALINA_OPTS=-Xmx40m -Xms40m -XX:MaxPermSize=32M -Xloggc:gc.log -XX:+PrintGCDetails</p><p>减小堆大小，增加GC压力，使用Serial回收器，Serial回收器是默认的回收器。<br><img alt="" data-original="../images/15511511611935.png"></p><h2 id="JDK-6，减小堆，并行收集器"><a href="#JDK-6，减小堆，并行收集器" class="headerlink" title="JDK 6，减小堆，并行收集器"></a>JDK 6，减小堆，并行收集器</h2><p>set CATALINA_OPTS=-Xmx40m -Xms40m -XX:MaxPermSize=32M -Xloggc:gc.log -XX:+PrintGCDetails -XX:+UseParallelOldGC -XX:ParallelGCThreads=4</p><p>减小堆大小，增加GC压力，使用并行回收器<img alt="" data-original="../images/15511513163999.png"></p><h2 id="JDK-6，减小堆，ParNew收集器"><a href="#JDK-6，减小堆，ParNew收集器" class="headerlink" title="JDK 6，减小堆，ParNew收集器"></a>JDK 6，减小堆，ParNew收集器</h2><p>set CATALINA_OPTS=-Xmx40m -Xms40m -XX:MaxPermSize=32M -Xloggc:gc.log -XX:+PrintGCDetails -XX:+UseParNewGC</p><p>减小堆大小，增加GC压力，使用ParNew回收器<br><img alt="" data-original="../images/15511513310090.png"></p><p>ParNew只是影响新生代，对老年代影响不大，而这里的压力主要是老年代，所以影响不大。</p><h2 id="启动Tomcat-7"><a href="#启动Tomcat-7" class="headerlink" title="启动Tomcat 7"></a>启动Tomcat 7</h2><p>使用JDK6<br>不加任何参数启动测试<br><img alt="" data-original="../images/15511513402372.png"></p><h2 id="启动Tomcat-7-1"><a href="#启动Tomcat-7-1" class="headerlink" title="启动Tomcat 7"></a>启动Tomcat 7</h2><p>使用JDK7<br>不加任何参数启动测试<br><img alt="" data-original="../images/15511513516173.png"></p><p>可以看到JDK7性能更加好一点。<br><strong><font color="red">升级JDK可能会带来额外的性能提升！<br>不要忽视JDK的版本哦</font></strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>细节决定成败</p><ul><li>性能的根本在应用</li><li>GC参数属于微调</li><li>设置不合理，会影响性能，产生大的延时</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;堆的回顾&quot;&gt;&lt;a href=&quot;#堆的回顾&quot; class=&quot;headerlink&quot; title=&quot;堆的回顾&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM内核-原理、诊断与优化学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM%E5%86%85%E6%A0%B8-%E5%8E%9F%E7%90%86%E3%80%81%E8%AF%8A%E6%96%AD%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="http://mmmmmm.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内核-原理、诊断与优化学习笔记（四）：GC算法与种类</title>
    <link href="http://mmmmmm.me/2019-02-24-2.html"/>
    <id>http://mmmmmm.me/2019-02-24-2.html</id>
    <published>2019-02-24T14:21:02.000Z</published>
    <updated>2019-03-12T12:14:09.303Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="GC的概念"><a href="#GC的概念" class="headerlink" title="GC的概念"></a>GC的概念</h1><ul><li>Garbage Collection 垃圾收集</li><li>1960年 List 使用了GC</li><li>Java中，GC的对象是堆空间和永久区<h1 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2>老牌垃圾回收算法<br>通过引用计算来回收垃圾<br>使用者</li><li>COM</li><li>ActionScript3</li><li>Python</li></ul><p>引用计数器的实现很简单，对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用。<br><img alt="" data-original="../images/15510032407244.png"></p><h3 id="引用计数法的问题"><a href="#引用计数法的问题" class="headerlink" title="引用计数法的问题"></a>引用计数法的问题</h3><p>引用和去引用伴随加法和减法，因为引用的计算是实时的，影响性能。<br>很难处理循环引用<br><img alt="" data-original="../images/15510032512665.png"></p><p>根对象的引用去掉之后，对于根对象来说，剩下的三个的引用都不为0，所以不会回收，所以引用计数的一个很大的问题就是 <strong><font color="red">垃圾对象的循环引用 ，导致无法被回收</font></strong>。</p><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。<br><img alt="" data-original="../images/15510032642250.png"></p><p><strong><font color="red">上图左边是标记阶段，右边是清除阶段。</font></strong><br>空白区域表示空闲空间，深灰色表示垃圾对象，浅灰色表示存或对象。<br>从根节点，箭头表示引用，所有的浅灰色的是从根节点的可达对象，这些对象是不应该被回收的，而所有的从根节点不可达的对象，即深灰色的对象为垃圾对象。</p><h2 id="标记压缩"><a href="#标记压缩" class="headerlink" title="标记压缩"></a>标记压缩</h2><p>标记-压缩算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后， <strong><font color="red">清理边界外所有的空间 </font></strong>。<br><img alt="" data-original="../images/15510032764407.png"></p><p>已经标记好了对象，箭头表示移动存活对象，而不是去简单的清除未被标记的对象，移动完了之后把区域外的对象（上图指的是除了第一行）全部清理。</p><h3 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h3><p>标记压缩对标记清除而言，有什么优势呢？</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><ul><li>与标记-清除算法相比，复制算法是一种相对高效的回收方法</li><li>不适用于存活对象较多的场合 如老年代</li><li>将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收</li></ul><p><img alt="" data-original="../images/15510032881638.png"></p><p>每次把存活的对象被复制到另一块区域中，复制完之后第一块区域中所有的对象都做一次清理，然后交换角色。</p><h3 id="复制算法的最大问题是：空间浪费-整合标记清理思想"><a href="#复制算法的最大问题是：空间浪费-整合标记清理思想" class="headerlink" title="复制算法的最大问题是：空间浪费 整合标记清理思想"></a>复制算法的最大问题是：空间浪费 整合标记清理思想</h3><p>因为复制算法，每次都有一半是没有被用的。<br><img alt="" data-original="../images/15510033006005.png"></p><p>主要的对象，对象的产生放在左边最大的区域中，下面的两小块是复制算法的核心。<br>当垃圾回收进行的时候，大对象直接进入担保空间（年老代），为什么大对象放到年老代中？因为复制区域很小，可能大对象直接就放不进去，也可能大对象放到负值区域，导致原本应该放到负值区域的小对象被挤到了年老代中。<br>然后老年对象进入老年代，什么叫做老年对象，对象在几次回收之后都没有被回收掉，每次回收后对象的年龄就会加一，当对象到达一定的年龄对象之后，就会变成老年对象，即长期被引用的对象，所以老年对象被放在老年代。<br>剩下小的、年轻的对象做复制右边的小的区域中去。<br>根据复制算法，清空原先使用的空间，就形成了右边的结果。</p><h3 id="XX-PrintGCDetails的输出"><a href="#XX-PrintGCDetails的输出" class="headerlink" title="-XX:+PrintGCDetails的输出"></a>-XX:+PrintGCDetails的输出</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"><span class="comment">//（0x28d80000-0x27e80000)/1024/1024=15m，即新生代有15m的大小。</span></span><br><span class="line"><span class="comment">//可是这里total为什么是13824K？</span></span><br><span class="line"><span class="comment">//实质上是12288K+ 1536K=13824</span></span><br><span class="line"><span class="comment">//即浪费了from to其中的一个空间，即复制算法所需要浪费的空间。</span></span><br><span class="line"> def <span class="keyword">new</span> generation   total <span class="number">13824</span>K, used <span class="number">11223</span>K [<span class="number">0x27e80000</span>, <span class="number">0x28d80000</span>, <span class="number">0x28d80000</span>)</span><br><span class="line">  eden space <span class="number">12288</span>K,  <span class="number">91</span>% used [<span class="number">0x27e80000</span>, <span class="number">0x28975f20</span>, <span class="number">0x28a80000</span>)</span><br><span class="line">  <span class="keyword">from</span> space <span class="number">1536</span>K,   <span class="number">0</span>% used [<span class="number">0x28a80000</span>, <span class="number">0x28a80000</span>, <span class="number">0x28c00000</span>)</span><br><span class="line">  to   space <span class="number">1536</span>K,   <span class="number">0</span>% used [<span class="number">0x28c00000</span>, <span class="number">0x28c00000</span>, <span class="number">0x28d80000</span>)</span><br><span class="line"> tenured generation   total <span class="number">5120</span>K, used <span class="number">0</span>K [<span class="number">0x28d80000</span>, <span class="number">0x29280000</span>, <span class="number">0x34680000</span>)</span><br><span class="line">   the space <span class="number">5120</span>K,   <span class="number">0</span>% used [<span class="number">0x28d80000</span>, <span class="number">0x28d80000</span>, <span class="number">0x28d80200</span>, <span class="number">0x29280000</span>)</span><br><span class="line"> compacting perm gen  total <span class="number">12288</span>K, used <span class="number">142</span>K [<span class="number">0x34680000</span>, <span class="number">0x35280000</span>, <span class="number">0x38680000</span>)</span><br><span class="line">   the space <span class="number">12288</span>K,   <span class="number">1</span>% used [<span class="number">0x34680000</span>, <span class="number">0x346a3a90</span>, <span class="number">0x346a3c00</span>, <span class="number">0x35280000</span>)</span><br><span class="line">    ro space <span class="number">10240</span>K,  <span class="number">44</span>% used [<span class="number">0x38680000</span>, <span class="number">0x38af73f0</span>, <span class="number">0x38af7400</span>, <span class="number">0x39080000</span>)</span><br><span class="line">    rw space <span class="number">12288</span>K,  <span class="number">52</span>% used [<span class="number">0x39080000</span>, <span class="number">0x396cdd28</span>, <span class="number">0x396cde00</span>, <span class="number">0x39c80000</span>)</span><br></pre></td></tr></table></figure><h2 id="gc思想以及总结"><a href="#gc思想以及总结" class="headerlink" title="gc思想以及总结"></a>gc思想以及总结</h2><h3 id="分代思想"><a href="#分代思想" class="headerlink" title="分代思想"></a>分代思想</h3><h4 id="依据对象的存活周期进行分类，短命对象归为新生代，长命对象归为老年代。"><a href="#依据对象的存活周期进行分类，短命对象归为新生代，长命对象归为老年代。" class="headerlink" title="依据对象的存活周期进行分类，短命对象归为新生代，长命对象归为老年代。"></a>依据对象的存活周期进行分类，短命对象归为新生代，长命对象归为老年代。</h4><h4 id="根据不同代的特点，选取合适的收集算法"><a href="#根据不同代的特点，选取合适的收集算法" class="headerlink" title="根据不同代的特点，选取合适的收集算法"></a>根据不同代的特点，选取合适的收集算法</h4><p>少量对象存活，适合复制算法（年轻代）<br>大量对象存活，适合标记清理或者标记压缩（年老代）<br>因为年老代的对象除了是比较大的对象之外，就是在年轻代多次存活的对象，数量比较大，如果是数量比较多的话，复制算法，需要复制的操作比较多，比较消耗性能。</p><h3 id="GC算法总结整理"><a href="#GC算法总结整理" class="headerlink" title="GC算法总结整理"></a>GC算法总结整理</h3><p>引用计数（没有被Java采用）<br>标记-清除、标记-压缩（被年老代采用）<br>复制算法（被新生代采用）</p><h1 id="可触及性"><a href="#可触及性" class="headerlink" title="可触及性"></a>可触及性</h1><p>所有的算法，需要能够识别一个垃圾对象，因此需要给出一个可触及性的定义</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="可触及的"><a href="#可触及的" class="headerlink" title="可触及的"></a>可触及的</h3><p>从根节点可以触及到这个对象，从根节点开始的引用链条中有这个对象就是可触及的。</p><h3 id="可复活的"><a href="#可复活的" class="headerlink" title="可复活的"></a>可复活的</h3><p>一旦所有引用被释放，就是可复活状态<br>因为在finalize()中可能复活该对象<br>就是在finalize（）执行过程中的时候，还没有变成不可触及的时候就是可复活的，可能会再次被触及的，可复活的对象是不能被回收的。</p><h3 id="不可触及的"><a href="#不可触及的" class="headerlink" title="不可触及的"></a>不可触及的</h3><p>在finalize()执行完之后，可能会进入不可触及状态<br>不可触及的对象不可能复活<br>可以回收</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CanReliveObj</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> CanReliveObj obj;</span><br><span class="line">@Override</span><br><span class="line">protected <span class="keyword">void</span> finalize() throws Throwable &#123;</span><br><span class="line">    <span class="keyword">super</span>.finalize();</span><br><span class="line">    System.out.println(<span class="string">"CanReliveObj finalize called"</span>);</span><br><span class="line">    obj=<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public <span class="built_in">String</span> toString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"I am CanReliveObj"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws</span><br><span class="line">     InterruptedException&#123;</span><br><span class="line">obj=<span class="keyword">new</span> CanReliveObj();</span><br><span class="line">obj=<span class="literal">null</span>;   <span class="comment">//可复活</span></span><br><span class="line">System.gc();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">if</span>(obj==<span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"obj 是 null"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"obj 可用"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"第二次gc"</span>);</span><br><span class="line">obj=<span class="literal">null</span>;    <span class="comment">//不可复活</span></span><br><span class="line">System.gc();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">if</span>(obj==<span class="literal">null</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"obj 是 null"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"obj 可用"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CanReliveObj finalize called</span><br><span class="line">obj 可用</span><br><span class="line">第二次gc</span><br><span class="line">obj 是 <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>解释：<br>注意第一段代码中的obj=this;<br>第二段代码中第一次obj=null的时候，是可复活的状态，System.gc();调用了第一段代码的finalize方法，执行obj=this，所以obj可用，但是注意 <strong><font color="red">finalize方法只能被执行一次</font></strong>，所以第二次obj=null，System.gc();的时候不能调用第一段代码中的finalize方法，所以第二次gc的时候输出obj 是 null。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>通过上面的代码，如果第一次执行了finalize放啊，第二次没有执行obj=null，那是不是以为这obj这个对象，永远无法回收？</p><ul><li>经验：避免使用finalize()，操作不慎可能导致错误。</li><li>优先级低，何时被调用， 不确定<br>何时发生GC不确定，所以不建议在finalize里面写代码，被调用的不确定性太大。</li><li>可以使用try-catch-finally来替代它</li></ul><h2 id="根"><a href="#根" class="headerlink" title="根"></a>根</h2><p>根，上面许多地方所说的根，究竟是什么？</p><ul><li>栈中引用的对象</li><li>方法区中静态成员或者常量引用的对象（全局对象）</li><li>JNI方法栈中引用对象<h1 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop-The-World"></a>Stop-The-World</h1></li><li>Java中一种全局暂停的现象</li><li>全局停顿，所有Java代码停止，native代码可以执行，但不能和JVM交互，也就是不能做所有应用层面的事情，只能做gc。</li><li>多半由于GC引起<br>Dump线程<br>死锁检查<br>堆Dump<br>因为Dump线程、死锁检查、堆Dump概率较低，而且多是由于程序员引起，而gc则是由程序自动触发的，所以由gc引起的全局暂停应该引起重视。</li><li>GC时为什么会有全局停顿？<br>类比在聚会时打扫房间，聚会时很乱，又有新的垃圾产生，房间永远打扫不干净，只有让大家停止活动了，才能将房间打扫干净。<br>所以gc会出现停顿，新生代停顿的短一点可能是0.000x秒，可是老年代停顿的可能就是几百秒，几十分钟。</li><li>危害<br>长时间服务停止，没有响应<br>遇到HA系统，可能引起主备切换，严重危害生产环境。<br>线上系统，主机gc时间较长的时候，备机启动，可是稍后gc完成了主机再次重新启动，主机和备机都启动的状态是十分危险的。</li></ul><h2 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>每秒打印10条<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">public <span class="keyword">static</span> final long starttime=System.currentTimeMillis();</span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run()&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">long t=System.currentTimeMillis()-starttime;</span><br><span class="line">System.out.println(<span class="string">"time:"</span>+t);</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">HashMap&lt;Long,byte[]&gt; map=<span class="keyword">new</span> HashMap&lt;Long,byte[]&gt;();</span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run()&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//大于450M时，清理内存</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(map.size()*<span class="number">512</span>/<span class="number">1024</span>/<span class="number">1024</span>&gt;=<span class="number">450</span>)&#123;</span><br><span class="line">System.out.println(“=====准备清理=====:<span class="string">"+map.size());</span></span><br><span class="line"><span class="string">map.clear();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//工作线程，消耗内存</span></span><br><span class="line"><span class="string">for(int i=0;i&lt;1024;i++)&#123;</span></span><br><span class="line"><span class="string">map.put(System.nanoTime(), new byte[512]);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">Thread.sleep(1);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;catch(Exception e)&#123;</span></span><br><span class="line"><span class="string">e.printStackTrace();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>运行<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xmx512M -Xms512M -XX:+UseSerialGC -Xloggc:gc.log -XX:+PrintGCDetails</span><br><span class="line">-Xmn1m -XX:PretenureSizeThreshold=<span class="number">50</span> -XX:MaxTenuringThreshold=<span class="number">1</span></span><br></pre></td></tr></table></figure><p></p><p>结果：<br>预期，应该是每秒中有10条输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">time:<span class="number">2018</span></span><br><span class="line">time:<span class="number">2121</span></span><br><span class="line">time:<span class="number">2221</span></span><br><span class="line">time:<span class="number">2325</span></span><br><span class="line">time:<span class="number">2425</span></span><br><span class="line">time:<span class="number">2527</span></span><br><span class="line">time:<span class="number">2631</span></span><br><span class="line">time:<span class="number">2731</span></span><br><span class="line">time:<span class="number">2834</span></span><br><span class="line">time:<span class="number">2935</span></span><br><span class="line">time:<span class="number">3035</span></span><br><span class="line">time:<span class="number">3153</span></span><br><span class="line">time:<span class="number">3504</span></span><br><span class="line">time:<span class="number">4218</span></span><br><span class="line">======before clean map=======:<span class="number">921765</span></span><br><span class="line">time:<span class="number">4349</span></span><br><span class="line">time:<span class="number">4450</span></span><br><span class="line">time:<span class="number">4551</span></span><br></pre></td></tr></table></figure><p>注意</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time:<span class="number">3153</span></span><br><span class="line">time:<span class="number">3504</span></span><br><span class="line">time:<span class="number">4218</span></span><br></pre></td></tr></table></figure><p>这里并不是中间间隔一秒</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.292</span>: [GC3<span class="number">.292</span>: [DefNew: <span class="number">959</span>K-&gt;<span class="number">63</span>K(<span class="number">960</span>K), <span class="number">0.0024260</span> secs] <span class="number">523578</span>K-&gt;<span class="number">523298</span>K(<span class="number">524224</span>K), <span class="number">0.0024879</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="number">3.296</span>: [GC3<span class="number">.296</span>: [DefNew: <span class="number">959</span>K-&gt;<span class="number">959</span>K(<span class="number">960</span>K), <span class="number">0.0000123</span> secs]<span class="number">3.296</span>: [Tenured: <span class="number">523235</span>K-&gt;<span class="number">523263</span>K(<span class="number">523264</span>K), <span class="number">0.2820915</span> secs] <span class="number">524195</span>K-&gt;<span class="number">523870</span>K(<span class="number">524224</span>K), [Perm : <span class="number">147</span>K-&gt;<span class="number">147</span>K(<span class="number">12288</span>K)], <span class="number">0.2821730</span> secs] [Times: user=<span class="number">0.26</span> sys=<span class="number">0.00</span>, real=<span class="number">0.28</span> secs] </span><br><span class="line"><span class="number">3.579</span>: [Full GC3<span class="number">.579</span>: [Tenured: <span class="number">523263</span>K-&gt;<span class="number">523263</span>K(<span class="number">523264</span>K), <span class="number">0.2846036</span> secs] <span class="number">524159</span>K-&gt;<span class="number">524042</span>K(<span class="number">524224</span>K), [Perm : <span class="number">147</span>K-&gt;<span class="number">147</span>K(<span class="number">12288</span>K)], <span class="number">0.2846745</span> secs] [Times: user=<span class="number">0.28</span> sys=<span class="number">0.00</span>, real=<span class="number">0.28</span> secs] </span><br><span class="line"><span class="number">3.863</span>: [Full GC3<span class="number">.863</span>: [Tenured: <span class="number">523263</span>K-&gt;<span class="number">515818</span>K(<span class="number">523264</span>K), <span class="number">0.4282780</span> secs] <span class="number">524042</span>K-&gt;<span class="number">515818</span>K(<span class="number">524224</span>K), [Perm : <span class="number">147</span>K-&gt;<span class="number">147</span>K(<span class="number">12288</span>K)], <span class="number">0.4283353</span> secs] [Times: user=<span class="number">0.42</span> sys=<span class="number">0.00</span>, real=<span class="number">0.43</span> secs] </span><br><span class="line"><span class="number">4.293</span>: [GC4<span class="number">.293</span>: [DefNew: <span class="number">896</span>K-&gt;<span class="number">64</span>K(<span class="number">960</span>K), <span class="number">0.0017584</span> secs] <span class="number">516716</span>K-&gt;<span class="number">516554</span>K(<span class="number">524224</span>K), <span class="number">0.0018346</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">……省略若干…..</span><br><span class="line"><span class="number">4.345</span>: [GC4<span class="number">.345</span>: [DefNew: <span class="number">960</span>K-&gt;<span class="number">960</span>K(<span class="number">960</span>K), <span class="number">0.0000156</span> secs]<span class="number">4.345</span>: [Tenured: <span class="number">522929</span>K-&gt;<span class="number">12436</span>K(<span class="number">523264</span>K), <span class="number">0.0781624</span> secs] <span class="number">523889</span>K-&gt;<span class="number">12436</span>K(<span class="number">524224</span>K), [Perm : <span class="number">147</span>K-&gt;<span class="number">147</span>K(<span class="number">12288</span>K)], <span class="number">0.0782611</span> secs] [Times: user=<span class="number">0.08</span> sys=<span class="number">0.00</span>, real=<span class="number">0.08</span> secs]</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.296</span>: Times: user=<span class="number">0.26</span> sys=<span class="number">0.00</span>, real=<span class="number">0.28</span> secs</span><br><span class="line"><span class="number">3.579</span>：Times: user=<span class="number">0.28</span> sys=<span class="number">0.00</span>, real=<span class="number">0.28</span> secs</span><br><span class="line"><span class="number">3.863</span>：Times: user=<span class="number">0.42</span> sys=<span class="number">0.00</span>, real=<span class="number">0.43</span> secs</span><br></pre></td></tr></table></figure><p>综上：因为系统的gc停顿导致了本应该每秒输出的时间有了误差。<br>因为一个是系统线程（gc），一个是应用级别的线程所以时间的显示可能有些误差。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;GC的概念&quot;&gt;&lt;a href=&quot;#GC的概念&quot; class=&quot;headerlink&quot; title=&quot;GC的概念&quot;&gt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM内核-原理、诊断与优化学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM%E5%86%85%E6%A0%B8-%E5%8E%9F%E7%90%86%E3%80%81%E8%AF%8A%E6%96%AD%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="http://mmmmmm.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内核-原理、诊断与优化学习笔记（三）：常用JVM配置参数</title>
    <link href="http://mmmmmm.me/2019-02-24-1.html"/>
    <id>http://mmmmmm.me/2019-02-24-1.html</id>
    <published>2019-02-24T14:20:02.000Z</published>
    <updated>2019-03-12T12:11:57.400Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="Trace跟踪参数"><a href="#Trace跟踪参数" class="headerlink" title="Trace跟踪参数"></a>Trace跟踪参数</h1><h2 id="verbose-gc-打开gc的跟踪情况"><a href="#verbose-gc-打开gc的跟踪情况" class="headerlink" title="-verbose:gc (打开gc的跟踪情况)"></a>-verbose:gc (打开gc的跟踪情况)</h2><h2 id="XX-printGC（打开gc的log开关，如果在运行的过程中出现了gc，就会打印出相关的信息。）"><a href="#XX-printGC（打开gc的log开关，如果在运行的过程中出现了gc，就会打印出相关的信息。）" class="headerlink" title="-XX:+printGC（打开gc的log开关，如果在运行的过程中出现了gc，就会打印出相关的信息。）"></a>-XX:+printGC（打开gc的log开关，如果在运行的过程中出现了gc，就会打印出相关的信息。）</h2><ul><li>可以打印GC的简要信息<br>[GC 4790K-&gt;374K(15872K), 0.0001606 secs]<br>[GC 4790K-&gt;374K(15872K), 0.0001474 secs]<br>[GC 4790K-&gt;374K(15872K), 0.0001563 secs]<br>[GC 4790K-&gt;374K(15872K), 0.0001682 secs]<br>上面这行的解释：堆在gc之前用了4m，在gc之后用了374k，回收了将近4m的大小，整个堆的大小15872K<h2 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a>-XX:+PrintGCDetails</h2>打印GC详细信息<h2 id="XX-PrintGCTimeStamps"><a href="#XX-PrintGCTimeStamps" class="headerlink" title="XX:+PrintGCTimeStamps"></a>XX:+PrintGCTimeStamps</h2>打印CG发生的时间戳</li><li>例<br>这是一个PrintGCDetails的log<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC[DefNew: <span class="number">4416</span>K-&gt;<span class="number">0</span>K(<span class="number">4928</span>K), <span class="number">0.0001897</span> secs] <span class="number">4790</span>K-&gt;<span class="number">374</span>K(<span class="number">15872</span>K), <span class="number">0.0002232</span> secs] </span><br><span class="line">[Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure></li></ul><p>DefNew: 4416K-&gt;0K(4928K), 0.0001897 secs表示这是一个新生代的gc</p><ul><li>-XX:+PrintGCDetails的输出，在程序运行结束后的一段描述<br>PrintGCDetails会把程序运行结束后，整个程序的堆的情况打印出来</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"><span class="comment">//新生代总的空间13824K，用了11223K</span></span><br><span class="line"><span class="comment">//0x27e80000低边界，起始位置，0x28d80000，当前所分配的，所申请到的位置，</span></span><br><span class="line"><span class="comment">//0x28d80000最高边界，最多能申请到的位置。从现在来看新生代已经全部申请完了，已经不能再做扩展了。</span></span><br><span class="line"><span class="comment">//（0x28d80000-0x27e80000)/1024/1024=15M说明新生代正好15m</span></span><br><span class="line"><span class="comment">//也就正好是eden+from+to，但是和13824K是不相等的，也就是分配了15m，但是只有</span></span><br><span class="line"><span class="comment">//13824K可用，为什么？后面学习gc的算法。</span></span><br><span class="line">def <span class="keyword">new</span> generation   total <span class="number">13824</span>K, used <span class="number">11223</span>K [<span class="number">0x27e80000</span>, <span class="number">0x28d80000</span>, <span class="number">0x28d80000</span>)</span><br><span class="line"><span class="comment">//yiden（伊甸园）对象出生的地方，总共12288K，91%被使用了</span></span><br><span class="line">eden space <span class="number">12288</span>K,  <span class="number">91</span>% used [<span class="number">0x27e80000</span>, <span class="number">0x28975f20</span>, <span class="number">0x28a80000</span>)</span><br><span class="line"><span class="comment">//from和to的大小是必须相等的</span></span><br><span class="line"><span class="keyword">from</span> space <span class="number">1536</span>K,   <span class="number">0</span>% used [<span class="number">0x28a80000</span>, <span class="number">0x28a80000</span>, <span class="number">0x28c00000</span>)</span><br><span class="line">to   space <span class="number">1536</span>K,   <span class="number">0</span>% used [<span class="number">0x28c00000</span>, <span class="number">0x28c00000</span>, <span class="number">0x28d80000</span>)</span><br><span class="line"><span class="comment">//老年代，总共5120K，已经使用0k</span></span><br><span class="line">tenured generation   total <span class="number">5120</span>K, used <span class="number">0</span>K [<span class="number">0x28d80000</span>, <span class="number">0x29280000</span>, <span class="number">0x34680000</span>)</span><br><span class="line">the space <span class="number">5120</span>K,   <span class="number">0</span>% used [<span class="number">0x28d80000</span>, <span class="number">0x28d80000</span>, <span class="number">0x28d80200</span>, <span class="number">0x29280000</span>)</span><br><span class="line"><span class="comment">//持久带，永久区，方法区。</span></span><br><span class="line">compacting perm gen  total <span class="number">12288</span>K, used <span class="number">142</span>K [<span class="number">0x34680000</span>, <span class="number">0x35280000</span>, <span class="number">0x38680000</span>)</span><br><span class="line"><span class="comment">//为什么use142k相对较小？</span></span><br><span class="line"><span class="comment">//因为在jdk5.0之后，在串行gc的模式之下，可以有一个永久区的共享，叫做类的共享</span></span><br><span class="line"><span class="comment">//打开类的共享之后一些基础的java的类会被加载到一个共享区间，供所有的jvm使用，</span></span><br><span class="line"><span class="comment">//ro和rw就是共享区间的大小，一个是只读的，一个是可读可写的，占得比重比较大了</span></span><br><span class="line">the space <span class="number">12288</span>K,   <span class="number">1</span>% used [<span class="number">0x34680000</span>, <span class="number">0x346a3a90</span>, <span class="number">0x346a3c00</span>, <span class="number">0x35280000</span>)</span><br><span class="line">ro space <span class="number">10240</span>K,  <span class="number">44</span>% used [<span class="number">0x38680000</span>, <span class="number">0x38af73f0</span>, <span class="number">0x38af7400</span>, <span class="number">0x39080000</span>)</span><br><span class="line">rw space <span class="number">12288</span>K,  <span class="number">52</span>% used [<span class="number">0x39080000</span>, <span class="number">0x396cdd28</span>, <span class="number">0x396cde00</span>, <span class="number">0x39c80000</span>)</span><br></pre></td></tr></table></figure><h2 id="Xloggc-log-gc-log"><a href="#Xloggc-log-gc-log" class="headerlink" title="-Xloggc:log/gc.log"></a>-Xloggc:log/gc.log</h2><p>指定GC log的位置，以文件输出<br>帮助开发人员分析问题<br>因为一般gc日志的输出都是在控制台的，不便于保留。</p><h2 id="XX-PrintHeapAtGC"><a href="#XX-PrintHeapAtGC" class="headerlink" title="-XX:+PrintHeapAtGC"></a>-XX:+PrintHeapAtGC</h2><p>每次一次GC后，都打印堆信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">//gc之前的信息</span></span><br><span class="line">Heap before GC invocations=<span class="number">0</span> (full <span class="number">0</span>):</span><br><span class="line"> def <span class="keyword">new</span> generation   total <span class="number">3072</span>K, used <span class="number">2752</span>K [<span class="number">0x33c80000</span>, <span class="number">0x33fd0000</span>, <span class="number">0x33fd0000</span>)</span><br><span class="line">  eden space <span class="number">2752</span>K, <span class="number">100</span>% used [<span class="number">0x33c80000</span>, <span class="number">0x33f30000</span>, <span class="number">0x33f30000</span>)</span><br><span class="line">  <span class="keyword">from</span> space <span class="number">320</span>K,   <span class="number">0</span>% used [<span class="number">0x33f30000</span>, <span class="number">0x33f30000</span>, <span class="number">0x33f80000</span>)</span><br><span class="line">  to   space <span class="number">320</span>K,   <span class="number">0</span>% used [<span class="number">0x33f80000</span>, <span class="number">0x33f80000</span>, <span class="number">0x33fd0000</span>)</span><br><span class="line"> tenured generation   total <span class="number">6848</span>K, used <span class="number">0</span>K [<span class="number">0x33fd0000</span>, <span class="number">0x34680000</span>, <span class="number">0x34680000</span>)</span><br><span class="line">   the space <span class="number">6848</span>K,   <span class="number">0</span>% used [<span class="number">0x33fd0000</span>, <span class="number">0x33fd0000</span>, <span class="number">0x33fd0200</span>, <span class="number">0x34680000</span>)</span><br><span class="line"> compacting perm gen  total <span class="number">12288</span>K, used <span class="number">143</span>K [<span class="number">0x34680000</span>, <span class="number">0x35280000</span>, <span class="number">0x38680000</span>)</span><br><span class="line">   the space <span class="number">12288</span>K,   <span class="number">1</span>% used [<span class="number">0x34680000</span>, <span class="number">0x346a3c58</span>, <span class="number">0x346a3e00</span>, <span class="number">0x35280000</span>)</span><br><span class="line">    ro space <span class="number">10240</span>K,  <span class="number">44</span>% used [<span class="number">0x38680000</span>, <span class="number">0x38af73f0</span>, <span class="number">0x38af7400</span>, <span class="number">0x39080000</span>)</span><br><span class="line">    rw space <span class="number">12288</span>K,  <span class="number">52</span>% used [<span class="number">0x39080000</span>, <span class="number">0x396cdd28</span>, <span class="number">0x396cde00</span>, <span class="number">0x39c80000</span>)</span><br><span class="line"><span class="comment">//这里正好是一次gc</span></span><br><span class="line">[GC[DefNew: <span class="number">2752</span>K-&gt;<span class="number">320</span>K(<span class="number">3072</span>K), <span class="number">0.0014296</span> secs] <span class="number">2752</span>K-&gt;<span class="number">377</span>K(<span class="number">9920</span>K), <span class="number">0.0014604</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="comment">//gc之后的信息</span></span><br><span class="line">Heap after GC invocations=<span class="number">1</span> (full <span class="number">0</span>):</span><br><span class="line"> def <span class="keyword">new</span> generation   total <span class="number">3072</span>K, used <span class="number">320</span>K [<span class="number">0x33c80000</span>, <span class="number">0x33fd0000</span>, <span class="number">0x33fd0000</span>)</span><br><span class="line">  eden space <span class="number">2752</span>K,   <span class="number">0</span>% used [<span class="number">0x33c80000</span>, <span class="number">0x33c80000</span>, <span class="number">0x33f30000</span>)</span><br><span class="line">  <span class="keyword">from</span> space <span class="number">320</span>K, <span class="number">100</span>% used [<span class="number">0x33f80000</span>, <span class="number">0x33fd0000</span>, <span class="number">0x33fd0000</span>)</span><br><span class="line">  to   space <span class="number">320</span>K,   <span class="number">0</span>% used [<span class="number">0x33f30000</span>, <span class="number">0x33f30000</span>, <span class="number">0x33f80000</span>)</span><br><span class="line"> tenured generation   total <span class="number">6848</span>K, used <span class="number">57</span>K [<span class="number">0x33fd0000</span>, <span class="number">0x34680000</span>, <span class="number">0x34680000</span>)</span><br><span class="line">   the space <span class="number">6848</span>K,   <span class="number">0</span>% used [<span class="number">0x33fd0000</span>, <span class="number">0x33fde458</span>, <span class="number">0x33fde600</span>, <span class="number">0x34680000</span>)</span><br><span class="line"> compacting perm gen  total <span class="number">12288</span>K, used <span class="number">143</span>K [<span class="number">0x34680000</span>, <span class="number">0x35280000</span>, <span class="number">0x38680000</span>)</span><br><span class="line">   the space <span class="number">12288</span>K,   <span class="number">1</span>% used [<span class="number">0x34680000</span>, <span class="number">0x346a3c58</span>, <span class="number">0x346a3e00</span>, <span class="number">0x35280000</span>)</span><br><span class="line">    ro space <span class="number">10240</span>K,  <span class="number">44</span>% used [<span class="number">0x38680000</span>, <span class="number">0x38af73f0</span>, <span class="number">0x38af7400</span>, <span class="number">0x39080000</span>)</span><br><span class="line">    rw space <span class="number">12288</span>K,  <span class="number">52</span>% used [<span class="number">0x39080000</span>, <span class="number">0x396cdd28</span>, <span class="number">0x396cde00</span>, <span class="number">0x39c80000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XX-TraceClassLoading"><a href="#XX-TraceClassLoading" class="headerlink" title="-XX:+TraceClassLoading"></a>-XX:+TraceClassLoading</h2><p>监控类的加载<br>[Loaded java.lang.Object from shared objects file]<br>[Loaded java.io.Serializable from shared objects file]<br>[Loaded java.lang.Comparable from shared objects file]<br>[Loaded java.lang.CharSequence from shared objects file]<br>[Loaded java.lang.String from shared objects file]<br>[Loaded java.lang.reflect.GenericDeclaration from shared objects file]<br>[Loaded java.lang.reflect.Type from shared objects file]</p><h2 id="XX-PrintClassHistogram"><a href="#XX-PrintClassHistogram" class="headerlink" title="-XX:+PrintClassHistogram"></a>-XX:+PrintClassHistogram</h2><p>打印类的直方图<br>在程序的运行过程中，按下Ctrl+Break后，打印类的信息：<br>所有的类的使用情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> num     #instances      #bytes    class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   <span class="number">1</span>:        <span class="number">890617</span>      <span class="number">470266000</span>  [B    <span class="comment">//byte数组</span></span><br><span class="line">   <span class="number">2</span>:        <span class="number">890643</span>       <span class="number">21375432</span>  java.util.HashMap$Node<span class="comment">//hashMap的节点数。</span></span><br><span class="line">   <span class="number">3</span>:        <span class="number">890608</span>       <span class="number">14249728</span>  java.lang.Long</span><br><span class="line">   <span class="number">4</span>:            <span class="number">13</span>        <span class="number">8389712</span>  [Ljava.util.HashMap$Node;</span><br><span class="line">   <span class="number">5</span>:          <span class="number">2062</span>         <span class="number">371680</span>  [C</span><br><span class="line">   <span class="number">6</span>:           <span class="number">463</span>          <span class="number">41904</span>  java.lang.Class</span><br></pre></td></tr></table></figure><p>分别显示：序号、实例数量、总大小（占用的空间）、类型</p><h1 id="堆的分配参数"><a href="#堆的分配参数" class="headerlink" title="堆的分配参数"></a>堆的分配参数</h1><h2 id="Xmx-–Xms"><a href="#Xmx-–Xms" class="headerlink" title="Xmx –Xms"></a>Xmx –Xms</h2><p>指定最大堆和最小堆(只要jvm一启动，这么多的空间就是被占用的。)</p><ul><li>-Xmx20m -Xms5m 运行代码：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="string">"Xmx="</span>);</span><br><span class="line">System.out.println(Runtime.getRuntime().maxMemory()/<span class="number">1024.0</span>/<span class="number">1024</span>+<span class="string">"M"</span>);</span><br><span class="line"><span class="comment">//最大空间</span></span><br><span class="line">System.out.print(<span class="string">"free mem="</span>);</span><br><span class="line">System.out.println(Runtime.getRuntime().freeMemory()/<span class="number">1024.0</span>/<span class="number">1024</span>+<span class="string">"M"</span>);</span><br><span class="line"><span class="comment">//空闲的空间</span></span><br><span class="line">System.out.print(<span class="string">"total mem="</span>);</span><br><span class="line">System.out.println(Runtime.getRuntime().totalMemory()/<span class="number">1024.0</span>/<span class="number">1024</span>+<span class="string">"M"</span>);</span><br><span class="line"><span class="comment">//总的空间、目前分配到的空间</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Xmx=<span class="number">19.375</span>M  （Xmx）</span><br><span class="line">free mem=<span class="number">4.342750549316406</span>M</span><br><span class="line">total mem=<span class="number">4.875</span>M （Xms）</span><br></pre></td></tr></table></figure><p>-Xmx20m -Xms5m 运行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">byte[] b=<span class="keyword">new</span> byte[<span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">System.out.println(<span class="string">"分配了1M空间给数组"</span>);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"Xmx="</span>);</span><br><span class="line">System.out.println(Runtime.getRuntime().maxMemory()/<span class="number">1024.0</span>/<span class="number">1024</span>+<span class="string">"M"</span>);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"free mem="</span>);</span><br><span class="line">System.out.println(Runtime.getRuntime().freeMemory()/<span class="number">1024.0</span>/<span class="number">1024</span>+<span class="string">"M"</span>);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"total mem="</span>);</span><br><span class="line">System.out.println(Runtime.getRuntime().totalMemory()/<span class="number">1024.0</span>/<span class="number">1024</span>+<span class="string">"M"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分配了<span class="number">1</span>M空间给数组</span><br><span class="line">Xmx=<span class="number">19.375</span>M</span><br><span class="line">free mem=<span class="number">3.4791183471679688</span>M</span><br><span class="line">total mem=<span class="number">4.875</span>M</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么total还是<span class="number">5</span>m，Java会尽可能维持在最小堆（Xms）。</span><br></pre></td></tr></table></figure><p>-Xmx20m -Xms5m 运行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">b=<span class="keyword">new</span> byte[<span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">System.out.println(<span class="string">"分配了4M空间给数组"</span>);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"Xmx="</span>);</span><br><span class="line">System.out.println(Runtime.getRuntime().maxMemory()/<span class="number">1024.0</span>/<span class="number">1024</span>+<span class="string">"M"</span>);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"free mem="</span>);</span><br><span class="line">System.out.println(Runtime.getRuntime().freeMemory()/<span class="number">1024.0</span>/<span class="number">1024</span>+<span class="string">"M"</span>);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"total mem="</span>);</span><br><span class="line">System.out.println(Runtime.getRuntime().totalMemory()/<span class="number">1024.0</span>/<span class="number">1024</span>+<span class="string">"M"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分配了<span class="number">4</span>M空间给数组</span><br><span class="line">Xmx=<span class="number">19.375</span>M</span><br><span class="line">free mem=<span class="number">3.5899810791015625</span>M</span><br><span class="line">total mem=<span class="number">9.00390625</span>M</span><br><span class="line">总内存变多了</span><br></pre></td></tr></table></figure><p>-Xmx20m -Xms5m 运行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"回收内存"</span>);</span><br><span class="line">System.out.print(<span class="string">"Xmx="</span>);</span><br><span class="line">System.out.println(Runtime.getRuntime().maxMemory()/<span class="number">1024.0</span>/<span class="number">1024</span>+<span class="string">"M"</span>);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"free mem="</span>);</span><br><span class="line">System.out.println(Runtime.getRuntime().freeMemory()/<span class="number">1024.0</span>/<span class="number">1024</span>+<span class="string">"M"</span>);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"total mem="</span>);</span><br><span class="line">System.out.println(Runtime.getRuntime().totalMemory()/<span class="number">1024.0</span>/<span class="number">1024</span>+<span class="string">"M"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">回收内存</span><br><span class="line">Xmx=<span class="number">19.375</span>M</span><br><span class="line">free mem=<span class="number">6.354591369628906</span>M</span><br><span class="line">total mem=<span class="number">10.75390625</span>M</span><br><span class="line">空闲内存变多了</span><br></pre></td></tr></table></figure><h2 id="小问题："><a href="#小问题：" class="headerlink" title="小问题："></a>小问题：</h2><p>-Xmx 和 –Xms 应该保持一个什么关系，可以让系统的性能尽可能的好呢？<br>如果你要做一个Java的桌面产品，需要绑定JRE，但是JRE又很大，你如何做一下JRE的瘦身呢？</p><h2 id="Xmn"><a href="#Xmn" class="headerlink" title="Xmn"></a>Xmn</h2><p>设置新生代大小（大小的绝对值，比如是5m就是5m）</p><h2 id="XX-NewRatio"><a href="#XX-NewRatio" class="headerlink" title="-XX:NewRatio"></a>-XX:NewRatio</h2><p>新生代（eden+2*s（eden+from+to））和老年代（不包含永久区）的比值<br>4 表示 新生代:老年代=1:4，即年轻代占堆的1/5<br>NewRatio和Xmn的区别是：一个是比值，一个是绝对值。</p><h2 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h2><p>设置两个Survivor区（幸存区，from+to）和eden的比<br>8表示 两个Survivor :eden=2:8，即一个Survivor占年轻代的1/10</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><h3 id="栗子一"><a href="#栗子一" class="headerlink" title="栗子一"></a>栗子一</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">   byte[] b=<span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">       b=<span class="keyword">new</span> byte[<span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red">注意：以上代码一共分配10m的空间</font></strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx20m -Xms20m -Xmn1m  -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p></p><p><img alt="" data-original="../images/15509788100159.png"></p><p>新生代（eden+from+to）一共1m，不能够分配10m，所以全部分配到了年老代，因为没有到达gc的条件。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">没有触发GC</span><br><span class="line">全部分配在老年代</span><br></pre></td></tr></table></figure><p></p><h3 id="栗子二"><a href="#栗子二" class="headerlink" title="栗子二"></a>栗子二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx20m -Xms20m -Xmn15m  -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img alt="" data-original="../images/15509788215168.png"></p><p>新生代调整到15m。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">没有触发GC</span><br><span class="line">全部分配在eden</span><br><span class="line">老年代没有使用</span><br></pre></td></tr></table></figure><p></p><h3 id="栗子三"><a href="#栗子三" class="headerlink" title="栗子三"></a>栗子三</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx20m -Xms20m –Xmn7m  -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img alt="" data-original="../images/15509788343265.png"></p><p>新生代调整到7m，from和to都是700k，还不足以放下1m的对象，所以有对象进入了老年代。<br>gc第一次回收了3m，第二次回收了4m，所以最后还剩下3m的空间，可以看到年轻代1m，年老代2m。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>进行了<span class="number">2</span>次新生代GC</span><br><span class="line"><span class="number">2.</span>s0 s1 太小需要老年代担保</span><br></pre></td></tr></table></figure><h3 id="栗子四"><a href="#栗子四" class="headerlink" title="栗子四"></a>栗子四</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx20m -Xms20m -Xmn7m   -XX:SurvivorRatio=<span class="number">2</span> -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img alt="" data-original="../images/15509788447776.png"></p><p>调整了幸存区的大小from和to每个1.7m，因为空间足够，所以进行了三次gc，在年轻代进行了三次gc，所以年老代并没有分配太多的空间。<br>年老代的459k是系统级别的（比如classloader、线程对象实例）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>进行了<span class="number">3</span>次新生代GC</span><br><span class="line"><span class="number">2.</span>s0 s1 增大</span><br></pre></td></tr></table></figure><h3 id="栗子五"><a href="#栗子五" class="headerlink" title="栗子五"></a>栗子五</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xmx20m -Xms20m -XX:NewRatio=<span class="number">1</span>   </span><br><span class="line">-XX:SurvivorRatio=<span class="number">2</span> -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img alt="" data-original="../images/15509788557675.png"></p><p>加大幸存区的比例，gc正常，基本上所有的数据在新生代做了处理，一共回收了7m的空间，剩下的3m还在新生代，没有老年代的gc发生。</p><h3 id="栗子六"><a href="#栗子六" class="headerlink" title="栗子六"></a>栗子六</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xmx20m -Xms20m -XX:NewRatio=<span class="number">1</span>   </span><br><span class="line">-XX:SurvivorRatio=<span class="number">3</span> -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img alt="" data-original="../images/15509788651915.png"></p><p>对新生代做一定的调整，gc越多，对系统的压力越大。幸存代大了之后容易形成空间浪费，eden变大，幸存区变小，gc次数变小，很多对象没有机会晋升到老年代，老年代所使用的空间就变成了0.</p><h2 id="XX-HeapDumpOnOutOfMemoryError"><a href="#XX-HeapDumpOnOutOfMemoryError" class="headerlink" title="-XX:+HeapDumpOnOutOfMemoryError"></a>-XX:+HeapDumpOnOutOfMemoryError</h2><p>OutOfMemory的时候做一个堆的转存，一般系统OutOfMemory之后会马上down掉，为了便于分析，在系统运行时，就让堆信息转存出来，在down掉之后能够得到有用的堆信息，推测当前系统down掉的时候发生了什么。<br>OOM时导出堆到文件</p><h2 id="XX-HeapDumpPath"><a href="#XX-HeapDumpPath" class="headerlink" title="-XX:+HeapDumpPath"></a>-XX:+HeapDumpPath</h2><p>导出OOM的路径</p><h2 id="Xmx20m-Xms5m-XX-HeapDumpOnOutOfMemoryError-XX-HeapDumpPath-d-a-dump"><a href="#Xmx20m-Xms5m-XX-HeapDumpOnOutOfMemoryError-XX-HeapDumpPath-d-a-dump" class="headerlink" title="-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.dump"></a>-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.dump</h2><p>Vector v=new Vector();<br>for(int i=0;i&lt;25;i++)<br>v.add(new byte[1<em>1024</em>1024]);<br><img alt="" data-original="../images/15509788859181.png"><br><img alt="" data-original="../images/15509788891192.png"></p><pre><code>上面就是dump出来的文件，可以看到已经分配了19个byte数组，每个数组1m，再次分配超过了-Xmx20m最大堆内存。 通过类似于上面的文件能够很好的考到问题出在了哪里。</code></pre><h1 id="XX-OnOutOfMemoryError"><a href="#XX-OnOutOfMemoryError" class="headerlink" title="-XX:OnOutOfMemoryError"></a>-XX:OnOutOfMemoryError</h1><p>在OOM时，执行一个脚本<br>“-XX:OnOutOfMemoryError=D:/tools/jdk1.7_40/bin/printstack.bat %p“<br>%p指的是当前这个java程序的一个pid，进程id。<br>printstack.bat中定义的内容是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:<span class="regexp">/tools/</span>jdk1<span class="number">.7</span>_40/bin/jstack -F %<span class="number">1</span> &gt; D:<span class="regexp">/a.txt</span></span><br><span class="line"><span class="regexp">将jstack的信息打印到D:/</span>a.txt下面。</span><br></pre></td></tr></table></figure><p>当程序OOM时，在D:/a.txt中将会生成线程的dump<br>可以在OOM时，发送邮件，甚至是重启程序</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据实际事情调整新生代和幸存代的大小<br>官方推荐新生代占堆的3/8<br>幸存代占新生代的1/10<br>在OOM时，记得Dump出堆，确保可以排查现场问题</p><h1 id="永久区分配参数"><a href="#永久区分配参数" class="headerlink" title="永久区分配参数"></a>永久区分配参数</h1><h2 id="XX-PermSize-XX-MaxPermSize"><a href="#XX-PermSize-XX-MaxPermSize" class="headerlink" title="-XX:PermSize  -XX:MaxPermSize"></a>-XX:PermSize -XX:MaxPermSize</h2><p>设置永久区的初始空间和最大空间<br>他们表示，一个系统可以容纳多少个类型</p><h2 id="使用CGLIB等库的时候，可能会产生大量的类，这些类，有可能撑爆永久区导致OOM"><a href="#使用CGLIB等库的时候，可能会产生大量的类，这些类，有可能撑爆永久区导致OOM" class="headerlink" title="使用CGLIB等库的时候，可能会产生大量的类，这些类，有可能撑爆永久区导致OOM"></a>使用CGLIB等库的时候，可能会产生大量的类，这些类，有可能撑爆永久区导致OOM</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">    CglibBean bean = <span class="keyword">new</span> CglibBean(<span class="string">"geym.jvm.ch3.perm.bean"</span>+i,<span class="keyword">new</span> HashMap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过CGlib不断产生新的类<br><img alt="" data-original="../images/15509789087280.png"></p><p>永久代不断触发full gc，full gc后永久代的空间没有办法回收，所以会导致OOM<br>而OOm的时候年轻代用了2%，年老代用了20%，持久待用了99%</p><h2 id="打开堆的Dump"><a href="#打开堆的Dump" class="headerlink" title="打开堆的Dump"></a>打开堆的Dump</h2><p>堆空间实际占用非常少<br>但是永久区溢出 一样抛出OOM<br><img alt="" data-original="../images/15509789183444.png"></p><p>如果堆空间没有用完也抛出了OOM，有可能是永久区导致的</p><h1 id="栈大小分配"><a href="#栈大小分配" class="headerlink" title="栈大小分配"></a>栈大小分配</h1><h2 id="Xss"><a href="#Xss" class="headerlink" title="-Xss"></a>-Xss</h2><p>通常只有几百K<br>决定了函数调用的深度（如果线程中有地柜，栈的空间又太小的话，会导致栈的溢出，）<br>每个线程都有独立的栈空间（栈的数量*每个栈的大小=系统中栈的大小，所以如果想多跑一些线程的话，就应该就应该把栈空间减小）<br>局部变量、参数 分配在栈上</p><h2 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TestStackDeep</span> </span>&#123;</span><br><span class="line">private <span class="keyword">static</span> int count=<span class="number">0</span>;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> recursion(long a,long b,long c)&#123;</span><br><span class="line">long e=<span class="number">1</span>,f=<span class="number">2</span>,g=<span class="number">3</span>,h=<span class="number">4</span>,i=<span class="number">5</span>,k=<span class="number">6</span>,q=<span class="number">7</span>,x=<span class="number">8</span>,y=<span class="number">9</span>,z=<span class="number">10</span>;</span><br><span class="line">count++;</span><br><span class="line">recursion(a,b,c);</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span> args[])&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">recursion(<span class="number">0</span>L,<span class="number">0</span>L,<span class="number">0</span>L);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">System.out.println(<span class="string">"deep of calling = "</span>+count);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">递归调用</span><br><span class="line">-Xss128K</span><br><span class="line">deep <span class="keyword">of</span> calling = <span class="number">701</span></span><br><span class="line">java.lang.StackOverflowError</span><br><span class="line"></span><br><span class="line">-Xss256K</span><br><span class="line">deep <span class="keyword">of</span> calling = <span class="number">1817</span> <span class="comment">//调用的次数</span></span><br><span class="line">java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><p>java.lang.StackOverflowError，就是函数的调用层次太深。<br>当然如果想要增加迭代的次数，通过减小栈中的局部变量表中的参数或者局部变量也能达到效果。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;Trace跟踪参数&quot;&gt;&lt;a href=&quot;#Trace跟踪参数&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM内核-原理、诊断与优化学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM%E5%86%85%E6%A0%B8-%E5%8E%9F%E7%90%86%E3%80%81%E8%AF%8A%E6%96%AD%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="http://mmmmmm.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内核-原理、诊断与优化学习笔记（二）：JVM运行机制</title>
    <link href="http://mmmmmm.me/2019-02-24.html"/>
    <id>http://mmmmmm.me/2019-02-24.html</id>
    <published>2019-02-23T14:20:02.000Z</published>
    <updated>2019-03-12T12:10:21.542Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="JVM启动流程"><a href="#JVM启动流程" class="headerlink" title="JVM启动流程"></a>JVM启动流程</h1><p><img alt="" data-original="../images/15509785973941.png"></p><p>jvm.cfg JVM配置文件<br>JNIEnv提供了大量的和JVM交互的一些操作，比如findClass<br><img alt="" data-original="../images/15509786089166.png"></p><h2 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h2><p>每个线程拥有一个PC寄存器<br>在线程创建时 创建<br>指向下一条指令的地址<br>执行本地方法时，PC的值为undefined</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>注意：<br>JDK6时，String等常量信息置于方法区<br>JDK7时，已经移动到了堆</p><h3 id="保存装载的类信息"><a href="#保存装载的类信息" class="headerlink" title="保存装载的类信息"></a>保存装载的类信息</h3><p>类型的常量池<br>字段，方法信息<br>方法字节码</p><h3 id="通常和永久区-Perm-关联在一起"><a href="#通常和永久区-Perm-关联在一起" class="headerlink" title="通常和永久区(Perm)关联在一起"></a>通常和永久区(Perm)关联在一起</h3><p>永久区(Perm)保存相对静止的数据，虽然类的数据在运行的过程当中可能会出现调整，比如说热加载，如果是热加载热替换的话，显然会有一个删除然后重新加载的过程，虽然这些信息可能会发生变动，但是应用层面的软件相比是比较稳定的，这样的稳定就是永久区，但是永久区并不是永远不会变的。</p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>跟方法区相比，方法区是jvm来维护的，而java堆所有代码中通过new出来的对象，基本上都是在java堆当中</p><ul><li>和程序开发密切相关</li><li>应用系统对象都保存在Java堆中</li><li>所有线程共享Java堆</li><li>对分代GC来说，堆也是分代的</li><li>GC的主要工作区间:<br>eden | s0 | s1 | tenured<br>eden对象出生的地方，s0 s1使用复制算法，tenured老年代。<h2 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h2>堆是全局共享的，栈是线程私有的</li><li>线程私有</li><li>栈由一系列帧组成（因此Java栈也叫做帧栈）</li><li>帧保存一个方法的局部变量、操作数栈、常量池指针</li><li>每一次方法调用创建一个帧，并压栈<h3 id="Java栈-–-局部变量表-包含参数和局部变量"><a href="#Java栈-–-局部变量表-包含参数和局部变量" class="headerlink" title="Java栈 – 局部变量表   包含参数和局部变量   "></a>Java栈 – 局部变量表 <strong><font color="red">包含参数和局部变量</font></strong></h3></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StackDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> int runStatic(int i,long l,float  f,<span class="built_in">Object</span> o ,byte b)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">public int runInstance(char c,short s,boolean b)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//runStatic静态方法的栈示意</span></span><br><span class="line"><span class="comment">//因为一个槽位只能容纳32位的大小，即int，所以int占了一个槽位，long（64位）占了两个槽位</span></span><br><span class="line"><span class="comment">//对象是引用reference（32位）</span></span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">0</span> int int i</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">1</span> long long l</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">3</span> float float f</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">4</span> reference <span class="built_in">Object</span> o</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">5</span> int byte b</span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//runInstance方法的示意</span></span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">0</span> reference <span class="keyword">this</span></span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">1</span> int char c</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">2</span> int short s</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">3</span> int boolean b</span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure><p><strong><font color="red">注意: runInstance和runStatic的区别是runInstance比runStatic多了一个自身的this引用。</font></strong></p><h3 id="Java栈-–-函数调用组成帧栈"><a href="#Java栈-–-函数调用组成帧栈" class="headerlink" title="Java栈 – 函数调用组成帧栈"></a>Java栈 – 函数调用组成帧栈</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> int runStatic(int i,long l,float  f,<span class="built_in">Object</span> o ,byte b)&#123;</span><br><span class="line"><span class="keyword">return</span> runStatic(i,l,f,o,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">-----------------------</span><br><span class="line"><span class="number">0</span> int int i</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">1</span> long long l</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">3</span> float float f</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">4</span> reference <span class="built_in">Object</span> o</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">5</span> int byte b</span><br><span class="line">-----------------------</span><br><span class="line"><span class="comment">//上面为一个帧，省略：操作数栈、返回地址等。</span></span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">0</span> int int i</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">1</span> long long l</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">3</span> float float f</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">4</span> reference <span class="built_in">Object</span> o</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">5</span> int byte b</span><br><span class="line">-----------------------</span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">0</span> int int i</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">1</span> long long l</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">3</span> float float f</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">4</span> reference <span class="built_in">Object</span> o</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">5</span> int byte b</span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure><p>每次方法调用就会有一个帧被压入栈，上面是一个递归调用，一直往上面压，一直到帧栈满了为止，发生溢出，方法调用结束了，帧又会自动从帧栈里面移除掉。</p><h3 id="Java栈-–-操作数栈"><a href="#Java栈-–-操作数栈" class="headerlink" title="Java栈 – 操作数栈"></a>Java栈 – 操作数栈</h3><p>Java没有寄存器，所有参数传递使用操作数栈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> int add(int a,int b)&#123;</span><br><span class="line">int c=<span class="number">0</span>;</span><br><span class="line">c=a+b;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:   iconst_0 <span class="comment">// 0压栈</span></span><br><span class="line"><span class="number">1</span>:   istore_2 <span class="comment">// 弹出int，存放于局部变量2</span></span><br><span class="line"><span class="number">2</span>:   iload_0  <span class="comment">// 把局部变量0压栈</span></span><br><span class="line"><span class="number">3</span>:   iload_1 <span class="comment">// 局部变量1压栈</span></span><br><span class="line"><span class="number">4</span>:   iadd      <span class="comment">//弹出2个变量，求和，结果压栈</span></span><br><span class="line"><span class="number">5</span>:   istore_2 <span class="comment">//弹出结果，放于局部变量2</span></span><br><span class="line"><span class="number">6</span>:   iload_2  <span class="comment">//局部变量2压栈</span></span><br><span class="line"><span class="number">7</span>:   ireturn   <span class="comment">//返回</span></span><br></pre></td></tr></table></figure><p><img alt="" data-original="../images/15509786612826.png"></p><h3 id="Java栈-–-栈上分配"><a href="#Java栈-–-栈上分配" class="headerlink" title="Java栈 – 栈上分配"></a>Java栈 – 栈上分配</h3><h4 id="C-代码示例"><a href="#C-代码示例" class="headerlink" title="C++ 代码示例"></a>C++ 代码示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BcmBasicString</span></span>&#123;    ....&#125;</span><br></pre></td></tr></table></figure><h5 id="堆上分配，每次需要清理空间"><a href="#堆上分配，每次需要清理空间" class="headerlink" title="堆上分配，每次需要清理空间"></a>堆上分配，每次需要清理空间</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> method()&#123;    </span><br><span class="line">BcmBasicString* str=<span class="keyword">new</span> BcmBasicString;    ....    delete str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码new是放在了堆里面，每次用完之后需要delete，如果忘记的会就会发生内存泄漏，这种错误是很难发现的。</p><h5 id="栈上分配，函数调用完成自动清理"><a href="#栈上分配，函数调用完成自动清理" class="headerlink" title="栈上分配，函数调用完成自动清理"></a>栈上分配，函数调用完成自动清理</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明出来的写法</span></span><br><span class="line">public <span class="keyword">void</span> method()&#123;    </span><br><span class="line">BcmBasicString str;  </span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OnStackTest</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> alloc()&#123;</span><br><span class="line">        byte[] b=<span class="keyword">new</span> byte[<span class="number">2</span>];</span><br><span class="line">        b[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        long b=System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">100000000</span>;i++)&#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        long e=System.currentTimeMillis();</span><br><span class="line">        System.out.println(e-b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-server -Xmx10m -Xms10m</span><br><span class="line">-XX:+DoEscapeAnalysis -XX:+PrintGC</span><br></pre></td></tr></table></figure><p>这种方式运行<br>输出结果 5<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-server -Xmx10m -Xms10m  </span><br><span class="line">-XX:-DoEscapeAnalysis -XX:+PrintGC</span><br></pre></td></tr></table></figure><p></p><p>这种方式运行输出如下结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">[GC <span class="number">3550</span>K-&gt;<span class="number">478</span>K(<span class="number">10240</span>K), <span class="number">0.0000977</span> secs]</span><br><span class="line">[GC <span class="number">3550</span>K-&gt;<span class="number">478</span>K(<span class="number">10240</span>K), <span class="number">0.0001361</span> secs]</span><br><span class="line">[GC <span class="number">3550</span>K-&gt;<span class="number">478</span>K(<span class="number">10240</span>K), <span class="number">0.0000963</span> secs]</span><br><span class="line"><span class="number">564</span></span><br></pre></td></tr></table></figure><p>说明方式一是在栈上面分配内存，方式二是在堆上分配内存，jvm内部是有相关的优化的，当数据量不是很大的时候，通过栈的方式分配，能够减小gc的压力。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>小对象（一般几十个bytes），在没有逃逸的情况下（逃逸，即分配出来之后除了我的线程要用，其他的线程也要用的时候，因为栈是线程私有的。），可以直接分配在栈上</li><li>直接分配在栈上，可以自动回收，减轻GC压力（函数调用完成之后）</li><li>大对象或者逃逸对象无法栈上分配<h3 id="栈、堆、方法区交互"><a href="#栈、堆、方法区交互" class="headerlink" title="栈、堆、方法区交互"></a>栈、堆、方法区交互</h3><h4 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h4><img alt="" data-original="../images/15509786748287.png"></li></ul><p>JVM通过栈调用main方法，局部变量test1存放着Sample实例的引用，用过实例的引用去堆中找到Sample实例，Sample实例的相关信息在方法区中存放着。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public   <span class="class"><span class="keyword">class</span>  <span class="title">AppMain</span>     </span></span><br><span class="line"><span class="class"> //运行时, <span class="title">jvm</span> 把<span class="title">appmain</span>的信息都放入方法区 </span></span><br><span class="line"><span class="class"> </span>&#123; public   <span class="keyword">static</span>   <span class="keyword">void</span>  main(<span class="built_in">String</span>[] args)  </span><br><span class="line"><span class="comment">//main 方法本身放入方法区。 &#123;</span></span><br><span class="line"> Sample test1 = <span class="keyword">new</span>  Sample( <span class="string">" 测试1 "</span> );  </span><br><span class="line"> <span class="comment">//test1是引用，所以放到栈区里， Sample是自定义对象应该放到堆里面 </span></span><br><span class="line"> Sample test2 = <span class="keyword">new</span>  Sample( <span class="string">" 测试2 "</span> ); </span><br><span class="line"> test1.printName(); test2.printName(); &#125; </span><br><span class="line">public   <span class="class"><span class="keyword">class</span>  <span class="title">Sample</span>       </span></span><br><span class="line"><span class="class"> //运行时, <span class="title">jvm</span> 把<span class="title">appmain</span>的信息都放入方法区 </span></span><br><span class="line"><span class="class"> </span>&#123; private  name;     </span><br><span class="line"> <span class="comment">//new Sample实例后， name 引用放入栈区里，  name 对象放入堆里 </span></span><br><span class="line"> public  Sample(<span class="built_in">String</span> name) </span><br><span class="line"> &#123; <span class="keyword">this</span> .name = name; &#125; </span><br><span class="line"> <span class="comment">//print方法本身放入 方法区里。public   void  printName()    </span></span><br><span class="line"> &#123; System.out.println(name); &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="JVM基本结构"><a href="#JVM基本结构" class="headerlink" title="JVM基本结构"></a>JVM基本结构</h1><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><ul><li>每一个线程有一个工作内存和主存独立<br>这里的主存指的是堆内存，共享内存</li><li>工作内存存放主存中变量的值的拷贝<br><img alt="" data-original="../images/15509786946574.png"></li></ul><p>当数据从主内存复制到工作存储时，必须出现两个动作：第一，由主内存执行的读（read）操作；第二，由工作内存执行的相应的load操作；当数据从工作内存拷贝到主内存时，也出现两个操作：第一个，由工作内存执行的存储（store）操作；第二，由主内存执行的相应的写（write）操作</p><p>每一个操作都是原子的，即执行期间不会被中断<br><strong><font color="red">对于普通变量，一个线程中更新的值，不能马上反应在其他变量中<br>如果需要在其他线程中立即可见，需要使用 volatile 关键字</font></strong><br>可以看到从工作内存到主存中是需要一定的时间的，所以当一个线程中更新了值的时候，不能够在其他的线程中立即可见。</p><p><img alt="" data-original="../images/15509787076064.png"></p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">VolatileStopThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">private volatile boolean stop = <span class="literal">false</span>;</span><br><span class="line">public <span class="keyword">void</span> stopMe()&#123;</span><br><span class="line">stop=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> run()&#123;</span><br><span class="line">int i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">    System.out.println(<span class="string">"Stop thread"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span> args[]) throws InterruptedException&#123;</span><br><span class="line">VolatileStopThread t=<span class="keyword">new</span> VolatileStopThread();</span><br><span class="line">t.start();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">t.stopMe();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有volatile -server 运行 无法停止<br>volatile 不能代替锁<br>一般认为volatile 比锁性能好（不绝对）</p><p>选择使用volatile的条件是：<br>语义是否满足应用</p><h2 id="内存模型的几个重要概念"><a href="#内存模型的几个重要概念" class="headerlink" title="内存模型的几个重要概念"></a>内存模型的几个重要概念</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>一个线程修改了变量，其他线程可以立即知道</p><h3 id="保证可见性的方法"><a href="#保证可见性的方法" class="headerlink" title="保证可见性的方法"></a>保证可见性的方法</h3><p>volatile<br>synchronized （unlock之前，写变量值回主存）<br>final(一旦初始化完成，其他线程就可见)</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>在本线程内，操作都是有序的<br>在线程外观察，操作都是无序的。（指令重排 或 主内存同步延时）</p><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p>线程内串行语义<br>写后读 a = 1;b = a; 写一个变量之后，再读这个位置。<br>写后写 a = 1;a = 2; 写一个变量之后，再写这个变量。<br>读后写 a = b;b = 1; 读一个变量之后，再写这个变量。<br>以上语句不可重排<br>编译器不考虑多线程间的语义<br>可重排： a=1;b=2;</p><h4 id="指令重排-–-破坏线程间的有序性"><a href="#指令重排-–-破坏线程间的有序性" class="headerlink" title="指令重排 – 破坏线程间的有序性"></a>指令重排 – 破坏线程间的有序性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderExample</span> </span>&#123;</span><br><span class="line">int a = <span class="number">0</span>;</span><br><span class="line">boolean flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> writer() &#123;</span><br><span class="line">    a = <span class="number">1</span>;                   </span><br><span class="line">    flag = <span class="literal">true</span>;           </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> reader() &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;                </span><br><span class="line">        int i =  a +<span class="number">1</span>;      </span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程A首先执行writer()方法<br>线程B线程接着执行reader()方法<br>线程B在int i=a+1 是不一定能看到a已经被赋值为1<br>因为在writer中，两句话顺序可能打乱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程A</span><br><span class="line">flag=<span class="literal">true</span></span><br><span class="line">a=<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程B</span><br><span class="line">flag=<span class="literal">true</span>(此时a=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="指令重排-–-保证有序性的方法"><a href="#指令重排-–-保证有序性的方法" class="headerlink" title="指令重排 – 保证有序性的方法"></a>指令重排 – 保证有序性的方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderExample</span> </span>&#123;</span><br><span class="line">int a = <span class="number">0</span>;</span><br><span class="line">boolean flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">public synchronized <span class="keyword">void</span> writer() &#123;</span><br><span class="line">    a = <span class="number">1</span>;                   </span><br><span class="line">    flag = <span class="literal">true</span>;           </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized <span class="keyword">void</span> reader() &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;                </span><br><span class="line">        int i =  a +<span class="number">1</span>;      </span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步后，即使做了writer重排，因为互斥的缘故，reader 线程看writer线程也是顺序执行的。在线程A执行完之前，线程B是进不来的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程A</span><br><span class="line">flag=<span class="literal">true</span></span><br><span class="line">a=<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程B</span><br><span class="line">flag=<span class="literal">true</span>(此时a=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="指令重排的基本原则"><a href="#指令重排的基本原则" class="headerlink" title="指令重排的基本原则"></a>指令重排的基本原则</h4><p>程序顺序原则：一个线程内保证语义的串行性<br>volatile规则：volatile变量的写，先发生于读<br>锁规则：解锁(unlock)必然发生在随后的加锁(lock)前<br>传递性：A先于B，B先于C 那么A必然先于C<br>线程的start方法先于它的每一个动作<br>线程的所有操作先于线程的终结（Thread.join()）<br>线程的中断（interrupt()）先于被中断线程的代码<br>对象的构造函数执行结束先于finalize()方法</p><h1 id="编译和解释运行的概念（字节码运行的两种方式）"><a href="#编译和解释运行的概念（字节码运行的两种方式）" class="headerlink" title="编译和解释运行的概念（字节码运行的两种方式）"></a>编译和解释运行的概念（字节码运行的两种方式）</h1><h2 id="解释运行"><a href="#解释运行" class="headerlink" title="解释运行"></a>解释运行</h2><p>解释执行以解释方式运行字节码<br>解释执行的意思是：读一句执行一句</p><h2 id="编译运行（JIT–just-in-time）"><a href="#编译运行（JIT–just-in-time）" class="headerlink" title="编译运行（JIT–just in time）"></a>编译运行（JIT–just in time）</h2><p>将字节码编译成机器码<br>直接执行机器码<br>运行时编译<br>编译后性能有数量级的提升<br>编译执行和解释执行性能应该差十倍以上。</p><h1 id="编译和解释运行的概念"><a href="#编译和解释运行的概念" class="headerlink" title="编译和解释运行的概念"></a>编译和解释运行的概念</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;JVM启动流程&quot;&gt;&lt;a href=&quot;#JVM启动流程&quot; class=&quot;headerlink&quot; title=&quot;JVM
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM内核-原理、诊断与优化学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM%E5%86%85%E6%A0%B8-%E5%8E%9F%E7%90%86%E3%80%81%E8%AF%8A%E6%96%AD%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="http://mmmmmm.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内核-原理、诊断与优化学习笔记（一）：初识JVM</title>
    <link href="http://mmmmmm.me/2019-02-23.html"/>
    <id>http://mmmmmm.me/2019-02-23.html</id>
    <published>2019-02-23T11:20:02.000Z</published>
    <updated>2019-02-23T12:28:46.769Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="JVM的概念"><a href="#JVM的概念" class="headerlink" title="JVM的概念"></a>JVM的概念</h1><h2 id="JVM是Java-Virtual-Machine的简称。意为Java虚拟机"><a href="#JVM是Java-Virtual-Machine的简称。意为Java虚拟机" class="headerlink" title="JVM是Java Virtual Machine的简称。意为Java虚拟机"></a>JVM是Java Virtual Machine的简称。意为Java虚拟机</h2><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统</p><h2 id="有哪些虚拟机"><a href="#有哪些虚拟机" class="headerlink" title="有哪些虚拟机"></a>有哪些虚拟机</h2><ul><li>VMWare</li><li>Visual Box</li><li>JVM</li></ul><h2 id="VMWare或者Visual-Box都是使用软件模拟物理CPU的指令集"><a href="#VMWare或者Visual-Box都是使用软件模拟物理CPU的指令集" class="headerlink" title="VMWare或者Visual Box都是使用软件模拟物理CPU的指令集"></a>VMWare或者Visual Box都是使用软件模拟物理CPU的指令集</h2><p>比如它们模拟的cpu、硬盘、内存，等都是现实存在的，能够在现实中找到对应的案例的。</p><h2 id="JVM使用软件模拟Java-字节码的指令集"><a href="#JVM使用软件模拟Java-字节码的指令集" class="headerlink" title="JVM使用软件模拟Java 字节码的指令集"></a>JVM使用软件模拟Java 字节码的指令集</h2><p>JVM模拟的对象是现实中没有的，现实中没有任何一个计算机能够运行Java字节码，单纯从从软件上做的一个设计，来模拟一个硬件的行为，比如jvm运行的的是java字节码指令集，为了设计上的精简，我们知道正常的cpu中有若干个寄存器，jvm中除了pc寄存器外，其他的寄存器都做了裁剪，因为寄存器的主要功能是加快数据访问的速度，因为在jvm中是纯粹用软件模拟的，速度使用寄存器后并不会有很好的提升，并且引入寄存器后，也为jvm的设计以及实现带来很大的困难，所以把这些功能去掉了。综上，jvm是一个被定制过的现实中不存在的计算机。</p><h1 id="JVM发展历史"><a href="#JVM发展历史" class="headerlink" title="JVM发展历史"></a>JVM发展历史</h1><h2 id="1996年-SUN-JDK-1-0-Classic-VM"><a href="#1996年-SUN-JDK-1-0-Classic-VM" class="headerlink" title="1996年 SUN JDK 1.0 Classic VM"></a>1996年 SUN JDK 1.0 Classic VM</h2><p>纯解释运行，使用外挂进行JIT，没有内置的即时编译的模块，一旦开启外挂，解释运行的功能就没有了。<br>Classic VM生命周期比较长，在1.3 、1.4的时候才被淘汰</p><h2 id="1997年-JDK1-1-发布"><a href="#1997年-JDK1-1-发布" class="headerlink" title="1997年 JDK1.1 发布"></a>1997年 JDK1.1 发布</h2><p>-AWT、内部类、JDBC、RMI、反射</p><h2 id="1998年-JDK1-2-Solaris-Exact-VM"><a href="#1998年-JDK1-2-Solaris-Exact-VM" class="headerlink" title="1998年 JDK1.2 Solaris Exact VM"></a>1998年 JDK1.2 Solaris Exact VM</h2><p>JIT 解释器混合<br>Accurate Memory Management 精确内存管理，数据类型敏感<br>提升的GC性能<br>JDK1.2开始 称为Java 2<br>J2SE J2EE J2ME 的出现<br>加入Swing Collections</p><p>Solaris Exact VM生命周期比较短。</p><h2 id="2000年-JDK-1-3-Hotspot-作为默认虚拟机发布"><a href="#2000年-JDK-1-3-Hotspot-作为默认虚拟机发布" class="headerlink" title="2000年 JDK 1.3 Hotspot 作为默认虚拟机发布"></a>2000年 JDK 1.3 Hotspot 作为默认虚拟机发布</h2><p>加入JavaSound加入了一些声音上的api</p><h2 id="2002年-JDK-1-4-Classic-VM退出历史舞台"><a href="#2002年-JDK-1-4-Classic-VM退出历史舞台" class="headerlink" title="2002年 JDK 1.4 Classic VM退出历史舞台"></a>2002年 JDK 1.4 Classic VM退出历史舞台</h2><p>Assert 正则表达式 NIO IPV6 日志API 加密类库</p><h2 id="2004年发布-JDK1-5-即-JDK5-、J2SE-5-、Java-5（重要版本）"><a href="#2004年发布-JDK1-5-即-JDK5-、J2SE-5-、Java-5（重要版本）" class="headerlink" title="2004年发布 JDK1.5 即 JDK5 、J2SE 5 、Java 5（重要版本）"></a>2004年发布 JDK1.5 即 JDK5 、J2SE 5 、Java 5（重要版本）</h2><p>泛型<br>注解<br>装箱<br>枚举<br>可变长的参数<br>Foreach循环</p><h2 id="JDK1-6-JDK6"><a href="#JDK1-6-JDK6" class="headerlink" title="JDK1.6 JDK6"></a>JDK1.6 JDK6</h2><p>脚本语言支持<br>JDBC 4.0<br>Java编译器 API（开放了这个API）</p><h2 id="2011年-JDK7发布"><a href="#2011年-JDK7发布" class="headerlink" title="2011年 JDK7发布"></a>2011年 JDK7发布</h2><p>延误项目推出到JDK8<br>G1（全新的gc收集器）<br>动态语言增强（动态语言的火热）<br>64位系统中的压缩指针<br>NIO 2.0</p><h2 id="2014年-JDK8发布（重要版本）"><a href="#2014年-JDK8发布（重要版本）" class="headerlink" title="2014年 JDK8发布（重要版本）"></a>2014年 JDK8发布（重要版本）</h2><p>Lambda表达式（模拟了函数式编程）<br>语法增强 Java类型注解</p><h2 id="2016年JDK9"><a href="#2016年JDK9" class="headerlink" title="2016年JDK9"></a>2016年JDK9</h2><p>模块化</p><h2 id="大事件"><a href="#大事件" class="headerlink" title="大事件"></a>大事件</h2><h3 id="使用最为广泛的JVM为HotSpot"><a href="#使用最为广泛的JVM为HotSpot" class="headerlink" title="使用最为广泛的JVM为HotSpot"></a>使用最为广泛的JVM为HotSpot</h3><h3 id="HotSpot-为Longview-Technologies开发-被SUN收购"><a href="#HotSpot-为Longview-Technologies开发-被SUN收购" class="headerlink" title="HotSpot 为Longview Technologies开发 被SUN收购"></a>HotSpot 为Longview Technologies开发 被SUN收购</h3><h3 id="2006年-Java开源-并建立OpenJDK"><a href="#2006年-Java开源-并建立OpenJDK" class="headerlink" title="2006年 Java开源 并建立OpenJDK"></a>2006年 Java开源 并建立OpenJDK</h3><p>HotSpot 成为Sun JDK和OpenJDK中所带的虚拟机</p><h3 id="2008-年-Oracle收购BEA"><a href="#2008-年-Oracle收购BEA" class="headerlink" title="2008 年 Oracle收购BEA"></a>2008 年 Oracle收购BEA</h3><p>得到JRockit VM</p><h3 id="2010年Oracle-收购-Sun"><a href="#2010年Oracle-收购-Sun" class="headerlink" title="2010年Oracle 收购 Sun"></a>2010年Oracle 收购 Sun</h3><p>得到Hotspot</p><h3 id="Oracle宣布在JDK8时整合JRockit和Hotspot，优势互补"><a href="#Oracle宣布在JDK8时整合JRockit和Hotspot，优势互补" class="headerlink" title="Oracle宣布在JDK8时整合JRockit和Hotspot，优势互补"></a>Oracle宣布在JDK8时整合JRockit和Hotspot，优势互补</h3><p>在Hotspot基础上，移植JRockit优秀特性<br>推测：JRockit在不久的将来会退出历史舞台，但是HotSpot会深受JRockit的影响。</p><h1 id="JVM种类"><a href="#JVM种类" class="headerlink" title="JVM种类"></a>JVM种类</h1><h2 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h2><p>SUN发布<br>IOS Android前，广泛用于手机系统</p><h2 id="CDC-CLDC-HotSpot"><a href="#CDC-CLDC-HotSpot" class="headerlink" title="CDC/CLDC HotSpot"></a>CDC/CLDC HotSpot</h2><p>手机、电子书、PDA等设备上建立统一的Java编程接口<br>J2ME的重要组成部分</p><h2 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit"></a>JRockit</h2><h2 id="IBM-J9-VM"><a href="#IBM-J9-VM" class="headerlink" title="IBM J9 VM"></a>IBM J9 VM</h2><p>IBM内部</p><h2 id="Apache-Harmony"><a href="#Apache-Harmony" class="headerlink" title="Apache Harmony"></a>Apache Harmony</h2><p>兼容于JDK 1.5和JDK 1.6的Java程序运行平台<br>与Oracle关系恶劣 退出JCP ，Java社区的分裂<br>OpenJDK出现后，受到挑战 2011年 退役<br>没有大规模商用经历<br>对Android的发展有积极作用<br>BEA</p><h1 id="Java语言规范"><a href="#Java语言规范" class="headerlink" title="Java语言规范"></a>Java语言规范</h1><h2 id="语法定义"><a href="#语法定义" class="headerlink" title="语法定义"></a>语法定义</h2><h3 id="IfThenStatement"><a href="#IfThenStatement" class="headerlink" title="IfThenStatement:"></a>IfThenStatement:</h3><p>if ( Expression ) Statement</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;<span class="keyword">do</span> sth;&#125;</span><br></pre></td></tr></table></figure><h3 id="ArgumentList"><a href="#ArgumentList" class="headerlink" title="ArgumentList:"></a>ArgumentList:</h3><p>Argument<br>ArgumentList , Argument</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(a,b,c,d);</span><br></pre></td></tr></table></figure><h2 id="词法结构"><a href="#词法结构" class="headerlink" title="词法结构"></a>词法结构</h2><p>\u + 4个16进制数字 表示UTF-16<br>行终结符： CR, or LF, or CR LF.<br>空白符<br>空格 tab \t 换页 \f 行终结符<br>注释<br>标识符<br>关键字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标识符：标识符字符串不能使关键字或者布尔值或者null</span></span><br><span class="line">Identifier:    IdentifierChars but not a Keyword or BooleanLiteral or NullLiteral</span><br><span class="line"><span class="comment">//标识符串：java字符</span></span><br><span class="line">IdentifierChars:    JavaLetter    IdentifierChars JavaLetterOrDigit</span><br><span class="line"><span class="comment">//java字符：任何一个unicode</span></span><br><span class="line">JavaLetter:    any Unicode character that is a Java letter (see below)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">JavaLetterOrDigit:    any Unicode character that is a Java letter-or-digit (see below)</span><br></pre></td></tr></table></figure><h3 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> 打印()&#123;</span><br><span class="line">System.out.println(<span class="string">"中文方法哦"</span>);</span><br><span class="line">&#125;</span><br><span class="line">public  <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">打印();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有意思的是，代码中有中文</p><h3 id="数字相关"><a href="#数字相关" class="headerlink" title="数字相关"></a>数字相关</h3><p>在jdk1.7中一个比较大的改变是允许有下划线，好处是当数字比较大的时候看的比较清楚一些。</p><ul><li>Int<br>0 2 0372 0xDada_Cafe 1996 0x00_FF__00_FF</li><li>Long<br>0l 0777L 0x100000000L 2_147_483_648L 0xC0B0L</li><li>Float<br>1e1f 2.f .3f 0f 3.14f 6.022137e+23f</li><li>Double<br>1e1 2. .3 0.0 3.14 1e-9d 1e137</li><li>操作<br>+= -= *= /= &amp;= |= ^= %= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=<h3 id="哪些是合法的数字呢？"><a href="#哪些是合法的数字呢？" class="headerlink" title="哪些是合法的数字呢？"></a>哪些是合法的数字呢？</h3>private int a=0xDada_Cafe;<br>private float b=0x1.fffffeP+127f;<br>private float c=1996;<br>private float d=1996.3;<br>private int f=9999e2;<br>private double g=33e2;<br>private float h=0x1.fffep-12f;<br>private float i=1.fffep-12f;<br>private long p=0b1_1_1_0_1;<br>private long q=0b1_1_1_0_2;</li></ul><h2 id="类型和变量"><a href="#类型和变量" class="headerlink" title="类型和变量"></a>类型和变量</h2><ul><li>元类型<br>byte short int long float char</li><li>变量初始值<br>boolean false<br>char \u0000</li><li>泛型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>&#123; int val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        int i1 = <span class="number">3</span>;</span><br><span class="line">        int i2 = i1;</span><br><span class="line">        i2 = <span class="number">4</span>;</span><br><span class="line">        System.out.print(<span class="string">"i1=="</span> + i1);</span><br><span class="line">        System.out.println(<span class="string">" but i2=="</span> + i2);</span><br><span class="line">        Value v1 = <span class="keyword">new</span> Value();</span><br><span class="line">        v1.val = <span class="number">5</span>;</span><br><span class="line">        Value v2 = v1;</span><br><span class="line">        v2.val = <span class="number">6</span>;</span><br><span class="line">        System.out.print(<span class="string">"v1.val=="</span> + v1.val);</span><br><span class="line">        System.out.println(<span class="string">" and v2.val=="</span> + v2.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i1==3 but i2==4<br>v1.val==6 and v2.val==6<br>i1 i2为不同的变量<br>v1 v2为引用同一个实例</p><h2 id="略"><a href="#略" class="headerlink" title="略"></a>略</h2><p>Java内存模型<br>类加载链接的过程<br>public static final abstract的定义<br>异常<br>数组的使用<br>…….</p><h1 id="JVM规范"><a href="#JVM规范" class="headerlink" title="JVM规范"></a>JVM规范</h1><p>Java语言规范定义了什么是Java语言<br>Java语言和JVM相对独立<br>符合JVM规范的就能够在JVM上运行，比如：</p><ul><li>Groovy</li><li>Clojure</li><li><p>Scala<br>JVM主要定义二进制class文件和JVM指令集等</p></li><li><p>Class 文件格式</p></li><li>数字的内部表示和存储<br>Byte -128 to 127 (-27 to 27 - 1)</li><li>returnAddress 数据类型定义<br>指向操作码的指针。不对应Java数据类型，不能在运行时修改。Finally实现需要</li><li>定义PC</li><li>堆</li><li>栈</li><li>方法区</li></ul><h2 id="整数的表达"><a href="#整数的表达" class="headerlink" title="整数的表达"></a>整数的表达</h2><ul><li>原码：第一位为符号位（0为正数，1为负数）</li><li>反码：符号位不动，原码取反</li><li>负数补码：符号位不动，反码加1</li><li>正数补码：和原码相同<ul><li>打印整数的二进制表示</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a=<span class="number">-6</span>;</span><br><span class="line"><span class="comment">//因为整数有32位，所以进行32次循环。</span></span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line"><span class="comment">//0x80000000表示最高位为1的数字，所以a &amp; 0x80000000只有一位是1，</span></span><br><span class="line"><span class="comment">//第一次i=0，就是把a的第一位取出来，无符号右移(31-i)位。</span></span><br><span class="line"><span class="comment">//依次循环，将每一位打印出来</span></span><br><span class="line">int t=(a &amp; <span class="number">0x80000000</span>&gt;&gt;&gt;i)&gt;&gt;&gt;(<span class="number">31</span>-i);</span><br><span class="line">System.out.print(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">00000101</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-6</span></span><br><span class="line">原码： <span class="number">10000110</span></span><br><span class="line">反码： <span class="number">11111001</span></span><br><span class="line">补码： <span class="number">11111010</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span></span><br><span class="line">原码： <span class="number">10000001</span></span><br><span class="line">反码： <span class="number">11111110</span></span><br><span class="line">补码： <span class="number">11111111</span></span><br></pre></td></tr></table></figure><h3 id="为什么要用补码？"><a href="#为什么要用补码？" class="headerlink" title="为什么要用补码？"></a>为什么要用补码？</h3><p>0是一个比较特殊的数字，既不属于正数，也不属于负数<br>计算0的表示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">正数：<span class="number">00000000</span></span><br><span class="line">负数：<span class="number">10000000</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">正数：<span class="number">00000000</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">负数：<span class="number">10000000</span></span><br><span class="line">反码：<span class="number">11111111</span></span><br><span class="line">补码：<span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>看到这里补码的好处是为了没有歧义的表示零</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-6</span>+<span class="number">5</span></span><br><span class="line">    <span class="number">11111010</span></span><br><span class="line">+ <span class="number">00000101</span></span><br><span class="line">= <span class="number">11111111</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-4</span>+<span class="number">5</span></span><br><span class="line">    <span class="number">11111100</span></span><br><span class="line">+ <span class="number">00000101</span></span><br><span class="line">= <span class="number">00000001</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-3</span>+<span class="number">5</span></span><br><span class="line">    <span class="number">11111101</span></span><br><span class="line">+ <span class="number">00000101</span></span><br><span class="line">= <span class="number">00000010</span></span><br></pre></td></tr></table></figure><p>看到这里，补码还有一个好处就是方便的计算两个数字之和（两个补码之和，符号位直接参与运算，得到的记过就是正确的结果。如果是源码做计算，符号位参与运算得不到正确的结果。），当然减法是一个特殊的加法。</p><h2 id="Float的表示与定义"><a href="#Float的表示与定义" class="headerlink" title="Float的表示与定义"></a>Float的表示与定义</h2><p>支持 IEEE 754<br>s eeeeeeee mmmmmmmmmmmmmmmmmmmmmmm<br>s符号位 eeeeeeee 指数：8 mmmmmmmmmmmmmmmmmmmmmmm 尾数：23</p><p>e全0 尾数附加位为0 否则尾数附加位为1，所以这里的尾数看似是23位，实质上是24位。<br>表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s*m*<span class="number">2</span>^(e<span class="number">-127</span>)</span><br></pre></td></tr></table></figure><p>m指的是后面的23位</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-5</span></span><br><span class="line"><span class="number">1</span> <span class="number">10000001</span> <span class="number">01000000000000000000000</span></span><br><span class="line"><span class="number">-1</span>*<span class="number">2</span>^(<span class="number">129</span><span class="number">-127</span>)*(<span class="number">2</span>^<span class="number">0</span>+<span class="number">2</span>^<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><h2 id="一些特殊的方法"><a href="#一些特殊的方法" class="headerlink" title="一些特殊的方法"></a>一些特殊的方法</h2><p>clinit 类的初始化方法<br>init 实例的初始化方法</p><h2 id="JVM指令集"><a href="#JVM指令集" class="headerlink" title="JVM指令集"></a>JVM指令集</h2><ul><li>类型转化<br>l2i</li><li>出栈入栈操作<br>因为虚拟机没有寄存器，所以很多的指令都是通过栈的方式来操作的，所以有一系列的指令来定义出栈和入栈的操作。<br>aload astore</li><li>运算<br>iadd（+） isub（-）</li><li>流程控制<br>ifeq（相等） ifne（不相等）</li><li><p>函数调用<br>invokevirtual（调用虚函数） invokeinterface （调用接口） invokespecial invokestatic （调用静态）</p><h2 id="JVM需要对Java-Library-提供以下支持："><a href="#JVM需要对Java-Library-提供以下支持：" class="headerlink" title="JVM需要对Java Library 提供以下支持："></a>JVM需要对Java Library 提供以下支持：</h2><p>因为这些功能没有办法通过java语言本身支持，所以通过JVM实现。</p></li><li><p>反射 java.lang.reflect</p></li><li>ClassLoader</li><li>初始化class和interface</li><li>安全相关 java.security</li><li>多线程</li><li>弱引用<h2 id="JVM的编译"><a href="#JVM的编译" class="headerlink" title="JVM的编译"></a>JVM的编译</h2>源码到JVM指令的对应格式<br>Javap 反编译<br>JVM反汇编的格式：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;index&gt; &lt;opcode&gt; [ &lt;operand1&gt; [ &lt;operand2&gt;... ]] [&lt;comment&gt;]</span><br></pre></td></tr></table></figure><p>索引（偏移量） 操作码（+-*/入站出站） 注解</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> spin() &#123;</span><br><span class="line">  int i; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; ;</span><br><span class="line">     <span class="comment">// Loop body is empty</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>   iconst_0       <span class="comment">// Push int constant 0</span></span><br><span class="line"><span class="number">1</span>   istore_1       <span class="comment">// Store into local variable 1 (i=0)</span></span><br><span class="line"><span class="number">2</span>   goto <span class="number">8</span>         <span class="comment">// First time through don't increment</span></span><br><span class="line"><span class="number">5</span>   iinc <span class="number">1</span> <span class="number">1</span>       <span class="comment">// Increment local variable 1 by 1 (i++)</span></span><br><span class="line"><span class="number">8</span>   iload_1        <span class="comment">// Push local variable 1 (i)</span></span><br><span class="line"><span class="number">9</span>   bipush <span class="number">100</span>     <span class="comment">// Push int constant 100</span></span><br><span class="line"><span class="number">11</span>  if_icmplt <span class="number">5</span>    <span class="comment">// Compare and loop if less than (i &lt; 100)</span></span><br><span class="line"><span class="number">14</span>  <span class="keyword">return</span>         <span class="comment">// Return void when done</span></span><br></pre></td></tr></table></figure><p>在JVM中直接执行的是JVM指令代码（如上）。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;JVM的概念&quot;&gt;&lt;a href=&quot;#JVM的概念&quot; class=&quot;headerlink&quot; title=&quot;JVM的概
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM内核-原理、诊断与优化学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM%E5%86%85%E6%A0%B8-%E5%8E%9F%E7%90%86%E3%80%81%E8%AF%8A%E6%96%AD%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="http://mmmmmm.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发程序设计学习笔记（十一）：Jetty分析</title>
    <link href="http://mmmmmm.me/2019-02-22.html"/>
    <id>http://mmmmmm.me/2019-02-22.html</id>
    <published>2019-02-22T11:20:02.000Z</published>
    <updated>2019-02-22T15:39:09.109Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><p>本次笔记是对jetty，一个servlet容器，一个httpServer,内部的实现，因为代码量量比较多，不会从架构的方向介绍，作为一个servlet容器，不会介绍如何使用jsp，而是通过多线程的方向，从代码触发，看究竟是如何提高并发量的。<br>综上本次笔记并没有对jetty具体是如何用的做介绍，主要是学习jetty高并发的处理手段。</p><h1 id="new-Server"><a href="#new-Server" class="headerlink" title="new Server()"></a>new Server()</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Server(@Name(<span class="string">"port"</span>)int port) &#123;</span><br><span class="line">    <span class="keyword">this</span>((ThreadPool)<span class="literal">null</span>);</span><br><span class="line">    ServerConnector connector=<span class="keyword">new</span> ServerConnector(<span class="keyword">this</span>); connector.setPort(port);</span><br><span class="line">    setConnectors(<span class="keyword">new</span> Connector[]&#123;connector&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化线程池"><a href="#初始化线程池" class="headerlink" title="初始化线程池"></a>初始化线程池</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Server(@Name(<span class="string">"threadpool"</span>) ThreadPool pool) &#123;</span><br><span class="line">    _threadPool=pool!=<span class="literal">null</span>?pool:<span class="keyword">new</span> QueuedThreadPool(); addBean(_threadPool);</span><br><span class="line">    setServer(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QueuedThreadPool"><a href="#QueuedThreadPool" class="headerlink" title="QueuedThreadPool"></a>QueuedThreadPool</h3><p>并不是初始化jdk的线程池，而是new自己的QueuedThreadPool，QueuedThreadPool实现了SizedThreadPool</p><h3 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a>execute()方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> execute(Runnable job) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isRunning() || !_jobs.offer(job)) &#123;</span><br><span class="line">        LOG.warn(<span class="string">"&#123;&#125; rejected &#123;&#125;"</span>, <span class="keyword">this</span>, job);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(job.toString()); &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Make sure there is at least one thread executing the job. if (getThreads() == 0)</span></span><br><span class="line">        startThreads(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心是将任务压入队列 ： _jobs.offer(job)</p><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>这里的_jobs是BlockingQueue，保存线程池执行的所有的任务。<br>将任务推入<br>BlockingQueue<runnable>org.eclipse.jetty.util.thread.QueuedThreadPool._jobs</runnable></p><p>BlockingQueue不是一个高性能的，所以execute不太可能被非常频繁的调用。</p><h2 id="初始化ServerConnector"><a href="#初始化ServerConnector" class="headerlink" title="初始化ServerConnector"></a>初始化ServerConnector</h2><p>处理一些http的连接以及NIO、Selector一些的东西。<br>HTTP connector using NIO ByteChannels and Selectors<br>继承自 AbstractConnector</p><h3 id="初始化ScheduledExecutorScheduler"><a href="#初始化ScheduledExecutorScheduler" class="headerlink" title="初始化ScheduledExecutorScheduler"></a>初始化ScheduledExecutorScheduler</h3><p>调度器<br>based on JDK’s {@link ScheduledThreadPoolExecutor}.<br>有些任务是需要每隔一段时间执行一次的，比如每一分钟需要检查一些东西，诸如此类的任务就是由schedule来调度的。</p><h3 id="初始化ByteBufferPool"><a href="#初始化ByteBufferPool" class="headerlink" title="初始化ByteBufferPool"></a>初始化ByteBufferPool</h3><p>ByteBuffer是一个数组，分为两种_indirect ByteBuffer（分配在堆当中）和_directByteBuffer（分配在内存当中），相当于一个对象池，这其中的byteBuffer实际上是可以复用的。对象池的好处就是可以减少gc，减少new。在java中new是经过了绝对的优化的，性能还是比较高，关键是回收，新生代的回收会更加的频繁。如果自己写一个线程池，还不如通过new、gc的方式，因为线程池必须是线程安全的，所以好多线程在用，拿到对象和归还对象的时候必须是线程安全的，如果简单的加synchronize，除非是特别大的超级对象，性能可能比new，好一点，否则，如果用synchronize构造的线程池性能还不如new出来的。</p><h4 id="ArrayByteBufferPool"><a href="#ArrayByteBufferPool" class="headerlink" title="ArrayByteBufferPool"></a>ArrayByteBufferPool</h4><p>普通对象池中的对象都是对立的，我去拿任何一个对象都是一样的，都是等价的，但是ByteBufferPool不同，因为你可能需要2k的bytebuffer，也可能需要一个2m的bytebuffer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public ArrayByteBufferPool(int minSize, int increment, int maxSize)</span><br><span class="line">public ArrayByteBufferPool() &#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="number">0</span>,<span class="number">1024</span>,<span class="number">64</span>*<span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line">_direct=<span class="keyword">new</span> Bucket[maxSize/increment];</span><br><span class="line">_indirect=<span class="keyword">new</span> Bucket[maxSize/increment];</span><br></pre></td></tr></table></figure><p>minSize其实大小（最小的容量），increment增量，maxSize最大的大小</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>Bucket理解为篮子，一个篮子里面只放一中大小的buffer<br>因为1-63k不可能每一个都有，也许系统中只需要32k，这个时候1k、2k等等都不需要，所以有一个延迟加载的功能<br>_direct Bucket数组 _indirect Bucket数组<br>为每一个大小，新建一个Bucket 但不初始化ByteBuffer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int size=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (int i=<span class="number">0</span>;i&lt;_direct.length;i++) &#123;</span><br><span class="line">    size+=_inc;</span><br><span class="line">    _direct[i]=<span class="keyword">new</span> Bucket(size);</span><br><span class="line">    _indirect[i]=<span class="keyword">new</span> Bucket(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个Bucekt存放大小相同的所有的ByteBuffer<br>_size<br>bytebuffer大小<br>_queue<br>public final Queue<bytebuffer>_queue= new ConcurrentLinkedQueue&lt;&gt;();<br>初始化ByteBuPool的时候所有的Bucket都创建一遍，但是Bucket里面的Queue里面的内容都是延迟加载的</bytebuffer></p><h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h4><p>请求线程池。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ByteBuffer acquire(int size, boolean direct)</span><br></pre></td></tr></table></figure><p>size多大的内存，direct直接内存还是堆。<br>取得合适的Bucket 每个Bucket的大小不同，这里找到最合适的，取最接近的Buket大小<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bucket bucket = bucketFor(size,direct);</span><br></pre></td></tr></table></figure><p></p><p>从Bucket中取得ByteBuffer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = bucket==<span class="literal">null</span>?<span class="literal">null</span>:bucket._queue.poll();</span><br></pre></td></tr></table></figure><p>不存在则新建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (buffer == <span class="literal">null</span>) &#123;</span><br><span class="line">    int capacity = bucket==<span class="literal">null</span>?size:bucket._size;</span><br><span class="line">    buffer = direct ? BufferUtil.allocateDirect(capacity) : BufferUtil.allocate(capacity); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p>用完了释放掉，还给线程池。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> release(ByteBuffer buffer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer!=<span class="literal">null</span>) &#123;</span><br><span class="line">        Bucket bucket = bucketFor(buffer.capacity(),buffer.isDirect()); </span><br><span class="line">        <span class="keyword">if</span> (bucket!=<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            BufferUtil.clear(buffer);</span><br><span class="line">            bucket._queue.offer(buffer); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取得合适的Bucket</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bucket bucket = bucketFor(buffer.capacity(),buffer.isDirect());</span><br></pre></td></tr></table></figure><p>清空Buffer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferUtil.clear(buffer);</span><br></pre></td></tr></table></figure><p>归还Pool</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bucket._queue.offer(buffer);</span><br></pre></td></tr></table></figure><h4 id="例外处理"><a href="#例外处理" class="headerlink" title="例外处理"></a>例外处理</h4><p>如果申请的ByteBuffer过大或者过小，无法在POOL中满足，则可以申请成功，但无法归还给POOL。<br>加入目前只有1-64k的bytebuffer，但是我需要120k大小的bytebuffer，就需要申请。<br>可以看到上面的require没有的话会创建，但是因为无法归还，所以最后会被gc</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过学习ByteBufferPool，首先是对于所有的对象池都应该无锁的，如果有锁，还不如new出来，第二个就是bucket，因为bytebuffer大小是不确定的，所做的相应的处理。</p><h3 id="维护ConnectionFactory"><a href="#维护ConnectionFactory" class="headerlink" title="维护ConnectionFactory"></a>维护ConnectionFactory</h3><p>HttpConnectionFactory<br>用于创建连接， 比如Accept后，需要创建一个表示连接的对象</p><h3 id="取得可用CPU数量"><a href="#取得可用CPU数量" class="headerlink" title="取得可用CPU数量"></a>取得可用CPU数量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int cores = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure><p>我的系统中应该使用多少accept线程，应该使用多少个selector线程，都要由cores算出来的，这也就是对于高并发的程序来讲，你必须自适应cpu的数量，否则在2核的cpu上和64核的cpu上，完全没有办法很好的协调，</p><h3 id="更新acceptor数量"><a href="#更新acceptor数量" class="headerlink" title="更新acceptor数量"></a>更新acceptor数量</h3><p>根据cpu的数量更新acceptor数量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (acceptors &lt; <span class="number">0</span>)</span><br><span class="line">acceptors=<span class="built_in">Math</span>.max(<span class="number">1</span>, <span class="built_in">Math</span>.min(<span class="number">4</span>,cores/<span class="number">8</span>));</span><br></pre></td></tr></table></figure><p>它认为accept的数量应该是比较小的，上面可以发现不会超过四个。</p><h3 id="创建acceptor线程组"><a href="#创建acceptor线程组" class="headerlink" title="创建acceptor线程组"></a>创建acceptor线程组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_acceptors = <span class="keyword">new</span> Thread[acceptors];</span><br></pre></td></tr></table></figure><h3 id="初始化ServerConnectorManager"><a href="#初始化ServerConnectorManager" class="headerlink" title="初始化ServerConnectorManager"></a>初始化ServerConnectorManager</h3><p>继承自 SelectorManager</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_manager = <span class="keyword">new</span> ServerConnectorManager(getExecutor(), getScheduler(), selectors&gt;<span class="number">0</span>?selectors:<span class="built_in">Math</span>.max(<span class="number">1</span>,<span class="built_in">Math</span>.min(<span class="number">4</span>,Runtime.getRuntime().availableProcessors()/<span class="number">2</span>)));</span><br></pre></td></tr></table></figure><h4 id="保存selector线程数量"><a href="#保存selector线程数量" class="headerlink" title="保存selector线程数量"></a>保存selector线程数量</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.min(<span class="number">4</span>,Runtime.getRuntime().availableProcessors()/<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>最多也不超过四个</p><h2 id="设置port"><a href="#设置port" class="headerlink" title="设置port"></a>设置port</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connector.setPort(port);</span><br></pre></td></tr></table></figure><h2 id="关联Sever和Connector"><a href="#关联Sever和Connector" class="headerlink" title="关联Sever和Connector"></a>关联Sever和Connector</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setConnectors(<span class="keyword">new</span> Connector[]&#123;connector&#125;);</span><br></pre></td></tr></table></figure><h1 id="Server-start"><a href="#Server-start" class="headerlink" title="Server.start()"></a>Server.start()</h1><p>org.eclipse.jetty.server.Server<br>启动web服务器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WebAppContext context = <span class="keyword">new</span> WebAppContext();</span><br><span class="line">context.setContextPath(<span class="string">"/"</span>);</span><br><span class="line">context.setResourceBase(<span class="string">"./web/"</span>); context.setClassLoader(Thread.currentThread().getContextClassLoader()); server.setHandler(context);</span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure><h2 id="设置启动状态"><a href="#设置启动状态" class="headerlink" title="设置启动状态"></a>设置启动状态</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AbstractLifeCycle</span><br><span class="line">private <span class="keyword">void</span> setStarting() &#123;</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) LOG.debug(<span class="string">"starting &#123;&#125;"</span>,<span class="keyword">this</span>);</span><br><span class="line">    _state = __STARTING;</span><br><span class="line">    <span class="keyword">for</span> (Listener listener : _listeners)</span><br><span class="line">    listener.lifeCycleStarting(<span class="keyword">this</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动过程doStart"><a href="#启动过程doStart" class="headerlink" title="启动过程doStart()"></a>启动过程doStart()</h2><p>Server<br>启动整个server</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="keyword">void</span> doStart() throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//If the Server should be stopped when the jvm exits, register //with the shutdown handler thread.</span></span><br><span class="line">    <span class="keyword">if</span> (getStopAtShutdown())</span><br><span class="line">        ShutdownThread.register(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//Register the Server with the handler thread for receiving //remote stop commands</span></span><br><span class="line">    ShutdownMonitor.register(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//Start a thread waiting to receive "stop" commands. ShutdownMonitor.getInstance().start(); // initialize</span></span><br><span class="line">    LOG.info(<span class="string">"jetty-"</span> + getVersion()); HttpGenerator.setJettyVersion(HttpConfiguration.SERVER_VERSION); MultiException mex=<span class="keyword">new</span> MultiException();</span><br><span class="line">    <span class="comment">// check size of thread pool</span></span><br><span class="line">    SizedThreadPool pool = getBean(SizedThreadPool.class); int max=pool==<span class="literal">null</span>?<span class="number">-1</span>:pool.getMaxThreads();</span><br><span class="line">    int selectors=<span class="number">0</span>;</span><br><span class="line">    int acceptors=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mex.size()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (Connector connector : _connectors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connector <span class="keyword">instanceof</span> AbstractConnector) acceptors+=((AbstractConnector)connector).getAcceptors();</span><br><span class="line">            <span class="keyword">if</span> (connector <span class="keyword">instanceof</span> ServerConnector) selectors+=((ServerConnector)connector).getSelectorManager().getSelectorCount();</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    int needed=<span class="number">1</span>+selectors+acceptors; <span class="keyword">if</span> (max&gt;<span class="number">0</span> &amp;&amp; needed&gt;max)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="built_in">String</span>.format(<span class="string">"Insufficient threads: max=%d &lt; needed(acceptors=%d + selectors=%d + request=1)"</span>,max,acceptors,selectors));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">super</span>.doStart();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Throwable e) &#123;</span><br><span class="line">        mex.add(e); &#125;</span><br><span class="line">    <span class="comment">// start connectors last</span></span><br><span class="line">    <span class="keyword">for</span> (Connector connector : _connectors) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connector.start(); </span><br><span class="line">            &#125;<span class="keyword">catch</span>(Throwable e) &#123;</span><br><span class="line">                mex.add(e); </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDumpAfterStart()) dumpStdErr();</span><br><span class="line">    mex.ifExceptionThrow();</span><br><span class="line">    LOG.info(<span class="built_in">String</span>.format(<span class="string">"Started @%dms"</span>,Uptime.getUptime())); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册ShutdownMonitor"><a href="#注册ShutdownMonitor" class="headerlink" title="注册ShutdownMonitor"></a>注册ShutdownMonitor</h3><p>远程控制接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Register the Server with the handler thread for receiving //remote stop commands</span></span><br><span class="line">ShutdownMonitor.register(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//Start a thread waiting to receive "stop" commands. ShutdownMonitor.getInstance().start(); // initialize</span></span><br></pre></td></tr></table></figure><p>允许远程的将jetty的server关掉。</p><h3 id="获取化线程池"><a href="#获取化线程池" class="headerlink" title="获取化线程池"></a>获取化线程池</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check size of thread pool</span></span><br><span class="line">SizedThreadPool pool = getBean(SizedThreadPool.class);</span><br></pre></td></tr></table></figure><p>QueuedThreadPool</p><h3 id="设置selector数量"><a href="#设置selector数量" class="headerlink" title="设置selector数量"></a>设置selector数量</h3><p>根据Connector数量进行累计 大部分情况下，只有一个ServerConnector，因为每个connector都有selector</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Connector connector : _connectors) &#123;</span><br><span class="line">    <span class="keyword">if</span> (connector <span class="keyword">instanceof</span> AbstractConnector) acceptors+=((AbstractConnector)connector).getAcceptors();</span><br><span class="line">    <span class="keyword">if</span> (connector <span class="keyword">instanceof</span> ServerConnector) selectors+=((ServerConnector)connector).getSelectorManager().getSelectorCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>累计所有Connector的需求</p><h3 id="计算所需的所有线程数量"><a href="#计算所需的所有线程数量" class="headerlink" title="计算所需的所有线程数量"></a>计算所需的所有线程数量</h3><p>int needed=1+selectors+acceptors;</p><h4 id="如果大于默认的200则中断程序"><a href="#如果大于默认的200则中断程序" class="headerlink" title="如果大于默认的200则中断程序"></a>如果大于默认的200则中断程序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (max&gt;<span class="number">0</span> &amp;&amp; needed&gt;max)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="built_in">String</span>.format(<span class="string">"Insufficient threads: max=%d &lt; needed(acceptors=%d</span></span><br><span class="line"><span class="string">+ selectors=%d + request=1)"</span>,max,acceptors,selectors));</span><br></pre></td></tr></table></figure><p>因为如果光accept和selector线程都超过200说明性能很差了，没有必要再继续往下跑了。</p><h3 id="维护Bean"><a href="#维护Bean" class="headerlink" title="维护Bean"></a>维护Bean</h3><h4 id="启动QueuedThreadPool"><a href="#启动QueuedThreadPool" class="headerlink" title="启动QueuedThreadPool"></a>启动QueuedThreadPool</h4><p>doStart()<br>startThreads()建立需要的线程</p><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><p>Thread thread = newThread(_runnable);<br>_runnable _jobs中取任务并执行</p><h5 id="设置线程的属性"><a href="#设置线程的属性" class="headerlink" title="设置线程的属性"></a>设置线程的属性</h5><p>thread.setDaemon(isDaemon()); thread.setPriority(getThreadsPriority()); thread.setName(_name + “-“ + thread.getId()); _threads.add(thread);</p><h5 id="启动线程-thread-start"><a href="#启动线程-thread-start" class="headerlink" title="启动线程 thread.start();"></a>启动线程 thread.start();</h5><h4 id="启动WebAppContext"><a href="#启动WebAppContext" class="headerlink" title="启动WebAppContext"></a>启动WebAppContext</h4><p>如果需要使用，在此处启动，去做servlet规范所做的内容，这里就不展开讲了。</p><h3 id="启动Connector"><a href="#启动Connector" class="headerlink" title="启动Connector"></a>启动Connector</h3><h4 id="取得ConnectionFactory"><a href="#取得ConnectionFactory" class="headerlink" title="取得ConnectionFactory"></a>取得ConnectionFactory</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_defaultConnectionFactory = getConnectionFactory(_defaultProtocol);</span><br></pre></td></tr></table></figure><h4 id="创建selector线程并启动"><a href="#创建selector线程并启动" class="headerlink" title="创建selector线程并启动"></a>创建selector线程并启动</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; _selectors.length; i++) &#123;</span><br><span class="line">    ManagedSelector selector = newSelector(i); _selectors[i] = selector;</span><br><span class="line">    selector.start();</span><br><span class="line">    execute(<span class="keyword">new</span> NonBlockingThread(selector));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newSelector()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected ManagedSelector newSelector(int id) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ManagedSelector(id); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建Acceptor线程"><a href="#创建Acceptor线程" class="headerlink" title="创建Acceptor线程"></a>创建Acceptor线程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建几个accept线程</span></span><br><span class="line">_stopping=<span class="keyword">new</span> CountDownLatch(_acceptors.length); </span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; _acceptors.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Acceptor a = <span class="keyword">new</span> Acceptor(i); </span><br><span class="line">    addBean(a); </span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    getExecutor().execute(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Acceptor</p><h5 id="设置线程名字"><a href="#设置线程名字" class="headerlink" title="设置线程名字"></a>设置线程名字</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final Thread thread = Thread.currentThread(); </span><br><span class="line"><span class="built_in">String</span> name=thread.getName(); </span><br><span class="line">_name=<span class="built_in">String</span>.format(<span class="string">"%s-acceptor-%d@%x-</span></span><br><span class="line"><span class="string">%s"</span>,name,_acceptor,hashCode(),AbstractConnector.this.toString()); thread.setName(_name);</span><br></pre></td></tr></table></figure><h5 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h5><h5 id="将自己放入-acceptors数组"><a href="#将自己放入-acceptors数组" class="headerlink" title="将自己放入_acceptors数组"></a>将自己放入_acceptors数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (AbstractConnector.this) &#123;</span><br><span class="line">    _acceptors[_acceptor] = thread; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="监听端口"><a href="#监听端口" class="headerlink" title="监听端口"></a>监听端口</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (isAccepting()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            accept(_acceptor); &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAccepting())</span><br><span class="line">        LOG.warn(e);</span><br><span class="line">        <span class="keyword">else</span> LOG.ignore(e);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    thread.setName(name);</span><br><span class="line">    <span class="keyword">if</span> (_acceptorPriorityDelta!=<span class="number">0</span>) thread.setPriority(priority);</span><br><span class="line">    synchronized (AbstractConnector.this) &#123;</span><br><span class="line">        _acceptors[_acceptor] = <span class="literal">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    CountDownLatch stopping=_stopping; </span><br><span class="line">    <span class="keyword">if</span> (stopping!=<span class="literal">null</span>)</span><br><span class="line">    stopping.countDown(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServerConnector.accept()<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> accept(int acceptorID) throws IOException &#123;</span><br><span class="line">ServerSocketChannel serverChannel = _acceptChannel; <span class="keyword">if</span> (serverChannel != <span class="literal">null</span> &amp;&amp; serverChannel.isOpen()) &#123;</span><br><span class="line">    SocketChannel channel =serverChannel.accept();</span><br><span class="line">    accepted(channel); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在accept的地方等待</p><h4 id="没有Acceptor的情况"><a href="#没有Acceptor的情况" class="headerlink" title="没有Acceptor的情况"></a>没有Acceptor的情况</h4><p>channle默认是blocking的<br>如果acceptor数量为0，没有安排线程专门进行accept，则设置为非阻塞模式 若是非0，有专门线程进行accept，因此，为阻塞模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="keyword">void</span> doStart() throws Exception &#123;</span><br><span class="line">    <span class="keyword">super</span>.doStart();</span><br><span class="line">    <span class="keyword">if</span> (getAcceptors()==<span class="number">0</span>) &#123;</span><br><span class="line">        _acceptChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        _manager.acceptor(_acceptChannel); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动完毕"><a href="#启动完毕" class="headerlink" title="启动完毕"></a>启动完毕</h2><h1 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h1><h2 id="Accept成功"><a href="#Accept成功" class="headerlink" title="Accept成功"></a>Accept成功</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">void</span> accepted(SocketChannel channel) throws IOException &#123;</span><br><span class="line">    channel.configureBlocking(<span class="literal">false</span>); </span><br><span class="line">    Socket socket = channel.socket(); </span><br><span class="line">    configure(socket); </span><br><span class="line">    _manager.accept(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置为非阻塞模式"><a href="#设置为非阻塞模式" class="headerlink" title="设置为非阻塞模式"></a>设置为非阻塞模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="配置Socket"><a href="#配置Socket" class="headerlink" title="配置Socket"></a>配置Socket</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = channel.socket();</span><br><span class="line">configure(socket);</span><br></pre></td></tr></table></figure><h3 id="正式处理"><a href="#正式处理" class="headerlink" title="正式处理"></a>正式处理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SelectorManager _manager;</span><br><span class="line">_manager.accept(channel);</span><br></pre></td></tr></table></figure><h4 id="选择可用的ManagedSelector线程"><a href="#选择可用的ManagedSelector线程" class="headerlink" title="选择可用的ManagedSelector线程"></a>选择可用的ManagedSelector线程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private ManagedSelector chooseSelector() &#123;</span><br><span class="line">  <span class="comment">//The ++ increment here not atomic, but does not matter,</span></span><br><span class="line"><span class="comment">// so long as the value chages sometimes,then connections will</span></span><br><span class="line"><span class="comment">//be distributed over the available selectors</span></span><br><span class="line">    long s = _selectorIndex++;</span><br><span class="line">    int index = (int)(s % getSelectorCount());</span><br><span class="line">    <span class="keyword">return</span> _selectors[index]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个很有意思的注释，++并不是原子操作，但是不影响，因为这里只需要++就可以了，并不需要每次的数字搜不一样。</p><h4 id="ManagedSelector处理"><a href="#ManagedSelector处理" class="headerlink" title="ManagedSelector处理"></a>ManagedSelector处理</h4><p>ManagedSelector 是一个线程 封装了Selector 的使用</p><h5 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector.submit(selector.new Accept(channel, attachment));</span><br></pre></td></tr></table></figure><p>提交这个处理任务到ManagedSelector:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Queue&lt;Runnable&gt; _changes = <span class="keyword">new</span> ConcurrentArrayQueue&lt;&gt;(); _changes.offer(change);</span><br></pre></td></tr></table></figure><p>任务提交到了_chages这个队列中，ConcurrentArrayQueue这个队列是jetty中自己实现的。<br>ConcurrentArrayQueue<br>与ConcurrentLinkedQueue相似的性能，但直接保存元素 而不是node，因此需要更少的对象，更少的GC<br>因为ConcurrentLinkedQueue是一个链表，所以要有node，并且指向下一个node，而ConcurrentArrayQueue不是一个链表，所以需要更少的对象，更少的GC</p><h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><h3 id="ManagedSelector-run"><a href="#ManagedSelector-run" class="headerlink" title="ManagedSelector.run()"></a>ManagedSelector.run()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isRunning()) </span><br><span class="line">    select();</span><br></pre></td></tr></table></figure><h4 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h4><p>发现有任务就执行</p><h5 id="runChanges"><a href="#runChanges" class="headerlink" title="runChanges();"></a>runChanges();</h5><p>参见: 提交任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    private <span class="keyword">void</span> runChanges() &#123;</span><br><span class="line">    Runnable change;</span><br><span class="line">    <span class="keyword">while</span> ((change = _changes.poll()) != <span class="literal">null</span>)</span><br><span class="line">        runChange(change); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将_changes中的任务拿出来做执行。<br>runChange()<br>change.run();</p><p>Accept.run</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(_selector, <span class="number">0</span>, attachment); </span><br><span class="line">EndPoint endpoint = createEndPoint(channel, key); </span><br><span class="line">key.attach(endpoint);</span><br></pre></td></tr></table></figure><p>注册selector并将endpoint传给后面。</p><h5 id="select-1"><a href="#select-1" class="headerlink" title="select()"></a>select()</h5><p>runChanges实质上是将selector和channel连接到一起，接下来就是等待read或者write准备好</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int selected = _selector.select();</span><br></pre></td></tr></table></figure><h5 id="处理SelectionKey"><a href="#处理SelectionKey" class="headerlink" title="处理SelectionKey"></a>处理SelectionKey</h5><p>当发现任何一个selector可用的时候就会处理SelectionKey</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>&lt;SelectionKey&gt; selectedKeys = _selector.selectedKeys(); <span class="keyword">for</span> (SelectionKey key : selectedKeys)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (key.isValid()) &#123;</span><br><span class="line">        processKey(key); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug)</span><br><span class="line">        LOG.debug(<span class="string">"Selector loop ignoring invalid key for channel &#123;&#125;"</span>, key.channel());</span><br><span class="line">        <span class="built_in">Object</span> attachment = key.attachment(); </span><br><span class="line">        <span class="keyword">if</span> (attachment <span class="keyword">instanceof</span> EndPoint)</span><br><span class="line">        ((EndPoint)attachment).close(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">selectedKeys.clear();</span><br></pre></td></tr></table></figure><p>processKey()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">void</span> processKey(SelectionKey key) &#123;</span><br><span class="line">    <span class="built_in">Object</span> attachment = key.attachment(); <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (attachment <span class="keyword">instanceof</span> SelectableEndPoint) &#123;</span><br><span class="line">        ((SelectableEndPoint)attachment).onSelected(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        processConnect(key, (Connect)attachment); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key.isAcceptable())</span><br><span class="line">    &#123;</span><br><span class="line">        processAccept(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (CancelledKeyException x) &#123;</span><br><span class="line">        LOG.debug(<span class="string">"Ignoring cancelled key for channel &#123;&#125;"</span>, key.channel()); </span><br><span class="line">        <span class="keyword">if</span> (attachment <span class="keyword">instanceof</span> EndPoint)</span><br><span class="line">        closeNoExceptions((EndPoint)attachment); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        LOG.warn(<span class="string">"Could not process key for channel "</span> + key.channel(), x); </span><br><span class="line">        <span class="keyword">if</span> (attachment <span class="keyword">instanceof</span> EndPoint)</span><br><span class="line">        closeNoExceptions((EndPoint)attachment); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onSelected()<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> onSelected() &#123;</span><br><span class="line">    assert _selector.isSelectorThread();</span><br><span class="line">    int oldInterestOps = _key.interestOps();</span><br><span class="line">    int readyOps = _key.readyOps();</span><br><span class="line">    int newInterestOps = oldInterestOps &amp; ~readyOps; setKeyInterests(oldInterestOps, newInterestOps); </span><br><span class="line">    updateLocalInterests(readyOps, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (_key.isReadable())</span><br><span class="line">    getFillInterest().fillable(); <span class="keyword">if</span> (_key.isWritable())</span><br><span class="line">    getWriteFlusher().completeWrite(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>会使用新的线程进行HTTP业务处理 (提交到线程池)</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;本次笔记是对jetty，一个servlet容器，一个httpServer,内部的实现，因为代码量量比较多，不会从架构的方向介
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java高并发程序设计学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="高并发" scheme="http://mmmmmm.me/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发程序设计学习笔记（十）：并发调试和JDK8新特性</title>
    <link href="http://mmmmmm.me/2019-02-21.html"/>
    <id>http://mmmmmm.me/2019-02-21.html</id>
    <published>2019-02-21T02:20:02.000Z</published>
    <updated>2019-03-12T12:16:32.800Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="多线程调试的方法"><a href="#多线程调试的方法" class="headerlink" title="多线程调试的方法"></a>多线程调试的方法</h1><h2 id="使用Eclipse进行多线程调试"><a href="#使用Eclipse进行多线程调试" class="headerlink" title="使用Eclipse进行多线程调试"></a>使用Eclipse进行多线程调试</h2><p>看如下一段代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UnsafeArrayList</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> ArrayList al=<span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++) </span><br><span class="line">al.add(<span class="keyword">new</span> <span class="built_in">Object</span>());</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123; </span><br><span class="line">Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AddTask(),<span class="string">"t1"</span>);</span><br><span class="line">Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AddTask(),<span class="string">"t2"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">Thread t3=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">"t3"</span>);</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>ArrayList不是线程安全的。<br><img alt="" data-original="../images/15507583046171.png">))</p><p>把断点打到ArrayList的add方法处，发现还是在classLoader层面上的，并没有到达我们的应用层的实现。</p><p><img alt="" data-original="../images/15507583180697.png"><br>上面的条件断点只有当不是主线程的时候才会生效，通过上面的程序不难看出，整个应用层面和主线程并没有太大的关系，主要和线程t1 t2有关系</p><p><img alt="" data-original="../images/15507583423100.png"><br><img alt="" data-original="../images/15507583487268.png"><br><img alt="" data-original="../images/15507583554360.png"></p><p>通过打断点的方式复现问题发现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>是在ensureCapacityInternal(size + 1);这行出现了问题，t1中size变成了9，t2size++，这个时候t1并不知情，导致size不一致，·8导致报错。</p><h1 id="线程dump及分析"><a href="#线程dump及分析" class="headerlink" title="线程dump及分析"></a>线程dump及分析</h1><p>jstack 3992 可以导出当前虚拟机所有运行的线程。<br>在%JAVA_HOME%/bin目录下面（jstack 3992 ）</p><h2 id="分析死锁案例"><a href="#分析死锁案例" class="headerlink" title="分析死锁案例"></a>分析死锁案例</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码简介：东西南北四个小车形成的死锁<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">protected <span class="built_in">Object</span> myDirect;</span><br><span class="line"><span class="keyword">static</span> ReentrantLock south = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">static</span> ReentrantLock north = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">static</span> ReentrantLock west = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">static</span> ReentrantLock east = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">public DeadLock(<span class="built_in">Object</span> obj)&#123;</span><br><span class="line"><span class="keyword">this</span>.myDirect = obj;</span><br><span class="line"><span class="keyword">if</span> (myDirect == south) &#123;</span><br><span class="line"><span class="keyword">this</span>.setName(<span class="string">"south"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (myDirect == north) &#123;</span><br><span class="line"><span class="keyword">this</span>.setName(<span class="string">"north"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (myDirect == west) &#123;</span><br><span class="line"><span class="keyword">this</span>.setName(<span class="string">"west"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (myDirect == east) &#123;</span><br><span class="line"><span class="keyword">this</span>.setName(<span class="string">"east"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">if</span> (myDirect == south) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">west.lockInterruptibly();</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">south.lockInterruptibly();</span><br><span class="line">System.out.println(<span class="string">"car to south has passed"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">System.out.println(<span class="string">"car to south is killed"</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (west.isHeldByCurrentThread())</span><br><span class="line">west.unlock();</span><br><span class="line"><span class="keyword">if</span> (south.isHeldByCurrentThread())</span><br><span class="line">south.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (myDirect == north) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">east.lockInterruptibly();</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">north.lockInterruptibly();</span><br><span class="line">System.out.println(<span class="string">"car to south has passed"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">System.out.println(<span class="string">"car to south is killed"</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (east.isHeldByCurrentThread())</span><br><span class="line">east.unlock();</span><br><span class="line"><span class="keyword">if</span> (north.isHeldByCurrentThread())</span><br><span class="line">north.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (myDirect == west) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">north.lockInterruptibly();</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">west.lockInterruptibly();</span><br><span class="line">System.out.println(<span class="string">"car to south has passed"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">System.out.println(<span class="string">"car to south is killed"</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (north.isHeldByCurrentThread())</span><br><span class="line">north.unlock();</span><br><span class="line"><span class="keyword">if</span> (west.isHeldByCurrentThread())</span><br><span class="line">west.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (myDirect == east) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">south.lockInterruptibly();</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">east.lockInterruptibly();</span><br><span class="line">System.out.println(<span class="string">"car to south has passed"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">System.out.println(<span class="string">"car to south is killed"</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (south.isHeldByCurrentThread())</span><br><span class="line">south.unlock();</span><br><span class="line"><span class="keyword">if</span> (east.isHeldByCurrentThread())</span><br><span class="line">east.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">DeadLock car2South = <span class="keyword">new</span> DeadLock(south);</span><br><span class="line">DeadLock car2North = <span class="keyword">new</span> DeadLock(north);</span><br><span class="line">DeadLock car2West = <span class="keyword">new</span> DeadLock(west);</span><br><span class="line">DeadLock car2East = <span class="keyword">new</span> DeadLock(east);</span><br><span class="line">car2South.start();</span><br><span class="line">car2East.start();</span><br><span class="line">car2North.start();</span><br><span class="line">car2West.start();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>什么也没有输出，程序还在不断的运行着。</p><h3 id="jstack调试"><a href="#jstack调试" class="headerlink" title="jstack调试"></a>jstack调试</h3><h4 id="jps命令找到当前这个java的进程号"><a href="#jps命令找到当前这个java的进程号" class="headerlink" title="jps命令找到当前这个java的进程号"></a>jps命令找到当前这个java的进程号</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jps</span><br><span class="line"><span class="number">1682</span> Launcher</span><br><span class="line"><span class="number">1714</span> Jps</span><br><span class="line"><span class="number">1683</span> DeadLock</span><br><span class="line"><span class="number">1397</span> RemoteMavenServer</span><br><span class="line"><span class="number">1370</span></span><br></pre></td></tr></table></figure><h4 id="运行jstack命令"><a href="#运行jstack命令" class="headerlink" title="运行jstack命令"></a>运行jstack命令</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack <span class="number">1683</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -h</span><br></pre></td></tr></table></figure><p>发现-l参数可以看到更多的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -l <span class="number">1683</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">"west" #12 prio=5 os_prio=31 tid=0x00007ff6cc062000 nid=0x3d03 waiting on condition [0x0000700006ab7000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x000000079578bda8</span>&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:<span class="number">836</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">897</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">1222</span>)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">335</span>)</span><br><span class="line">at DeadLock.run(DeadLock.java:<span class="number">65</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- <span class="xml"><span class="tag">&lt;<span class="name">0x000000079578bd78</span>&gt;</span> (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">"north" #11 prio=5 os_prio=31 tid=0x00007ff6cd843800 nid=0x3f03 waiting on condition [0x00007000069b4000]</span></span><br><span class="line"><span class="xml">   java.lang.Thread.State: WAITING (parking)</span></span><br><span class="line"><span class="xml">at sun.misc.Unsafe.park(Native Method)</span></span><br><span class="line">- parking to wait for  &lt;0x000000079578bd78&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:897)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)</span><br><span class="line">at DeadLock.run(DeadLock.java:49)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- &lt;0x000000079578bdd8&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line"></span><br><span class="line">"east" #13 prio=5 os_prio=31 tid=0x00007ff6cd843000 nid=0x4103 waiting on condition [0x00007000068b1000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x000000079578bdd8&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:897)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)</span><br><span class="line">at DeadLock.run(DeadLock.java:81)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- &lt;0x000000079578bd48&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line"></span><br><span class="line">"south" #10 prio=5 os_prio=31 tid=0x00007ff6cd842000 nid=0x3b03 waiting on condition [0x00007000067ae000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x000000079578bd48&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:897)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)</span><br><span class="line">at DeadLock.run(DeadLock.java:33)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- &lt;0x000000079578bda8&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">- Found one Java-level deadlock:</span><br><span class="line">  =============================</span><br><span class="line">"west":</span><br><span class="line">  waiting for ownable synchronizer 0x000000079578bda8, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),</span><br><span class="line">  which is held by "south"</span><br><span class="line">"south":</span><br><span class="line">  waiting for ownable synchronizer 0x000000079578bd48, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),</span><br><span class="line">  which is held by "east"</span><br><span class="line">"east":</span><br><span class="line">  waiting for ownable synchronizer 0x000000079578bdd8, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),</span><br><span class="line">  which is held by "north"</span><br><span class="line">"north":</span><br><span class="line">  waiting for ownable synchronizer 0x000000079578bd78, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),</span><br><span class="line">  which is held by "west"</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">  ===================================================</span><br></pre></td></tr></table></figure><p>可以看到east中有这句话：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x000000079578bdd8</span>&gt;</span><br><span class="line"> south 中 Locked ownable synchronizers:<span class="xml"><span class="tag">&lt;<span class="name">0x000000079578bda8</span>&gt;</span> (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span></span><br></pre></td></tr></table></figure><p>可以知道east在等待0x000000079578bdd8，而0x000000079578bdd8是被south持有的。以此类推。</p><p>同样<br>“west”:waiting for ownable synchronizer 0x000000079578bda8, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),<br>which is held by “south”<br>也是能看出具体的原因。</p><p>末尾更清楚：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">=============================</span><br><span class="line"><span class="string">"west"</span>:</span><br><span class="line">  waiting <span class="keyword">for</span> ownable synchronizer <span class="number">0x000000079578bda8</span>, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),</span><br><span class="line">  which is held by <span class="string">"south"</span></span><br><span class="line"><span class="string">"south"</span>:</span><br><span class="line">  waiting <span class="keyword">for</span> ownable synchronizer <span class="number">0x000000079578bd48</span>, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),</span><br><span class="line">  which is held by <span class="string">"east"</span></span><br><span class="line"><span class="string">"east"</span>:</span><br><span class="line">  waiting <span class="keyword">for</span> ownable synchronizer <span class="number">0x000000079578bdd8</span>, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),</span><br><span class="line">  which is held by <span class="string">"north"</span></span><br><span class="line"><span class="string">"north"</span>:</span><br><span class="line">  waiting <span class="keyword">for</span> ownable synchronizer <span class="number">0x000000079578bd78</span>, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),</span><br><span class="line">  which is held by <span class="string">"west"</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br></pre></td></tr></table></figure><h1 id="JDK8对并发的新支持"><a href="#JDK8对并发的新支持" class="headerlink" title="JDK8对并发的新支持"></a>JDK8对并发的新支持</h1><h2 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h2><p>– 和AtomicInteger类似的使用方式<br>– 在AtomicInteger上进行了热点分离<br>– public void add(long x)<br>– public void increment()增加一<br>– public void decrement()减一<br>– public long sum() 因为是分离成16份，这里是一个求和的操作<br>– public long longValue() 同上<br>– public int intValue() Long转化成整形<br>性能比AtomicLong高很多，因为LongAdder是类似于HashMao的热点分离。<br>示意：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cas更新</span><br><span class="line">线程一--------&gt;cell1 |</span><br><span class="line">线程二--------&gt;cell2 |---sum----&gt;</span><br><span class="line">线程三--------&gt;cell3 |----求和---&gt;    value</span><br><span class="line">线程四--------&gt;cell4 |</span><br></pre></td></tr></table></figure><p></p><p>基本思想：<br>如上，当高并发的时候，将一个数分解成多个cell，线程一访问cell1，线程二访问cell2，以此类推，从而减少冲突的概率，但是当并发的线程数极少的时候，将数分成数组，则会消耗很大的性能，起到相反的作用，所以Longadd本身是有优化的，本身通过base数据（类似于AtomicLong），当发现一次冲突的时候就分成两个，在发现一次冲突分成四个，以此类推。</p><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p>– 实现CompletionStage接口(40余个方法)<br>– Java 8中对Future的增强版<br>– 支持流式调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stage.thenApply(x -&gt; square(x)).thenAccept(x -&gt; System.out.print(x)).thenRun(() -&gt; </span><br><span class="line">System.out.println())</span><br></pre></td></tr></table></figure><p>完成后得到通知</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AskThread</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      CompletableFuture &lt;Integer&gt; re = <span class="literal">null</span>;</span><br><span class="line">      public AskThread(CompletableFuture &lt;Integer&gt; re) &#123;</span><br><span class="line">      <span class="keyword">this</span>.re = re</span><br><span class="line">  &#125;</span><br><span class="line">      @Override</span><br><span class="line">      public <span class="keyword">void</span> run() [</span><br><span class="line">      int myRe = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//返回future值的平方</span></span><br><span class="line">      myRe = re.get) * re.get();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(myRe);</span><br><span class="line">      &#125;</span><br><span class="line">      public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">      final CompletableFuture &lt;Integer&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">      <span class="comment">//将future传到线程中</span></span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> AskThread(future)).start();</span><br><span class="line">      <span class="comment">//模拟长时间的计算过程</span></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"> <span class="comment">//告知完成结果</span></span><br><span class="line">      future.complete(<span class="number">60</span>);</span><br></pre></td></tr></table></figure><p>跟前面的future模式不同的是，前面的future模式完成是系统自己完成的，这里的完成是能够开发者自己定义的，如上面的代码future.complete(60);</p><h3 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> Integer calc(Integer para) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 模拟一个长时间的执行</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> para*para;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException, ExecutionException &#123; </span><br><span class="line">final CompletableFuture&lt;Integer&gt; future =</span><br><span class="line"><span class="comment">//supplyAsync工厂方法，能够得到一个CompletableFuture的实例，</span></span><br><span class="line"><span class="comment">//并不是通过new出来的，内部会帮我们创建一个，能够直接得到一个实例，然后调动calc</span></span><br><span class="line"><span class="comment">//calc中的执行类似上面的代码，return平法。</span></span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; calc(<span class="number">50</span>)); </span><br><span class="line">System.out.println(future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法："><a href="#工厂方法：" class="headerlink" title="工厂方法："></a>工厂方法：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier);</span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor); <span class="keyword">static</span> CompletableFuture&lt;Void&gt; runAsync(Runnable runnable);</span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor);</span><br></pre></td></tr></table></figure><p>Executor executor就是线程池，supplyAsync和runAsync的区别是supplyAsync是有返回值的，runAsync就是一个单纯Runnable接口，没有返回值。</p><h3 id="流式调用"><a href="#流式调用" class="headerlink" title="流式调用"></a>流式调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> Integer calc(Integer para) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 模拟一个长时间的执行</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> para*para;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException, ExecutionException &#123; </span><br><span class="line">CompletableFuture&lt;Void&gt; fu=CompletableFuture.supplyAsync(() -&gt; calc(<span class="number">50</span>))</span><br><span class="line">.thenApply((i)-&gt;Integer.toString(i)) .thenApply((str)-&gt;<span class="string">"\""</span>+str+<span class="string">"\""</span>) .thenAccept(System.out::println);</span><br><span class="line">fu.get(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>calc返回平方操作，Integer.toString转化成String，thenApply((str)-&gt;”\””+str+”\””) 在String两边加引号，thenAccept(System.out::println)输出结果。fu.get(); 看看得到结果了没有。</p><h3 id="组合多个CompletableFuture"><a href="#组合多个CompletableFuture" class="headerlink" title="组合多个CompletableFuture"></a>组合多个CompletableFuture</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenCompose(<span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> Integer calc(Integer para) &#123;</span><br><span class="line"><span class="keyword">return</span> para/<span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException, ExecutionException &#123; </span><br><span class="line">CompletableFuture&lt;Void&gt; fu =</span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; calc(<span class="number">50</span>)) .thenCompose((i)-&gt;CompletableFuture.supplyAsync(() -&gt; calc(i))) .thenApply((str)-&gt;<span class="string">"\""</span> + str + <span class="string">"\""</span>).thenAccept(System.out::println);</span><br><span class="line">fu.get(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thenCompose除以四，就是五十先除以四，再除以四。<br>结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"12"</span></span><br></pre></td></tr></table></figure><h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p>– 读写锁的改进<br>– 读不阻塞写<br>读的时候发生了写，不应该不让写操作，而应该重读。<br>因为：<br>当读太多的时候，可能出现写不进去的现象，写饥饿。<br>stemp时间戳</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">private double x, y;</span><br><span class="line">private final StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"><span class="keyword">void</span> move(double deltaX, double deltaY) &#123; <span class="comment">// an exclusively locked method long stamp = sl.writeLock();</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">x += deltaX;</span><br><span class="line">y += deltaY;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">sl.unlockWrite(stamp);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">double distanceFromOrigin() &#123; <span class="comment">// A read-only method </span></span><br><span class="line"><span class="comment">//tryOptimisticRead乐观读，即上面提到的思想</span></span><br><span class="line">long stamp = sl.tryOptimisticRead();</span><br><span class="line">double currentX = x, currentY = y; </span><br><span class="line"><span class="comment">//验证stemp，如果读的过程中，进行了写操作，返回零或者其他的数，拒绝操作</span></span><br><span class="line"><span class="comment">//如果在读x的过程中修改了y，看到上面的move函数，对sl加锁解锁，每次的stemp值都是不一样的</span></span><br><span class="line"><span class="comment">//和这里的对比</span></span><br><span class="line"><span class="keyword">if</span> (!sl.validate(stamp)) &#123;</span><br><span class="line"><span class="comment">//如果不支持乐观读，就用最原始的读写锁的方法。</span></span><br><span class="line">stamp = sl.readLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">currentX = x;</span><br><span class="line">currentY = y; </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">sl.unlockRead(stamp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StampedLock的实现思想"><a href="#StampedLock的实现思想" class="headerlink" title="StampedLock的实现思想"></a>StampedLock的实现思想</h3><p>– CLH自旋锁<br>– 锁维护一个等待线程队列，所有申请锁，但是没有成功的线程都记录在这个队列中。每一个节点(一个 节点代表一个线程)，保存一个标记位(locked)，用于判断当前线程是否已经释放锁。<br>– 当一个线程试图获得锁时，取得当前等待队列的尾部节点作为其前序节点。并使用类似如下代码判断前 序节点是否已经成功释放锁:<br>示意代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (pred.locked) &#123; &#125;</span><br></pre></td></tr></table></figure><p>StampedLock的实现思想<br>– 不会进行无休止的自旋，会在在若干次自旋后挂起线程<br>上面（while）只是一个示意的代码，不会无休止的自旋<br><img alt="" data-original="../images/15507583741088.png"></p><p>简单来说就是每次执行自己的时候先看看前面的锁释放了没有，以此类推。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;多线程调试的方法&quot;&gt;&lt;a href=&quot;#多线程调试的方法&quot; class=&quot;headerlink&quot; title=&quot;多
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java高并发程序设计学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="高并发" scheme="http://mmmmmm.me/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发程序设计学习笔记（九）：锁的优化和注意事项</title>
    <link href="http://mmmmmm.me/2019-02-18.html"/>
    <id>http://mmmmmm.me/2019-02-18.html</id>
    <published>2019-02-18T11:20:02.000Z</published>
    <updated>2019-03-12T12:37:53.453Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><p><strong><font color="red">注意：只要是持有锁的，性能就会比无锁要差，不论如何优化。</font></strong></p><h1 id="锁优化的思路和方法"><a href="#锁优化的思路和方法" class="headerlink" title="锁优化的思路和方法"></a>锁优化的思路和方法</h1><p>注意tryLock是无锁的，只是去尝试下，拿不到就会接着做其他的事情，Lock是有锁的操作。</p><h2 id="减少锁持有时间"><a href="#减少锁持有时间" class="headerlink" title="减少锁持有时间"></a>减少锁持有时间</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public synchronized <span class="keyword">void</span> syncMethod()&#123; </span><br><span class="line">othercode1();</span><br><span class="line">mutextMethod();</span><br><span class="line">othercode2(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> syncMethod2()&#123; </span><br><span class="line">othercode1();</span><br><span class="line">synchronized(<span class="keyword">this</span>)&#123;</span><br><span class="line">mutextMethod(); </span><br><span class="line">&#125;</span><br><span class="line">othercode2(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值同步相关的代码，无关的代码就不要同步。</p><h2 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h2><p>将大对象，拆成小对象，大大增加并行度，降低锁竞争 ，原来可能是对一个很大的对象加锁。<br>偏向锁，轻量级锁成功率提高<br>ConcurrentHashMap（就是将大对象拆分成小对象）<br>HashMap的同步实现<br>– Collections.synchronizedMap(Map&lt;K,V&gt; m)<br>– 返回SynchronizedMap对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public V get(<span class="built_in">Object</span> key) &#123;</span><br><span class="line">synchronized (mutex) &#123;<span class="keyword">return</span> m.get(key);&#125; </span><br><span class="line">&#125;</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">synchronized (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap<br>– 若干个Segment :Segment&lt;K,V&gt;[] segments<br>– Segment中维护HashEntry&lt;K,V&gt;<br>– put操作时<br>• 先定位到Segment，锁定一个Segment，执行put<br>在减小锁粒度后， ConcurrentHashMap允许若干个线程同时进入<br>就是讲hashmap拆分成多个hashMap，即拆分成多个对象。</p><h2 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h2><p>即读写分离<br>根据功能进行锁分离<br>ReadWriteLock<br>读多写少的情况，可以提高性能<br>| | 读锁 |写锁|<br>|–|–|–|<br>| 读锁 | 可访问 |不可访问 |<br>|写锁|不可访问|不可访问 |<br>读操作和读操作是不需要阻塞的，将阻塞的并发变成了无等待的并发。</p><p>读写分离思想可以延伸，只要操作互不影响，锁就可以分离<br>LinkedBlockingQueue<br>– 队列<br>– 链表<br>就像队列put和take操作，一个在头部一个在尾部互不影响</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完 公共资源后，应该立即释放锁。只有这样，等待在这个锁上的其他线程才能尽早的获得资源执行 任务。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗 系统宝贵的资源，反而不利于性能的优化</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> demoMethod()&#123; </span><br><span class="line">synchronized(lock)&#123;</span><br><span class="line"> <span class="comment">//do sth.</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//做其他不需要的同步的工作，但能很快执行完毕 </span></span><br><span class="line">synchronized(lock)&#123;</span><br><span class="line"><span class="comment">//do sth. </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该转化成<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> demoMethod()&#123; <span class="comment">//整合成一次锁请求</span></span><br><span class="line">synchronized(lock)&#123; </span><br><span class="line"><span class="comment">//do sth.</span></span><br><span class="line"><span class="comment">//做其他不需要的同步的工作，但能很快执行完毕 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>不断的加锁释放锁也是会消耗很大的性能的，这个时候就应该锁粗化，但是前提上面的代码中的其他不需要同步的工作是能够很快的执行完毕的，否则不应该所粗化。</p><h3 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;CIRCLE;i++)&#123; </span><br><span class="line">synchronized(lock)&#123;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(lock)&#123; </span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;CIRCLE;i++)&#123;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作（jdk自身的优化）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span> args[]) throws InterruptedException &#123; </span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; CIRCLE; i++) &#123;</span><br><span class="line">craeteStringBuffer(<span class="string">"JVM"</span>, <span class="string">"Diagnosis"</span>); </span><br><span class="line">&#125;</span><br><span class="line">long bufferCost = System.currentTimeMillis() - start;</span><br><span class="line">System.out.println(<span class="string">"craeteStringBuffer: "</span> + bufferCost + <span class="string">" ms"</span>); </span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="built_in">String</span> craeteStringBuffer(<span class="built_in">String</span> s1, <span class="built_in">String</span> s2) &#123; </span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(s1);</span><br><span class="line">sb.append(s2);</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上面的代码，在jdk中有许多类似StringBuffer这样的类，本身就是在锁的基础上封装的，自己是线程安全的，我用了它的某些方法（append等）后，发现sb这个变量是局部变量，不会被其他的线程访问到，并不需要为了线程安全，而进行锁的操作。</p><p>解决办法:<br>CIRCLE= 2000000</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</span><br><span class="line">   craeteStringBuffer: <span class="number">187</span> ms</span><br><span class="line">-server -XX:+DoEscapeAnalysis -XX:-EliminateLocks</span><br><span class="line">craeteStringBuffer: <span class="number">254</span> ms</span><br></pre></td></tr></table></figure><p>自私server模式下能有更多的操作，-XX:+DoEscapeAnalysis ：逃逸分析，分析sb这个变量会不会被其他的线程访问到，如果会怎样，如果会不怎样，+EliminateLocks：经过逃逸分析，看是否打开锁消除。<br>通过上面的时间显示，进行了锁消除，确实性能有很大的提升。</p><h1 id="虚拟机内部的锁优化-当使用synchronize关键字的时候里面会做那些事情"><a href="#虚拟机内部的锁优化-当使用synchronize关键字的时候里面会做那些事情" class="headerlink" title="虚拟机内部的锁优化(当使用synchronize关键字的时候里面会做那些事情)"></a>虚拟机内部的锁优化(当使用synchronize关键字的时候里面会做那些事情)</h1><h2 id="对象头Mark"><a href="#对象头Mark" class="headerlink" title="对象头Mark"></a>对象头Mark</h2><p>每个对象都有一个对象头<br>Mark Word，对象头的标记，32位（32位操作系统中）<br>描述对象的hash、锁信息，垃圾回收标记，年龄<br>– 指向锁记录的指针<br>– 指向monitor的指针<br>– GC标记<br>– 偏向锁线程ID</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>大部分情况是没有竞争的，所以可以通过偏向来提高性能<br>所谓的偏向，就是偏心，即锁会偏向于当前已经占有锁的线程<br>将对象头Mark的标记设置为偏向，并将线程ID写入对象头Mark<br>只要没有竞争，获得偏向锁的线程，在将来进入同步块，不需要做同步<br>当其他线程请求相同的锁时，偏向模式结束<br>-XX:+UseBiasedLocking – 默认启用<br>在竞争激烈的场合，偏向锁会增加系统负担，就像如果每次都偏向然后紧接着又结束了，任何事情都是有两面性的。</p><h3 id="举个栗子-2"><a href="#举个栗子-2" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> List&lt;Integer&gt; numberList =<span class="keyword">new</span> Vector&lt;Integer&gt;(); public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">long begin=System.currentTimeMillis(); </span><br><span class="line">int count=<span class="number">0</span>;</span><br><span class="line">int startnum=<span class="number">0</span>; <span class="keyword">while</span>(count&lt;<span class="number">10000000</span>)&#123;</span><br><span class="line">numberList.add(startnum); startnum+=<span class="number">2</span>;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">long end=System.currentTimeMillis(); </span><br><span class="line">System.out.println(end-begin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本例中，使用偏 向锁，可以获得 5%以上的性能 提升</span></span><br><span class="line">-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=<span class="number">0</span></span><br><span class="line">-XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure><p>BiasedLockingStartupDelay是系统启动的几秒之内金童偏向锁，因为在系统刚刚启动的时候确实会有许多的锁竞争，虚拟机会提供一个默认的时间，这里设置为0，是因为需要写的代码很少，能够在很短的时间内执行完毕，所以将BiasedLockingStartupDelay设置为0。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>BasicObjectLock<br>– 嵌入在线程栈中的对象<br>如果偏向锁失败，就会去执行轻量级锁的操作。<br>普通的锁处理性能不够理想，轻量级锁是一种快速的锁定方法。<br><strong><font color="red">操作系统层面的锁性能是比较差的，jvm相当于操作系统上的一个应用，jvm级别的锁能够提高性能。</font></strong><br>如果对象没有被锁定<br>– 将对象头的Mark指针保存到锁对象中<br>– 将对象头设置为指向锁的指针(在线程栈空间中)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock-&gt;set_displaced_header(mark);</span><br><span class="line"><span class="keyword">if</span> (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;mark_addr(), mark))</span><br><span class="line">&#123;</span><br><span class="line">TEVENT (slow_enter: release stacklock) ;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lock位于线程栈中<br><strong><font color="red">注意上面说的，对象头mark保存在锁中，锁位于线程栈中，对象头设置为锁的指针，所以如果对象头指向了线程栈中，则表示持有这把锁，上面的指令同样是cas操作。</font></strong></p><p>如果轻量级锁失败，表示存在竞争，升级为重量级锁(常规锁，操作系统层面的锁)<br>在没有锁竞争的前提下，减少传统锁使用OS互斥量产生的性能损耗<br>在竞争激烈时，轻量级锁会多做很多额外操作，导致性能下降</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><h3 id="举个栗子-3"><a href="#举个栗子-3" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>concurrentHashMao中的put就是线程的锁被其他人拿走之后，不急着挂起自己，而是执行几次trylocak操作，因为一旦挂起会消耗八万个时光周期。不断的循环trylock，当多次循环之后还是没有拿到，就挂起。</p><p>当竞争存在时，如果线程可以很快获得锁，那么可以不在OS层挂起线程，让线程做几个空操作( 自旋)<br>JDK1.6中-XX:+UseSpinning开启<br>JDK1.7中，去掉此参数，改为内置实现<br>如果同步块很长，自旋失败，会降低系统性能<br>如果同步块很短，自旋成功，节省线程挂起切换时间，提升系统性能</p><h2 id="偏向锁，轻量级锁，自旋锁总结"><a href="#偏向锁，轻量级锁，自旋锁总结" class="headerlink" title="偏向锁，轻量级锁，自旋锁总结"></a>偏向锁，轻量级锁，自旋锁总结</h2><p>不是Java语言层面的锁优化方法，是虚拟机层面的优化<br>内置于JVM中的获取锁的优化方法和获取锁的步骤<br>– 偏向锁可用会先尝试偏向锁<br>– 轻量级锁可用会先尝试轻量级锁<br>– 以上都失败，尝试自旋锁<br>– 再失败，尝试普通锁，使用OS互斥量在操作系统层挂起</p><h1 id="一个错误使用锁的案例"><a href="#一个错误使用锁的案例" class="headerlink" title="一个错误使用锁的案例"></a>一个错误使用锁的案例</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">IntegerLock</span> </span>&#123; </span><br><span class="line"><span class="keyword">static</span> Integer i=<span class="number">0</span>;</span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123; </span><br><span class="line">public <span class="keyword">void</span> run()&#123;</span><br><span class="line"><span class="keyword">for</span>(int k=<span class="number">0</span>;k&lt;<span class="number">100000</span>;k++)&#123; </span><br><span class="line">synchronized(i)&#123;</span><br><span class="line">i++; </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123; AddThread t1=<span class="keyword">new</span> AddThread();</span><br><span class="line">AddThread t2=<span class="keyword">new</span> AddThread(); </span><br><span class="line">t1.start();</span><br><span class="line">t2.start(); </span><br><span class="line">t1.join();</span><br><span class="line">t2.join(); </span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这句话：synchronized(i)<br>其中的i是Integer类型的，i++操作一般是在int类型上，Integer类型会有自动的拆箱装箱的操作，并不是将i++的值直接赋值给了i，而是new了一个新的对象，然后将i指向它，所以这里synchronized(i)中的i不能确定是代码中的i还是new的一个新的Integer对象，从而不能保证拿到的是同一个对象，所以这段代码并不是线程安全的。</p><h1 id="ThreadLocal及其源码分析"><a href="#ThreadLocal及其源码分析" class="headerlink" title="ThreadLocal及其源码分析"></a>ThreadLocal及其源码分析</h1><p>把锁去掉，为每一个线程都提供一个对象实例，不同的线程，都去访问自己的对象，而不去访问别人的对象，这个时候锁就完全没有必要等待。</p><h2 id="举个栗子-4"><a href="#举个栗子-4" class="headerlink" title="举个栗子"></a>举个栗子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">static</span> final SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>); </span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">int i=<span class="number">0</span>;</span><br><span class="line">public ParseDate(int i)&#123;<span class="keyword">this</span>.i=i;&#125; public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">Date</span> t=sdf.parse(<span class="string">"2015-03-29 19:29:"</span>+i%<span class="number">60</span>); </span><br><span class="line">System.out.println(i+<span class="string">":"</span>+t);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">ExecutorService es=Executors.newFixedThreadPool(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">es.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleDateFormat不是线程安全的，被多线程访问是容易抛出一些异常，不能正常的工作。</p><h3 id="为每一个线程分配一个实例"><a href="#为每一个线程分配一个实例" class="headerlink" title="为每一个线程分配一个实例"></a>为每一个线程分配一个实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; tl=<span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;(); public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">int i=<span class="number">0</span>;</span><br><span class="line">public ParseDate(int i)&#123;<span class="keyword">this</span>.i=i;&#125; public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(tl.get()==<span class="literal">null</span>)&#123;</span><br><span class="line">tl.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Date</span> t=tl.get().parse(<span class="string">"2015-03-29 19:29:"</span>+i%<span class="number">60</span>); </span><br><span class="line">System.out.println(i+<span class="string">":"</span>+t);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">ExecutorService es=Executors.newFixedThreadPool(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">es.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如果使用共享实例，起不到效果"><a href="#如果使用共享实例，起不到效果" class="headerlink" title="如果使用共享实例，起不到效果"></a>如果使用共享实例，起不到效果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; tl=<span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();</span><br><span class="line">private <span class="keyword">static</span> final SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>); public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">int i=<span class="number">0</span>;</span><br><span class="line">public ParseDate(int i)&#123;<span class="keyword">this</span>.i=i;&#125; </span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(tl.get()==<span class="literal">null</span>)&#123;</span><br><span class="line">tl.set(sdf ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Date</span> t=tl.get().parse(<span class="string">"2015-03-29 19:29:"</span>+i%<span class="number">60</span>);</span><br><span class="line">System.out.println(i+<span class="string">":"</span>+t); </span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">ExecutorService es=Executors.newFixedThreadPool(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">es.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上述代码中tl.set(sdf ); 正确的应该是tl.set(new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”));<br>每次都new一个新的实例，只有这样才能起到作用，否则锁一个的threadlocal里面存的还是一个对象，还是会出现线程不安全的现象。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"> public <span class="keyword">void</span> set(T value) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//拿到ThreadlocalMap</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line"><span class="comment">//可以看到Threadlocal本身就隶属于这个线程</span></span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在当前的线程中，也就是每个线程中都有自己的map</span></span><br><span class="line"> ThreadLocal.ThreadLocalMap threadLocals = <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">//key是ThreadLocal本身，value就是设进去的值</span></span><br><span class="line"> private <span class="keyword">void</span> set(ThreadLocal&lt;?&gt; key, <span class="built_in">Object</span> value) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">            <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">            <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">            <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            int len = tab.length;</span><br><span class="line">            int i = key.threadLocalHashCode &amp; (len<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="literal">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            int sz = ++size;</span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//nextIndex其实是i++的操作，因为get出来，发现如果有了会有hash冲突，这个时候</span></span><br><span class="line">  <span class="comment">//下标加一，再赋值。</span></span><br><span class="line">  private <span class="keyword">static</span> int nextIndex(int i, int len) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//执行清理的工作，可以看到并不是全部清理，只是n &gt;&gt;&gt;= 1右移操作，清理部分。</span></span><br><span class="line">  <span class="comment">//前面知道Entry是弱引用的，只有当entry！=null并且e.get（）--》ThreadLocal是null的时候</span></span><br><span class="line">  <span class="comment">//通过expungeStaleEntry方法将tab[staleSlot].value = null;</span></span><br><span class="line">  <span class="comment">//tab[staleSlot] = null;这两个置为null</span></span><br><span class="line">private boolean cleanSomeSlots(int i, int n) &#123;</span><br><span class="line">            boolean removed = <span class="literal">false</span>;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            int len = tab.length;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">                Entry e = tab[i];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">                    n = len;</span><br><span class="line">                    removed = <span class="literal">true</span>;</span><br><span class="line">                    i = expungeStaleEntry(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> removed;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//可以看到 ThreadLocalMap.Entry e = map.getEntry(this);</span></span><br><span class="line"><span class="comment">//也是传的ThreadLocal本身</span></span><br><span class="line">public T get() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里注意Entry是继承于弱引用的，也就是没有数据引用到这个对象，这个对象就会被系统释放掉。</span></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            <span class="built_in">Object</span> value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, <span class="built_in">Object</span> v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;注意：只要是持有锁的，性能就会比无锁要差，不论如何优化。&lt;/font&gt;&lt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java高并发程序设计学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="高并发" scheme="http://mmmmmm.me/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发程序设计学习笔记（八）：NIO和AIO</title>
    <link href="http://mmmmmm.me/2019-02-16.html"/>
    <id>http://mmmmmm.me/2019-02-16.html</id>
    <published>2019-02-16T11:20:02.000Z</published>
    <updated>2019-03-12T12:16:32.833Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="什么是NIO"><a href="#什么是NIO" class="headerlink" title="什么是NIO"></a>什么是NIO</h1><p>NIO是New I/O的简称，与旧式的基于流的I/O方法相对，从名字看，它表示新的一套Java I/O标 准。它是在Java 1.4中被纳入到JDK中的，并具有以下特性:<br>– NIO是基于块(Block,硬盘上的块)的，它以块为基本单位处理数据，传统的是基于字节的，最小单位是字节，NIO最小单位是块。<br>– 为所有的原始类型提供(Buffer)缓存支持<br>– 增加通道(Channel)对象，作为新的原始 I/O 抽象<br>– 支持锁和内存映射文件的文件访问接口，拿文件系统来实现锁，就是我们平常的.log文件。<br>– 提供了基于Selector的异步网络I/O</p><h1 id="Buffer-amp-amp-Channel"><a href="#Buffer-amp-amp-Channel" class="headerlink" title="Buffer &amp;&amp; Channel"></a>Buffer &amp;&amp; Channel</h1><p><img alt="" data-original="../images/15503116585564.png"></p><p>文件的读写都是通过Buffer读写到Channel，然后再到文件。Channel左边就是对应的我们的文件。</p><h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p>每个基本类型都有对应的buffer<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span></span><br><span class="line">-Buffer</span><br><span class="line">-ByteBuffer</span><br><span class="line">-CharBuffer</span><br><span class="line">-DoubleBuffer</span><br><span class="line">-FloatBUffer</span><br><span class="line">-IntBuffer</span><br><span class="line">-LongBuffer</span><br><span class="line">-ShortBuffer</span><br></pre></td></tr></table></figure><p></p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"d:\\temp_buffer.tmp"</span>)); </span><br><span class="line"><span class="comment">//通过InputStream得到channel。</span></span><br><span class="line">FileChannel fc=fin.getChannel();</span><br><span class="line"><span class="comment">//通过ByteBuffer分配1k的大小的buffer</span></span><br><span class="line">ByteBuffer byteBuffer=ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">//通过channel将1k大小的数据读到buffer中 </span></span><br><span class="line">fc.read(byteBuffer);</span><br><span class="line">fc.close(); </span><br><span class="line"><span class="comment">//对buffer中的数据进行读写转换，后面可能要对buffer中的数据进行读取。</span></span><br><span class="line">byteBuffer.flip();</span><br></pre></td></tr></table></figure><h2 id="NIO复制文件"><a href="#NIO复制文件" class="headerlink" title="NIO复制文件"></a>NIO复制文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> nioCopyFile(<span class="built_in">String</span> resource, <span class="built_in">String</span> destination) throws IOException &#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(resource); </span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destination); </span><br><span class="line">FileChannel readChannel = fis.getChannel();<span class="comment">//读文件通道</span></span><br><span class="line">FileChannel writeChannel = fos.getChannel();<span class="comment">//写文件通道</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>); <span class="comment">//读入数据缓存</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">buffer.clear();</span><br><span class="line">int len = readChannel.read(buffer); <span class="comment">//读入数据</span></span><br><span class="line"><span class="comment">//len读到数据的大小</span></span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//读取完毕 </span></span><br><span class="line">&#125;</span><br><span class="line">buffer.flip();</span><br><span class="line">writeChannel.write(buffer); </span><br><span class="line"><span class="comment">//写入文件</span></span><br><span class="line">&#125; </span><br><span class="line">readChannel.close(); </span><br><span class="line">writeChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Buffer中有3个重要的参数"><a href="#Buffer中有3个重要的参数" class="headerlink" title="Buffer中有3个重要的参数:"></a>Buffer中有3个重要的参数:</h2><p>位置(position)、容量(capactiy)和上限(limit)<br>|参数 |写模式 | 读模式|<br>|–|–|–|<br>|位置 |当前缓冲区的位置，将从position的下一个位置写数据 |当前缓冲区读取的位置，将从此位置后，读取数据|<br>|容量|缓存区的总容量上限|缓存区的总容量上限|<br>|上限|缓冲区的实际上线，他总是小于等于容量。通常情况下和容量相等|代表刻度的总容量，和上次写入的数据量相等|</p><h3 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer b=ByteBuffer.allocate(<span class="number">15</span>); <span class="comment">//15个字节大小的缓冲区 </span></span><br><span class="line">System.out.println(<span class="string">"limit="</span>+b.limit()+<span class="string">" capacity="</span>+b.capacity()+<span class="string">" position="</span>+b.position()); </span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123; <span class="comment">//存入10个字节数据</span></span><br><span class="line">b.put((byte)i); </span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"limit="</span>+b.limit()+<span class="string">" capacity="</span>+b.capacity()+<span class="string">" position="</span>+b.position());</span><br><span class="line">b.flip(); <span class="comment">//重置position </span></span><br><span class="line">System.out.println(<span class="string">"limit="</span>+b.limit()+<span class="string">" capacity="</span>+b.capacity()+<span class="string">" position="</span>+b.position());</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">System.out.print(b.get());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"limit="</span>+b.limit()+<span class="string">" capacity="</span>+b.capacity()+<span class="string">" position="</span>+b.position()); b.flip();</span><br><span class="line">System.out.println(<span class="string">"limit="</span>+b.limit()+<span class="string">" capacity="</span>+b.capacity()+<span class="string">" position="</span>+b.position());</span><br></pre></td></tr></table></figure><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><h4 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h4><p><img alt="" data-original="../images/15503116715775.png"></p><h4 id="存入10byte"><a href="#存入10byte" class="headerlink" title="存入10byte"></a>存入10byte</h4><p><img alt="" data-original="../images/15503116881176.png"></p><h4 id="flip"><a href="#flip" class="headerlink" title="flip"></a>flip</h4><p><img alt="" data-original="../images/15503117143136.png"></p><p>该操作会重置position，通常，将buffer从写模式转换为读 模式时需要执行此方法 flip()操作不仅重置了当前的position为0，还将limit设置到当 前position的位置</p><h4 id="五次读操作"><a href="#五次读操作" class="headerlink" title="五次读操作"></a>五次读操作</h4><p><img alt="" data-original="../images/15503117236806.png"></p><h4 id="flip-1"><a href="#flip-1" class="headerlink" title="flip"></a>flip</h4><p><img alt="" data-original="../images/15503117513822.png"></p><h2 id="几个重要的函数"><a href="#几个重要的函数" class="headerlink" title="几个重要的函数"></a>几个重要的函数</h2><p>public final Buffer rewind()<br>– 将position置零，并清除标志位(mark)<br>public final Buffer clear()<br>– 将position置零，同时将limit设置为capacity的大小，并清除了标志mark<br>public final Buffer flip()<br>– 先将limit设置到position所在位置，然后将position置零，并清除标志位mark – 通常在读写转换时使用</p><h2 id="文件映射到内存"><a href="#文件映射到内存" class="headerlink" title="文件映射到内存"></a>文件映射到内存</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"C:\\mapfile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel fc = raf.getChannel();</span><br><span class="line"><span class="comment">//将文件映射到内存中</span></span><br><span class="line">MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, raf.length()); </span><br><span class="line"><span class="keyword">while</span>(mbb.hasRemaining())&#123;</span><br><span class="line">System.out.print((char)mbb.get()); </span><br><span class="line">&#125;</span><br><span class="line">mbb.put(<span class="number">0</span>,(byte)<span class="number">98</span>); <span class="comment">//修改文件</span></span><br><span class="line">raf.close();</span><br></pre></td></tr></table></figure><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="多线程网络服务器的一般结构"><a href="#多线程网络服务器的一般结构" class="headerlink" title="多线程网络服务器的一般结构"></a>多线程网络服务器的一般结构</h2><p><img alt="" data-original="../images/15503117616100.png"></p><h2 id="简单案例-EchoServer"><a href="#简单案例-EchoServer" class="headerlink" title="简单案例 EchoServer"></a>简单案例 EchoServer</h2><h3 id="EchoServer"><a href="#EchoServer" class="headerlink" title="EchoServer"></a>EchoServer</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span> args[]) &#123; </span><br><span class="line">ServerSocket echoServer = <span class="literal">null</span>; </span><br><span class="line">Socket clientSocket = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">echoServer = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">System.out.println(e); &#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">clientSocket = echoServer.accept(); System.out.println(clientSocket.getRemoteSocketAddress() + <span class="string">" connect!"</span>); </span><br><span class="line">tp.execute(<span class="keyword">new</span> HandleMsg(clientSocket));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">System.out.println(e); &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程在这里制作一个接收accept的功能。</p><h3 id="HandleMsg"><a href="#HandleMsg" class="headerlink" title="HandleMsg"></a>HandleMsg</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleMsg</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="comment">//省略部分信息</span></span><br><span class="line">public <span class="keyword">void</span> run()&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">is = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">os = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="literal">true</span>); </span><br><span class="line"><span class="comment">// 从InputStream当中读取客户端所发送的数据</span></span><br><span class="line"><span class="built_in">String</span> inputLine = <span class="literal">null</span>;</span><br><span class="line">long b=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">while</span> ((inputLine = is.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">os.println(inputLine); </span><br><span class="line">&#125;</span><br><span class="line">long e=System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"spend:"</span>+(e-b)+<span class="string">"ms"</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace(); &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读到什么就回写什么</p><h3 id="EchoServer的客户端"><a href="#EchoServer的客户端" class="headerlink" title="EchoServer的客户端"></a>EchoServer的客户端</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">Socket client = <span class="literal">null</span>;</span><br><span class="line">PrintWriter writer = <span class="literal">null</span>;</span><br><span class="line">BufferedReader reader = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">client = <span class="keyword">new</span> Socket();</span><br><span class="line">client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8000</span>)); writer = <span class="keyword">new</span> PrintWriter(client.getOutputStream(), <span class="literal">true</span>); writer.println(<span class="string">"Hello!"</span>);</span><br><span class="line">writer.flush();</span><br><span class="line">reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">System.out.println(<span class="string">"from server: "</span> + reader.readLine());</span><br><span class="line">&#125; <span class="keyword">catch</span>&#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//省略资源关闭 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h3><p>– 为每一个客户端使用一个线程，如果客户端出现延时等异常，线程可能会被占用很长时间。因为数据的准备和读取都在这个线程中。<br>– 此时，如果客户端数量众多，可能会消耗大量的系统资源</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>– 非阻塞的NIO<br>– 数据准备好了在工作<br><strong><font color="red">注意：io真正的工作分为准备和读取两个部分。nio就是在准备玩了之后才会分配读取的操作。</font></strong></p><h2 id="模拟低效的客户端"><a href="#模拟低效的客户端" class="headerlink" title="模拟低效的客户端"></a>模拟低效的客户端</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">static</span> ExecutorService tp=Executors.newCachedThreadPool(); private <span class="keyword">static</span> final int sleep_time=<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>;</span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">public <span class="keyword">void</span> run()&#123; </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">client = <span class="keyword">new</span> Socket();</span><br><span class="line">client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8000</span>)); </span><br><span class="line">writer = <span class="keyword">new</span> PrintWriter(client.getOutputStream(), <span class="literal">true</span>); writer.print(<span class="string">"H"</span>);</span><br><span class="line">LockSupport.parkNanos(sleep_time);</span><br><span class="line">writer.print(<span class="string">"e"</span>);</span><br><span class="line">LockSupport.parkNanos(sleep_time);</span><br><span class="line">writer.print(<span class="string">"l"</span>);</span><br><span class="line">LockSupport.parkNanos(sleep_time);</span><br><span class="line">writer.print(<span class="string">"l"</span>);</span><br><span class="line">LockSupport.parkNanos(sleep_time);</span><br><span class="line">writer.print(<span class="string">"o"</span>);</span><br><span class="line">LockSupport.parkNanos(sleep_time);</span><br><span class="line">writer.print(<span class="string">"!"</span>);</span><br><span class="line">LockSupport.parkNanos(sleep_time);</span><br><span class="line">writer.println();</span><br><span class="line">writer.flush();</span><br></pre></td></tr></table></figure><h3 id="服务器输出"><a href="#服务器输出" class="headerlink" title="服务器输出"></a>服务器输出</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spend:<span class="number">6000</span>ms </span><br><span class="line">spend:<span class="number">6000</span>ms </span><br><span class="line">spend:<span class="number">6000</span>ms </span><br><span class="line">spend:<span class="number">6001</span>ms </span><br><span class="line">spend:<span class="number">6002</span>ms</span><br><span class="line">spend:<span class="number">6002</span>ms </span><br><span class="line">spend:<span class="number">6002</span>ms </span><br><span class="line">spend:<span class="number">6002</span>ms </span><br><span class="line">spend:<span class="number">6003</span>ms </span><br><span class="line">spend:<span class="number">6003</span>ms</span><br></pre></td></tr></table></figure><p>这里的6秒花在了哪里？<br>注意上面的代码块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long b=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">while</span> ((inputLine = is.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">os.println(inputLine); </span><br><span class="line">&#125;</span><br><span class="line">long e=System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"spend:"</span>+(e-b)+<span class="string">"ms"</span>);</span><br></pre></td></tr></table></figure><p>读和写一共花了六秒，读的时候花了很多时间读不到</p><h1 id="网络编程NIO"><a href="#网络编程NIO" class="headerlink" title="网络编程NIO"></a>网络编程NIO</h1><p><img alt="" data-original="../images/15503117817368.png"></p><p><strong><font color="red">把数据准备好了再通知我 </font></strong>Channel有点类似于流，一个Channel可以和文件或者网络Socket对应<br>Selector：多路复用选择器 Selector，它是NIO编程的基础，非常重要，多路复用器提供选择已经就绪的任务的能力。简单说，就是Selector会不断地轮询注册在其上的通道（Channel） 假如某个通道发生了读写操作，这个通道就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以取得就绪的Channel集合，从而进行后续的IO操作。一个Selector可以负责成千上万Channel通道，没有上线，这也是JDK使用了epoll代替了传统的select实现，获得连接句柄没有限制。这就意味着 我们只需要一个线程负责Selector的轮询，就可以接入成千上万个客户端。<br>Selector准备好数据后，返回SelectionKey SelectionKey表示一对Selector和Channel的关系， 从SelectionKey中可以得到Channnel(数据已经准备)， 并读取数据<br>select()和selectNow()：<br>select方法如果没有一个channel准备好数据的话，就会出现阻塞，selectNow不论有没有准备好，都会有一个返回值，不会出现阻塞。</p><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.spi.SelectorProvider;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NioTest</span> </span>&#123;</span><br><span class="line">private <span class="keyword">void</span> StartServer ()throws Exception&#123;</span><br><span class="line">final Selector selector = SelectorProvider.provider().openSelector();</span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">//将ServerSocketChannel设置为非阻塞的，accept不会一直等待，即数据准备好了，给个通知。</span></span><br><span class="line">ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">InetSocketAddress isa = <span class="keyword">new</span> InetSocketAddress(<span class="number">8000</span>);</span><br><span class="line">ssc.socket().bind(isa);</span><br><span class="line"><span class="comment">//给channel注册一个感兴趣的事件，即accept事件，如果有人accept，selector就告诉ssc</span></span><br><span class="line">SelectionKey acceptKey = ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"><span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"><span class="comment">//已经有数据准备好了（读、写、accept）</span></span><br><span class="line">selector.select();</span><br><span class="line"><span class="comment">//if (selector.selectNow() == 0) &#123;</span></span><br><span class="line"><span class="comment">//continue;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="built_in">Set</span> readyKeys = selector.selectedKeys();</span><br><span class="line">Iterator i = readyKeys.iterator();</span><br><span class="line">long e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">SelectionKey sk = (SelectionKey) i.next();</span><br><span class="line"><span class="comment">//remove掉，是为了防止后面重复处理。</span></span><br><span class="line">i.remove();</span><br><span class="line"><span class="comment">//如果是一个accept的事件</span></span><br><span class="line"><span class="keyword">if</span> (sk.isAcceptable()) &#123;</span><br><span class="line">doAccept(sk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是一个读的事件，读已经准备好了</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sk.isValid()&amp;&amp;sk.isReadable())&#123;</span><br><span class="line"><span class="comment">//将时间做一个记录</span></span><br><span class="line"><span class="keyword">if</span> (!geym_time_stat.containsKey(((SocketChannel) sk.channel()).socket())) &#123;</span><br><span class="line">geym_time_stat.put(((SocketChannel) sk.channel()).socket(),System.currentTimeMillis() );</span><br><span class="line">doRead(sk);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是一个写的事件</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sk.isValid() &amp;&amp; sk.isWritable()) &#123;</span><br><span class="line">doWrite(sk);</span><br><span class="line">e = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//耗时的统计</span></span><br><span class="line">long b = geym_time_stat.remove(((SocketChannel) sk.channel()).socket());</span><br><span class="line">System.out.println(<span class="string">"spend："</span>+(e-b)+<span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleMsg</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">SelectionKey sk;</span><br><span class="line">ByteBuffer bb;</span><br><span class="line"></span><br><span class="line">public HandleMsg(SelectionKey sk,ByteBuffer bb)&#123;</span><br><span class="line"><span class="keyword">this</span>.sk= sk;</span><br><span class="line"><span class="keyword">this</span>.bb = bb;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="comment">//将之前添加的附件拿出来</span></span><br><span class="line">EchoClient echoClient = (EchoClient) sk.attachment();</span><br><span class="line">echoClient.enqueue(bb);</span><br><span class="line"><span class="comment">//将SelectionKey感兴趣的事件修改为OP_READ和OP_WRITE；</span></span><br><span class="line">sk.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line"><span class="comment">//强迫Selector立即返回</span></span><br><span class="line">selector.wakeup();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private <span class="keyword">void</span> doRead(SelectionKey sk)&#123;</span><br><span class="line">SocketChannel channel = (SocketChannel) sk.channel();</span><br><span class="line">ByteBuffer bb = ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line">int len;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">len = channel.read(bb);</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">disconnect(sk);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"Field to read from client"</span>);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">disconnect(sk);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">bb.flip();</span><br><span class="line">tp.excute(<span class="keyword">new</span> HandleMsg(sk, bb));</span><br><span class="line">&#125;</span><br><span class="line">private <span class="keyword">void</span> doWrite(SelectionKey sk)&#123;</span><br><span class="line">SelectableChannel channel = sk.channel();</span><br><span class="line">EchoClient echoClient = (EchoClient) sk.attachment();</span><br><span class="line">LinkedList&lt;ByteBuffer&gt; outq =  echoClient.getOutputQueue();</span><br><span class="line">ByteBuffer bb = outq.getLast();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//回写到channel中</span></span><br><span class="line">int len = channel.write(bb);</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">disconnect(sk);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bb.remaining() == <span class="number">0</span>) &#123;</span><br><span class="line">outq.removeLast();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">"Faild to write to client ."</span>);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">disconnect(sk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列中的数据已经回写完毕的话</span></span><br><span class="line"><span class="keyword">if</span> (outq.size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//将对写事件感兴趣去掉。</span></span><br><span class="line">sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private <span class="keyword">void</span> doAccept(SelectionKey sk)&#123;</span><br><span class="line">ServerSocketChannel server = (ServerSocketChannel) sk.channel();</span><br><span class="line">SocketChannel clientChannel;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">clientChannel = server.accept();</span><br><span class="line">clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//希望能读数据</span></span><br><span class="line">SelectionKey clientKey = clientChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">EchoClient echoClient = <span class="keyword">new</span> EchoClient();</span><br><span class="line"><span class="comment">//增加一个附件给Key</span></span><br><span class="line">clientKey.attach(echoClient);</span><br><span class="line">InetAddress clientAddress = clientChannel.socket().getInetAddress();</span><br><span class="line">System.out.println(<span class="string">"Accepted connection from "</span>+clientAddress.getHostAddress());</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">"Faild to accept new client"</span>);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span></span>&#123;</span><br><span class="line">LinkedList&lt;ByteBuffer&gt; outq;</span><br><span class="line">EchoClient()&#123;</span><br><span class="line">outq = <span class="keyword">new</span> LinkedList&lt;ByteBuffer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读到数据就往里面塞</span></span><br><span class="line">public <span class="keyword">void</span> enqueue(ByteBuffer bb)&#123;</span><br><span class="line">outq.addFirst(bb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是通过nio的方式实现上面的功能，从6s多变为了几毫秒，因为只是部分代码，所以没有运行结果。<br>总结:<br>– NIO会将数据准备好后，再交由应用进行处理，数据如果没有准备好，是不会进入到应用中的，数据的读取过程依然在应用线程中完成 ，等待的时间剥离到一个独立的线程中去等待（selector.select();）。<br>– 节省数据准备时间(因为Selector可以复用)</p><h1 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h1><p>异步io<br>上面的NIO只是将等待的时间剥离到少数的线程中，避免大量的线程等待，造成的资源浪费，AIO等你写完了或者读完了再通知我。不需要读，也不需要写，只需要等系统把数据都处理完了之后，把回调函数放进去，就会执行，AIO不会加快io，io本身的速度并没有加快，只是改变了原来的线程对io的处理方式，看起来是变快了。</p><h2 id="特点总结："><a href="#特点总结：" class="headerlink" title="特点总结："></a>特点总结：</h2><p>读完了再通知我<br>不会加快IO，只是在读完后进行通知<br>使用回调函数，进行业务处理</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>用到的类<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousServerSocketChannel</span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server = AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br></pre></td></tr></table></figure><p>使用server上的accept方法<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract &lt;A&gt; <span class="keyword">void</span> accept(A attachment,</span><br><span class="line">CompletionHandler&lt;AsynchronousSocketChannel,? <span class="keyword">super</span> A&gt;handler);</span><br></pre></td></tr></table></figure><p></p><p>因为AIO是异步的，将accept调用了之后立即返回，但是并没有真正拿到客户端的数据，CompletionHandler&lt;AsynchronousSocketChannel,? super A&gt;handler这个接口的作用就是在真正accept的时候，将accept得到的数据传给handler，供后面的相关操作使用。</p><h2 id="其他的方法"><a href="#其他的方法" class="headerlink" title="其他的方法"></a>其他的方法</h2><p>AsynchronousSocketChannel<br>因为是异步的，肯定不能读完了之后再返回，所以所有的方法都是立即返回的<br>– read</p><p><img alt="" data-original="../images/15503118004273.png"><br>TimeUnit是超时时间<br>第三个函数只有一个参数，但是会返回一个future，告知读到了第几个字节<br>第四个函数是读到了ByteBuffer数组中，因为网络报文的前二十（举例）个字节是无用的，直接剥离掉，能直接拿到有用的数据。<br>– write<br><img alt="" data-original="../images/15503118085609.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server.accept(<span class="literal">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, <span class="built_in">Object</span>&gt;() &#123;</span><br><span class="line">final ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">  网络编程 AIO</span><br><span class="line">public <span class="keyword">void</span> completed(AsynchronousSocketChannel result, <span class="built_in">Object</span> attachment) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName());   Future&lt;Integer&gt; writeResult=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">buffer.clear();</span><br><span class="line">result.read(buffer).get(<span class="number">100</span>, TimeUnit.SECONDS); </span><br><span class="line">buffer.flip();</span><br><span class="line">writeResult=result.write(buffer);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123; e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (TimeoutException e) &#123; e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//执行完了之后再次执行accept，防止执行完了没事干了。</span></span><br><span class="line">server.accept(<span class="literal">null</span>, <span class="keyword">this</span>);</span><br><span class="line">writeResult.get(); </span><br><span class="line">result.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(e.toString()); &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> failed(Throwable exc, <span class="built_in">Object</span> attachment) &#123;</span><br><span class="line">System.out.println(<span class="string">"failed: "</span> + exc); </span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面是accept的代码实现，</p><h1 id="为什么需要了解NIO和AIO"><a href="#为什么需要了解NIO和AIO" class="headerlink" title="为什么需要了解NIO和AIO?"></a>为什么需要了解NIO和AIO?</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;什么是NIO&quot;&gt;&lt;a href=&quot;#什么是NIO&quot; class=&quot;headerlink&quot; title=&quot;什么是NI
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java高并发程序设计学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="高并发" scheme="http://mmmmmm.me/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发程序设计学习笔记（七）：并行设计模式</title>
    <link href="http://mmmmmm.me/2019-02-13.html"/>
    <id>http://mmmmmm.me/2019-02-13.html</id>
    <published>2019-02-13T11:20:02.000Z</published>
    <updated>2019-03-12T12:16:32.842Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><p>在软件工程中，设计模式(design pattern)是对软件设计中普遍存在(反复出现)的各种问题 ，所提出的解决方案。这个术语是由埃里希·伽玛(Erich Gamma)等人在1990年代从建筑设计领 域引入到计算机科学的。<br>Richard Helm, Ralph Johnson ,John Vlissides (Gof) 和Gamma合称四人帮<br>《设计模式:可复用面向对象软件的基础》 收录 23种模式<br>– 观察者模式<br>– 策略模式<br>– 装饰者模式<br>– 享元模式<br>– 模板方法<br>– …..</p><h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h2><p>– MVC<br>– 分层</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>– 提炼系统中的组件</p><h2 id="代码模式-成例-Idiom"><a href="#代码模式-成例-Idiom" class="headerlink" title="代码模式(成例 Idiom)"></a>代码模式(成例 Idiom)</h2><p>– 低层次，与编码直接相关<br>– 如DCL</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line"><span class="built_in">String</span> name; </span><br><span class="line">int birthYear; </span><br><span class="line">byte[] raw;</span><br><span class="line">public boolean equals(<span class="built_in">Object</span> obj)&#123; </span><br><span class="line"><span class="keyword">if</span> (!obj <span class="keyword">instanceof</span> Person)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">Person other = (Person)obj; </span><br><span class="line"><span class="keyword">return</span> name.equals(other.name)</span><br><span class="line">&amp;&amp; birthYear == other.birthYear</span><br><span class="line">&amp;&amp; Arrays.equals(raw, other.raw); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int hashCode()&#123; </span><br><span class="line">... </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样 有利于我们协调系统整体的行为<br>比如:全局信息配置<br>在多线程中通过单例模式，防止多个线程多次创建对象。</p><h2 id="普通单例"><a href="#普通单例" class="headerlink" title="普通单例"></a>普通单例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">private Singleton()&#123;</span><br><span class="line">System.out.println(<span class="string">"Singleton is create"</span>);</span><br><span class="line">&#125;</span><br><span class="line">private <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">public <span class="keyword">static</span> Singleton getInstance() &#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>何时产生实例 不好控制</p><h2 id="假如单例中有某个字段"><a href="#假如单例中有某个字段" class="headerlink" title="假如单例中有某个字段"></a>假如单例中有某个字段</h2><p>一般来说，产生实例的时间是调用getinstance方法的时候，但是实际上是Singleton对象第一次被访问的时候。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> int STATUS=<span class="number">1</span>;</span><br><span class="line">private Singleton()&#123;</span><br><span class="line">System.out.println(<span class="string">"Singleton is create"</span>); </span><br><span class="line">&#125;</span><br><span class="line">private <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">public <span class="keyword">static</span> Singleton getInstance() &#123;</span><br><span class="line"><span class="keyword">return</span> instance; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Singleton.STATUS);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Singleton is create <span class="number">1</span></span><br></pre></td></tr></table></figure><p>想要输出STATUS这个字段，去访问了Singleton这个类，会自动创建一个实例，这是一个不好的地方。</p><h2 id="改进的单例"><a href="#改进的单例" class="headerlink" title="改进的单例"></a>改进的单例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">private LazySingleton() &#123;</span><br><span class="line">System.out.println(<span class="string">"LazySingleton is create"</span>); </span><br><span class="line">&#125;</span><br><span class="line">private <span class="keyword">static</span> LazySingleton instance = <span class="literal">null</span>;</span><br><span class="line">public <span class="keyword">static</span> synchronized LazySingleton getInstance() &#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为上面的一点小bug，所以衍生出了这种单例模式，只有是第一次（instance=null）的时候才会进行初始化，是一个延迟加载的过程，同时防止多线程进入此类而创建多个实例，所以在方法上加入了synchronized关键字，保证当有一个线程进来的时候，其他的线程进不来，所以只有一个线程能够进入if (instance == null)这句话，不会多个线程同时进行判断。但是synchronized这个锁，可能对于高并发，可能有点影响。</p><h2 id="代理模式再升级"><a href="#代理模式再升级" class="headerlink" title="代理模式再升级"></a>代理模式再升级</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StaticSingleton</span> </span>&#123;</span><br><span class="line">private StaticSingleton()&#123;</span><br><span class="line">System.out.println(<span class="string">"StaticSingleton is create"</span>); </span><br><span class="line">&#125;</span><br><span class="line">private <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">private <span class="keyword">static</span> StaticSingleton instance = <span class="keyword">new</span> StaticSingleton(); </span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> StaticSingleton getInstance() &#123; </span><br><span class="line"><span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免上面的synchronized带来的高并发的性能问题，衍生出了这种方式。<br>将new StaticSingleton放到内部类中，调用getInstance方法的时候再访问StaticSingleton类中的instance，再new StaticSingleton来进行初始化，如果有一个static的STATUS的变量的时候，去访问它，是不会创建本类的实例的，因为并没有对内部类进行初始化，所以，只有通过访问getInstance（）这个方法的时候才会进行初始化。<br>通过这种方法也起到一种延迟加载的效果，而且没有高并发的性能问题，因为并没有加锁。</p><h1 id="不变模式"><a href="#不变模式" class="headerlink" title="不变模式"></a>不变模式</h1><p>一个类的内部状态创建后，在整个生命期间都不会发生变化时，就是不变类<br>不变模式不需要同步，因为不变模式是一个只读的对象。</p><h2 id="不变模式是如何实现的"><a href="#不变模式是如何实现的" class="headerlink" title="不变模式是如何实现的"></a>不变模式是如何实现的</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123; </span><br><span class="line"><span class="comment">//确保无子类</span></span><br><span class="line">private final <span class="built_in">String</span> no; </span><br><span class="line"><span class="comment">//私有属性，不会被其他对象获取 </span></span><br><span class="line">private final <span class="built_in">String</span> name;</span><br><span class="line"><span class="comment">//final保证属性不会被2次赋值 </span></span><br><span class="line">private final double price;</span><br><span class="line">public Product(<span class="built_in">String</span> no, <span class="built_in">String</span> name, double price) &#123;<span class="comment">//在创建对象时，必须指定数据</span></span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="comment">//因为创建之后，无法进行修改 this.no = no;</span></span><br><span class="line"><span class="keyword">this</span>.name = name; <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="built_in">String</span> getNo() &#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="built_in">String</span> getName() &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">public double getPrice() &#123;</span><br><span class="line"><span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将类变成final的，保证没有子类，防止子类继承它，变成可变的。<br>将所有的属性变成final的，保证所有的字段只能被赋值一次。</p><h2 id="不变模式的案例"><a href="#不变模式的案例" class="headerlink" title="不变模式的案例"></a>不变模式的案例</h2><p>java.lang.String<br>所有像是修改String的操作（replace，substring等），实际上是生成了一个新的String对象<br>java.lang.Boolean<br>java.lang.Byte<br>java.lang.Character<br>java.lang.Double<br>java.lang.Float<br>java.lang.Integer<br>java.lang.Long<br>java.lang.Short<br>以上所有的看似改变了原来对象的操作都是生成了一个新的对象。</p><h1 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h1><h2 id="核心思想是异步调用"><a href="#核心思想是异步调用" class="headerlink" title="核心思想是异步调用"></a>核心思想是异步调用</h2><p>被集成在可jdk的开发包中，核心思想就是异步调用。<br><img alt="" data-original="../images/15500674888163.png"><br><img alt="" data-original="../images/15500674940045.png"></p><p>如上图更加清楚的阐述了这一过程，futuredate和realdata都继承自Data接口，函数调用的时候返回Data接口，而不管究竟是futuredate还是realdata，将futuredate（类似上面的订单，只是一个空壳）迅速的返回，然后等真正的数据构造完成之后再返回realdata，并且在futuredate中具有realdata的参数，来判断时候已经将真实的数据返回。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Data &#123;</span><br><span class="line">public <span class="built_in">String</span> getResult (); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="title">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">protected RealData realdata = <span class="literal">null</span>;<span class="comment">//FutureData是RealData的包装</span></span><br><span class="line">protected boolean isReady = <span class="literal">false</span>;</span><br><span class="line">public synchronized <span class="keyword">void</span> setRealData(RealData realdata) &#123;</span><br><span class="line"><span class="keyword">if</span> (isReady) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.realdata = realdata; isReady = <span class="literal">true</span>; notifyAll();<span class="comment">//RealData已经被注入，通知getResult()</span></span><br><span class="line">&#125;</span><br><span class="line">public synchronized <span class="built_in">String</span> getResult() &#123;<span class="comment">//会等待RealData构造完成</span></span><br><span class="line"><span class="keyword">while</span> (!isReady) &#123; </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">wait();<span class="comment">//一直等待，知道RealData被注入</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> realdata.result;<span class="comment">//由RealData实现</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="title">implements</span> <span class="title">Data</span> </span>&#123; </span><br><span class="line">protected final <span class="built_in">String</span> result;</span><br><span class="line">public RealData(<span class="built_in">String</span> para) &#123;</span><br><span class="line"><span class="comment">//RealData的构造可能很慢，需要用户等待很久，这里使用sleep模拟</span></span><br><span class="line">StringBuffer sb=<span class="keyword">new</span> StringBuffer(); <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">sb.append(para); </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里使用sleep，代替一个很慢的操作过程 Thread.sleep(100);</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">result =sb.toString(); </span><br><span class="line">&#125;</span><br><span class="line">public <span class="built_in">String</span> getResult() &#123;</span><br><span class="line"><span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">public Data request(final <span class="built_in">String</span> queryStr) &#123;</span><br><span class="line">final FutureData future = <span class="keyword">new</span> FutureData();</span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;<span class="comment">// RealData的构建很慢，</span></span><br><span class="line"><span class="comment">//所以在单独的线程中进行</span></span><br><span class="line">RealData realdata = <span class="keyword">new</span> RealData(queryStr); future.setRealData(realdata);</span><br><span class="line">&#125; </span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="keyword">return</span> future; <span class="comment">// FutureData会被立即返回 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新开启一个线程进行setRealData，但是立即返回future，供使用。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">Client client = <span class="keyword">new</span> Client(); <span class="comment">//这里会立即返回，因为得到的是FutureData而不是RealData</span></span><br><span class="line">Data data = client.request(<span class="string">"name"</span>);</span><br><span class="line">System.out.println(<span class="string">"请求完毕"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里可以用一个sleep代替了对其他业务逻辑的处理 //在处理这些业务逻辑的过程中，RealData被创建，从而充分利用了等待时间</span></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用真实的数据</span></span><br><span class="line">System.out.println(<span class="string">"数据 = "</span> + data.getResult()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果刚执行了Data data = client.request(“name”)返回的并不是真正的数据，这个时候去getResult一定会出现阻塞，但是中间执行了sleep（2000）或做一些其他的事情，并不会影响其他的业务，在真正需要数据的时候，在getResult，能够瞬间返回真正需要的数据。</p><h2 id="JDK对Future模式的支持"><a href="#JDK对Future模式的支持" class="headerlink" title="JDK对Future模式的支持"></a>JDK对Future模式的支持</h2><p><img alt="" data-original="../images/15500675136116.png"></p><p>核心是FutureTask，一个带有Future功能的Runnable</p><h3 id="通过callable实现future"><a href="#通过callable实现future" class="headerlink" title="通过callable实现future"></a>通过callable实现future</h3><p>这里通过implements Callable来实现future的功能。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="title">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123; </span><br><span class="line">private <span class="built_in">String</span> para;</span><br><span class="line">public RealData(<span class="built_in">String</span> para)&#123;</span><br><span class="line"><span class="keyword">this</span>.para=para;</span><br><span class="line">&#125;</span><br><span class="line"> @Override</span><br><span class="line">public <span class="built_in">String</span> call() throws Exception &#123;</span><br><span class="line">StringBuffer sb=<span class="keyword">new</span> StringBuffer(); </span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">sb.append(para);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FutureMain</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line"><span class="comment">//构造FutureTask</span></span><br><span class="line">FutureTask&lt;<span class="built_in">String</span>&gt; future = <span class="keyword">new</span> FutureTask&lt;<span class="built_in">String</span>&gt;(<span class="keyword">new</span> RealData(<span class="string">"a"</span>));</span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>); </span><br><span class="line"><span class="comment">//执行FutureTask，相当于上例中的 client.request("a") 发送请求 </span></span><br><span class="line"><span class="comment">//在这里开启线程进行RealData的call()执行 </span></span><br><span class="line">executor.submit(future);</span><br><span class="line">System.out.println(<span class="string">"请求完毕"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123; <span class="comment">//这里依然可以做额外的数据操作，这里使用sleep代替其他业务逻辑的处理</span></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于data.getResult ()，取得call()方法的返回值 </span></span><br><span class="line"><span class="comment">//如果此时call()方法没有执行完成，则依然会等待 </span></span><br><span class="line">System.out.println(<span class="string">"数据 = "</span> + future.get());</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：<br>FutureTask<string>future = new FutureTask<string>(new RealData(“a”));<br>上面说到jdk中对future的支持，其核心就是FutureTask，这里构造FutureTask<br>executor.submit(future);<br>System.out.println(“数据 = “ + future.get());<br>这里如果，在submit和get之间没有其他的操作直接进行get还是会形成阻塞的。</string></string></p><h3 id="更加简便的方式实现future"><a href="#更加简便的方式实现future" class="headerlink" title="更加简便的方式实现future"></a>更加简便的方式实现future</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FutureMain2</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//执行FutureTask，相当于上例中的 client.request("a") 发送请求</span></span><br><span class="line"><span class="comment">//在这里开启线程进行RealData的call()执行</span></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; future=executor.submit(<span class="keyword">new</span> RealData(<span class="string">"a"</span>));</span><br><span class="line">System.out.println(<span class="string">"请求完毕"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"><span class="comment">//这里依然可以做额外的数据操作，这里使用sleep代替其他业务逻辑的处理</span></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于data.getResult ()，取得call()方法的返回值 </span></span><br><span class="line"><span class="comment">//如果此时call()方法没有执行完成，则依然会等待 </span></span><br><span class="line">System.out.println(<span class="string">"数据 = "</span> + future.get());</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：<br>Future<string>future=executor.submit(new RealData(“a”));<br>System.out.println(“数据 = “ + future.get());<br>因为callable是能够有返回值的，所以能够直接得到future，进一步简化了操作。</string></p><h1 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h1><p>生产者-消费者模式是一个经典的多线程设计模式。它为多线程间的协作提供了良好的解决方案。 在生产者-消费者模式中，通常由两类线程，即若干个生产者线程和若干个消费者线程。生产者线 程负责提交用户请求，消费者线程则负责具体处理生产者提交的任务。生产者和消费者之间则通 过共享内存缓冲区进行通信。</p><p>线程a需要知道线程b的存在，线程b需要知道线程a的存在，如果更换了名字呢？从软件工程的角度讲，一个模块，对外最好是被知道的越少越好，一无所知最好，意味着外部的程序不论怎么改，对我都是没有影响的，能很好的降低耦合性。<br><img alt="" data-original="../images/15500675290878.png"></p><table><thead><tr><th>角色</th><th>作用</th></tr></thead><tbody><tr><td>生产者</td><td>用于提交用户请求，提取用户任务，并装入内存缓冲区</td></tr><tr><td>消费者</td><td>在内存缓冲区中提取并处理任务</td></tr><tr><td>内存缓冲区</td><td>缓存生产者提交的任务或数据，供消费者使用</td></tr><tr><td>任务</td><td>生成者向内存缓冲区提交的数据结构。</td></tr><tr><td>Main</td><td>使用生产者和消费者的客户端</td></tr></tbody></table><h2 id="简单代码实现"><a href="#简单代码实现" class="headerlink" title="简单代码实现"></a>简单代码实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isRunning) &#123; </span><br><span class="line">Thread.sleep(r.nextInt(SLEEPTIME));</span><br><span class="line">data = <span class="keyword">new</span> PCData(count.incrementAndGet()); <span class="comment">//构造任务数据</span></span><br><span class="line">System.out.println(data+<span class="string">" is put into queue"</span>); </span><br><span class="line"><span class="keyword">if</span> (!queue.offer(data, <span class="number">2</span>, TimeUnit.SECONDS)) &#123; </span><br><span class="line"><span class="comment">//提交数据到缓冲区中</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">System.err.println(<span class="string">"failed to put data:"</span> + data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">PCData data = queue.take();</span><br><span class="line"><span class="comment">//提取任务</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != data) &#123;</span><br><span class="line">int re = data.getData() * data.getData(); <span class="comment">//计算平方</span></span><br><span class="line">System.out.println(MessageFormat.format(<span class="string">"&#123;0&#125;*&#123;1&#125;=&#123;2&#125;"</span>,</span><br><span class="line">data.getData(), re));</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;什么是设计模式&quot;&gt;&lt;a href=&quot;#什么是设计模式&quot; class=&quot;headerlink&quot; title=&quot;什么是
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java高并发程序设计学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="高并发" scheme="http://mmmmmm.me/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发程序设计学习笔记（六）：JDK并发包(线程池的基本使用、ForkJoin)</title>
    <link href="http://mmmmmm.me/2019-02-12.html"/>
    <id>http://mmmmmm.me/2019-02-12.html</id>
    <published>2019-02-12T11:20:02.000Z</published>
    <updated>2019-03-12T12:16:32.771Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="1-线程池的基本使用"><a href="#1-线程池的基本使用" class="headerlink" title="1. 线程池的基本使用"></a>1. 线程池的基本使用</h1><h2 id="1-1-为什么需要线程池"><a href="#1-1-为什么需要线程池" class="headerlink" title="1.1. 为什么需要线程池"></a>1.1. 为什么需要线程池</h2><p><strong><font color="red">为什么需要线程池？</font></strong><br>线程创建和销毁的代价是比较高的，在多线程中，如果每次都要对线程进行创建和销毁，这两个操作，对于线程本身的业务来说其实是没有必要的，我只关心线程所执行的任务，希望吧尽可能多的cpu用在任务的执行上，而不是辅助性质的线程的创建和销毁上面，所以线程池应运而生。</p><p><strong><font color="red">线程池的作用？</font></strong><br>它的作用就是把线程进行复用，比如执行一百个任务，如果分十次批量执行，如果没有线程池就需要创建销毁一百次，如果有线程池（假如线程池中有十个线程），这十个线程是不退出的，常驻线程的，如果没有任务的话是一个等待的状态，任务开始的时候就会执行任务，当前十个任务提交的时候，他们在线程池里跑，因为线程池的线程不会被销毁，所以前十个任务跑完之后，马上就能执行下面的十个任务，从始至终只关注线程的业务，而只创建了一次十个线程，节省cpu的时间。</p><p>简单的线程池实现<br>略</p><h2 id="1-2-JDK为我们提供了哪些支持-内置线程池"><a href="#1-2-JDK为我们提供了哪些支持-内置线程池" class="headerlink" title="1.2. JDK为我们提供了哪些支持 内置线程池"></a>1.2. JDK为我们提供了哪些支持 内置线程池</h2><h2 id="1-2-1"><a href="#1-2-1" class="headerlink" title="1.2.1."></a>1.2.1.</h2><p><img alt="" data-original="../images/15499794818047.png"></p><h2 id="1-3-线程池的使用"><a href="#1-3-线程池的使用" class="headerlink" title="1.3. 线程池的使用"></a>1.3. 线程池的使用</h2><h3 id="1-3-1-线程池的种类"><a href="#1-3-1-线程池的种类" class="headerlink" title="1.3.1. 线程池的种类"></a>1.3.1. 线程池的种类</h3><p>newFixedThreadPool 固定大小的线程池，线程池中的线程数量是固定的<br>newSingleThreadExecutor 单一线程的线程池，只有一个线程<br>newCachedThreadPool 缓存的线程池，当一下子好多任务的时候，就开好多线程去做，如果没有任务的时候，线程空闲下来的时候，慢慢线程的数量就会减少，自然消亡，简而言之就是线程的数量在某段时间内是会扩张或者收缩的<br>newScheduledThreadPool定时任务的线程池，支持定时及周期性任务执行，比如每个五分钟调一个什么任务。</p><h3 id="1-3-2-不同线程池的共同性-线程池构造函数详解"><a href="#1-3-2-不同线程池的共同性-线程池构造函数详解" class="headerlink" title="1.3.2. 不同线程池的共同性 线程池构造函数详解"></a>1.3.2. 不同线程池的共同性 线程池构造函数详解</h3><p>进入Executors类中<br>注意：代码中的参数详细意思，再往下面的代码中有详细介绍。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br><span class="line">   public <span class="keyword">static</span> ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">           (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                   <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">   &#125;</span><br><span class="line">public <span class="keyword">static</span> ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                     <span class="number">60</span>L, TimeUnit.SECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//第一个参数（线程池标准容量、初始容量）一开始是零，当任务进来就扩容，</span></span><br><span class="line">   <span class="comment">//SynchronousQueue容量是零当试图往queue中</span></span><br><span class="line">   <span class="comment">//塞任务的时候，是会失败的，就会线程池线程数从零开始往上增加到MAX_VALUE为止，</span></span><br><span class="line">   <span class="comment">//60秒是超时时间，60秒没被使用就会被移除掉</span></span><br></pre></td></tr></table></figure><p></p><p><strong><font color="red">发现都是new ThreadPoolExecutor（），只是传入了不同的参数<br>研究一下ThreadPoolExecutor这个构造函数</font></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,<span class="comment">//核心线程数（标准）</span></span><br><span class="line">                             int maximumPoolSize,<span class="comment">//最大的线程数</span></span><br><span class="line">                             long keepAliveTime,<span class="comment">//如果没有事情做，还能在当前线程存活多少时间</span></span><br><span class="line">                             <span class="comment">//超过指定的时间，将会被杀掉</span></span><br><span class="line">                             TimeUnit unit,<span class="comment">//上面需要的时间的单位</span></span><br><span class="line">                             BlockingQueue&lt;Runnable&gt; workQueue<span class="comment">//阻塞队列，如果当前没有多余线程来做任务，现在queue中排队，用来保存任务。</span></span><br><span class="line">                             <span class="comment">//注意这个queue的容量是有限度的。</span></span><br><span class="line">                             ) &#123;</span><br><span class="line">       <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">            Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>返回头来接着看上面的构造函数就有了很多眉目。</p><h2 id="1-4-线程池使用的小例子"><a href="#1-4-线程池使用的小例子" class="headerlink" title="1.4. 线程池使用的小例子"></a>1.4. 线程池使用的小例子</h2><h3 id="1-4-1-简单线程池"><a href="#1-4-1-简单线程池" class="headerlink" title="1.4.1. 简单线程池"></a>1.4.1. 简单线程池</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line">System.out.println(System.currentTimeMillis()+<span class="string">":Thread ID:"</span>+Thread.currentThread().getId());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">ExecutorService es = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">es.submit(task);</span><br><span class="line"><span class="comment">//es.execute(task);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1549114075211</span>Thread ID:<span class="number">9</span></span><br><span class="line"><span class="number">1549114075213</span>Thread ID:<span class="number">10</span></span><br><span class="line"><span class="number">1549114085211</span>Thread ID:<span class="number">11</span></span><br><span class="line"><span class="number">1549114075211</span>Thread ID:<span class="number">12</span></span><br><span class="line"><span class="number">1549114075210</span>Thread ID:<span class="number">13</span></span><br><span class="line"><span class="number">1549114075213</span>hread ID:<span class="number">10</span></span><br><span class="line"><span class="number">1549114075415</span>Thread ID:<span class="number">9</span></span><br><span class="line"><span class="number">1549114075219</span>Thread ID:<span class="number">13</span></span><br><span class="line"><span class="number">1549114675217</span>Thread ID:<span class="number">12</span></span><br><span class="line"><span class="number">1549114075208</span>hread ID:<span class="number">11</span></span><br></pre></td></tr></table></figure><p>可以看到是五个五个执行的。es.submit(task);es.execute(task);两种方式都可以。</p><h3 id="1-4-2-ScheduledThreadPool"><a href="#1-4-2-ScheduledThreadPool" class="headerlink" title="1.4.2. ScheduledThreadPool"></a>1.4.2. ScheduledThreadPool</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutirServiceDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//如果前面的任务没有完成，则调度也不会启动</span></span><br><span class="line">ses.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1548114424</span></span><br><span class="line"><span class="number">1548114425</span></span><br><span class="line"><span class="number">1548114427</span></span><br><span class="line"><span class="number">1548114428</span></span><br><span class="line"><span class="number">1548114420</span></span><br><span class="line"><span class="number">1548114422</span></span><br><span class="line"><span class="number">1548114423</span></span><br><span class="line"><span class="number">1548114426</span></span><br><span class="line"><span class="number">1548114429</span></span><br><span class="line"><span class="number">1548114430</span></span><br><span class="line"><span class="number">1548114432</span></span><br><span class="line"><span class="number">1548114433</span></span><br><span class="line"><span class="number">1548114434</span></span><br><span class="line"><span class="number">1548114435</span></span><br><span class="line"><span class="number">1548114436</span></span><br><span class="line"><span class="number">1548114437</span></span><br><span class="line"><span class="number">1548114438</span></span><br><span class="line"><span class="number">1548114439</span></span><br><span class="line"><span class="number">1548114430</span></span><br></pre></td></tr></table></figure><p>每过三秒钟执行一次。<br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/20190122075216822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"><br>可以看到第一个参数是第一次各多少时间去调，第二个参数后面周期性的多长时间去调，第三个参数是事件的三围。</p><h1 id="2-扩展和增强线程池"><a href="#2-扩展和增强线程池" class="headerlink" title="2. 扩展和增强线程池"></a>2. 扩展和增强线程池</h1><h2 id="2-1-回调接口"><a href="#2-1-回调接口" class="headerlink" title="2.1. 回调接口"></a>2.1. 回调接口</h2><p>beforeExecute afterExecute terminated<br>捕获线程池运行时一些信息，捕获当时的工作状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExtThreadPool</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Mytask</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">public <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">public Mytask(<span class="built_in">String</span> name) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line">System.out.println(<span class="string">"正在执行"</span>+<span class="string">":Thread ID:"</span>+Thread.currentThread().getId()+<span class="string">",Task Name = "</span>+name);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">ThreadPoolExecutor es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>L, TimeUnit.MICROSECONDS,</span><br><span class="line"><span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;()) &#123;</span><br><span class="line">@Override</span><br><span class="line">protected <span class="keyword">void</span> beforeExecute(Thread t, Runnable r) &#123;</span><br><span class="line">System.out.println(<span class="string">"准备执行："</span>+((Mytask)r).name);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected <span class="keyword">void</span> afterExecute(Runnable r,Throwable t ) &#123;</span><br><span class="line">System.out.println(<span class="string">"执行完成："</span>+((Mytask)r).name);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected <span class="keyword">void</span> terminated() &#123;</span><br><span class="line">System.out.println(<span class="string">"线程池退出"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">Mytask mytask = <span class="keyword">new</span> Mytask(<span class="string">"TASK_GEYM_"</span> + i);</span><br><span class="line">es.execute(mytask);</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">es.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">准备执行：TASK_CEYM_0</span><br><span class="line">正在执行Thread ID：<span class="number">9</span>，TASK Name = TASK_CEYM_0</span><br><span class="line">准备执行：TASK_CEYM_1</span><br><span class="line">正在执行Thread ID：<span class="number">9</span>，TASK Name = TASK_CEYM_1</span><br><span class="line">准备执行：TASK_CEYM_2</span><br><span class="line">正在执行Thread ID：<span class="number">9</span>，TASK Name = TASK_CEYM_2</span><br><span class="line">准备执行：TASK_CEYM_3</span><br><span class="line">正在执行Thread ID：<span class="number">9</span>，TASK Name = TASK_CEYM_3</span><br><span class="line">准备执行：TASK_CEYM_4</span><br><span class="line">正在执行Thread ID：<span class="number">9</span>，TASK Name = TASK_CEYM_4</span><br><span class="line">执行完成：TASK_CEYM_0</span><br><span class="line">执行完成：TASK_CEYM_1</span><br><span class="line">执行完成：TASK_CEYM_2</span><br><span class="line">执行完成：TASK_CEYM_3</span><br><span class="line">执行完成：TASK_CEYM_4</span><br><span class="line">线程池退出</span><br></pre></td></tr></table></figure><p>beforeExecute 线程执行前做的事<br>afterExecute 线程执行完了之后做的事<br>terminated 线程池退出后做的事</p><h2 id="2-2-拒绝策略"><a href="#2-2-拒绝策略" class="headerlink" title="2.2. 拒绝策略"></a>2.2. 拒绝策略</h2><p>不能有无限大小的缓存队列，因为如果有大量的任务进来，会导致内存的激增，如果一直激增而没有释放，会导致内存异常。<br>所以当发现负载到了一定的程度后，应该选择丢弃一些任务，而不是放在内存中，看着内存被耗掉，丢弃的时候希望把这些丢掉的任务（比如数量，具体是那些）记录下来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                             int maximumPoolSize,</span><br><span class="line">                             long keepAliveTime,</span><br><span class="line">                             TimeUnit unit,</span><br><span class="line">                             BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                             ThreadFactory threadFactory,</span><br><span class="line">                             RejectedExecutionHandler handler) &#123;</span><br><span class="line">       <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">           keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">       <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">       <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">       <span class="keyword">this</span>.handler = handler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>构造函数中多了两个参数<br>ThreadFactory//线程工厂（稍后介绍）<br>RejectedExecutionHandler//拒绝策略//如果任务不能执行了我应该怎么做<br>具体的实现包括<br><img alt="在这里插入图片描述" data-original="https://img-blog.csdnimg.cn/2019012208435337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70"></p><h3 id="拒绝策略举例："><a href="#拒绝策略举例：" class="headerlink" title="拒绝策略举例："></a>拒绝策略举例：</h3><h4 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="title">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates an &#123;@code AbortPolicy&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        public AbortPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Always throws RejectedExecutionException.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * @param r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">         * @param e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">         * @throws RejectedExecutionException always.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        public <span class="keyword">void</span> rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                                 <span class="string">" rejected from "</span> +</span><br><span class="line">                                                 e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个策略是如果不能执行了，就会抛出异常，并且将具体的任务信息打印出啦。</p><h4 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="title">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a &#123;@code DiscardPolicy&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        public DiscardPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Does nothing, which has the effect of discarding task r.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * @param r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">         * @param e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        public <span class="keyword">void</span> rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个策略是如果不执行了，就直接丢弃掉，设么也不做。</p><h4 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="title">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a &#123;@code CallerRunsPolicy&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        public CallerRunsPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Executes task r in the caller's thread, unless the executor</span></span><br><span class="line"><span class="comment">         * has been shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * @param r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">         * @param e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        public <span class="keyword">void</span> rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>if (!e.isShutdown()) {<br>r.run();<br>}<br>如果线程池还活着，就让调用者执行这个任务，这个类本身自己不做处理。</p><h4 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="title">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates a &#123;@code DiscardOldestPolicy&#125; for the given executor.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       public DiscardOldestPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Obtains and ignores the next task that the executor</span></span><br><span class="line"><span class="comment">        * would otherwise execute, if one is immediately available,</span></span><br><span class="line"><span class="comment">        * and then retries execution of task r, unless the executor</span></span><br><span class="line"><span class="comment">        * is shut down, in which case task r is instead discarded.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * @param r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">        * @param e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       public <span class="keyword">void</span> rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">               e.getQueue().poll();</span><br><span class="line">               e.execute(r);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>将队列中最老的丢弃掉。</p><h3 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.omg.PortableServer.THREAD_POLICY_ID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RejectThreadPoolDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line">System.out.println(System.currentTimeMillis()+<span class="string">":Thread Id:"</span>+Thread.currentThread().getId());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line"><span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),<span class="comment">//永远都放不进去的对了，只有当我去拿的时候才能放进去，</span></span><br><span class="line"><span class="comment">// 因为放不进去，所以走拒绝策略</span></span><br><span class="line">Executors.defaultThreadFactory(),</span><br><span class="line"><span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> rejectedExecution(final Runnable r, final ThreadPoolExecutor executor) &#123;</span><br><span class="line">System.out.println(r.toString()+<span class="string">"is discard"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;Integer.MAX_VALUE ; i++) &#123;</span><br><span class="line">es.submit(task);</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1548893374312</span>:Thread Id:<span class="number">9</span></span><br><span class="line"><span class="number">1548893374323</span>:Thread Id:<span class="number">10</span></span><br><span class="line"><span class="number">1548893374333</span>:Thread Id:<span class="number">11</span></span><br><span class="line"><span class="number">1548893374345</span>:Thread Id:<span class="number">12</span></span><br><span class="line"><span class="number">1548893374356</span>:Thread Id:<span class="number">13</span></span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">655538e5</span>is discard</span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">3e0</span>a765cis discard</span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">20e0</span>b1d6is discard</span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">7</span>fbb6976is discard</span><br><span class="line"><span class="number">1548893374418</span>:Thread Id:<span class="number">9</span></span><br><span class="line"><span class="number">1548893374433</span>:Thread Id:<span class="number">10</span></span><br><span class="line"><span class="number">1548893374446</span>:Thread Id:<span class="number">11</span></span><br><span class="line"><span class="number">1548893374456</span>:Thread Id:<span class="number">12</span></span><br><span class="line"><span class="number">1548893374466</span>:Thread Id:<span class="number">13</span></span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">6</span>c2fdbb1is discard</span><br></pre></td></tr></table></figure><p></p><p>如上面，因为队列放不进去东西，任务每10ms执行一次，而每个任务要sleep 100ms，所以，必定会出现任务堆积，这个时候就走了我们自定义的拒绝策略。</p><h2 id="2-3-自定义ThreadFactory"><a href="#2-3-自定义ThreadFactory" class="headerlink" title="2.3. 自定义ThreadFactory"></a>2.3. 自定义ThreadFactory</h2><p>能够在创造Thread的时候给Thread命名，或者使其变成守护线程的操作。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TheadF</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="title">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">private <span class="keyword">static</span> final AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">private final ThreadGroup group;</span><br><span class="line">private final AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">private final <span class="built_in">String</span> namePrefix;</span><br><span class="line"></span><br><span class="line">DefaultThreadFactory()&#123;</span><br><span class="line">SecurityManager s = System.getSecurityManager();</span><br><span class="line">group = (s != <span class="literal">null</span>) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br><span class="line">namePrefix = <span class="string">"pool-"</span> + poolNumber.getAndIncrement() + <span class="string">"-thread-"</span>;</span><br><span class="line">&#125;</span><br><span class="line">DefaultThreadFactory(final ThreadGroup group, final <span class="built_in">String</span> namePrefix) &#123;</span><br><span class="line"><span class="keyword">this</span>.group = group;</span><br><span class="line"><span class="keyword">this</span>.namePrefix = namePrefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Thread newThread(final Runnable r) &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(group, r, namePrefix + threadNumber.getAndIncrement(),<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">t.setDaemon(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (t.getPriority()!=Thread.NORM_PRIORITY)</span><br><span class="line">t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="简单的线程池实现的原理"><a href="#简单的线程池实现的原理" class="headerlink" title="简单的线程池实现的原理"></a>简单的线程池实现的原理</h2><p>execute方法（ThreadPollExecutor类中）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> execute(Runnable command) &#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            int recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到是将线程放到了workqueue中，workQueue是一个blockingQueue，如果里面没有数据，就不拿，如果满了，就等待，构造参数中的long keepAliveTime就是如果规定时间内一直在等待，超出之后就退出<br>上述代码中的ctl是什么？</p><pre><code> * The main pool control state, ctl, is an atomic integer packing * 他是一个原子的整数 * two conceptual fields包装了两个逻辑上的字段： *   workerCount, indicating the effective number of threads线程总数 *   runState,    indicating whether running, shutting down etc线程池本身的状态 * The runState provides the main lifecyle control, taking on values:一些 线程池的状态 * *   RUNNING:  Accept new tasks and process queued tasks可以添加新的task也可以处理一些任务 *   SHUTDOWN: Don&apos;t accept new tasks, but process queued tasks不接受task但是接受task *   STOP:     Don&apos;t accept new tasks, don&apos;t process queued tasks, *             and interrupt in-progress tasks不接受task，不处理task *   TIDYING:  All tasks have terminated, workerCount is zero, *             the thread transitioning to state TIDYING *             will run the terminated() hook method *   TERMINATED: terminated() has completed</code></pre><p>下面这里：了解即可。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">通过control+j看到CAPACITY是一个<span class="number">29</span>位的数，左移一位，再减一，就是前二十八位</span><br><span class="line">    private <span class="keyword">static</span> final int CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"> <span class="comment">//c和CAPACITY的按位取反，最后再取与，就是前三位，表示线程池的状态</span></span><br><span class="line">    private <span class="keyword">static</span> int runStateOf(int c)     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">    <span class="comment">//c和CAPACITY按位取与（都转化成二进制，每位进行与的操作），得到c的前二十八位</span></span><br><span class="line">    <span class="comment">//得到了当前有多少个线程</span></span><br><span class="line">    private <span class="keyword">static</span> int workerCountOf(int c)  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure><p></p><p>接着往下看<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int c = ctl.get();</span><br><span class="line"><span class="comment">//如果当前线程的数量小于核心线程数量</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//加入进去</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 如果加入失败了，就将这个操作放到workqueue中，</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            int recheck = ctl.get();</span><br><span class="line">            <span class="comment">//如果在往queue里面加的过程中，简称线程池，发现不再是running的状态</span></span><br><span class="line">            <span class="comment">//就拒绝掉这个任务</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">                <span class="comment">//如果检查发现正在跑的线程是零，就addwork进行初始化</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//首选的不是reject而是先进行上面的放入queue</span></span><br><span class="line">        <span class="comment">//如果上面判断加如队列没有队列满了，塞不进去了，在这里再尝试加入任务</span></span><br><span class="line">        <span class="comment">//第二个参数是false，线程的数量不在收到核心线程数量的限制，而是受到</span></span><br><span class="line">        <span class="comment">//最大线程数的限制。如果这样都失败了，就进行reject拒绝策略。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">            reject(command);</span><br></pre></td></tr></table></figure><p></p><h1 id="4-ForkJoin"><a href="#4-ForkJoin" class="headerlink" title="4. ForkJoin"></a>4. ForkJoin</h1><p>一个比较新的线程池</p><h2 id="4-1-思想"><a href="#4-1-思想" class="headerlink" title="4.1. 思想"></a>4.1. 思想</h2><h3 id="4-1-1"><a href="#4-1-1" class="headerlink" title="4.1.1."></a>4.1.1.</h3><p><img alt="" data-original="../images/15499797945926.png"></p><p>将大任务分成小任务，join等待所有的小任务结束再执行相应的操作，fork将小任务推向线程池。</p><h2 id="4-2-使用接口"><a href="#4-2-使用接口" class="headerlink" title="4.2. 使用接口"></a>4.2. 使用接口</h2><h3 id="4-2-1-RecursiveAction"><a href="#4-2-1-RecursiveAction" class="headerlink" title="4.2.1. RecursiveAction"></a>4.2.1. RecursiveAction</h3><p>无返回值</p><h3 id="4-2-2-RecursiveTask"><a href="#4-2-2-RecursiveTask" class="headerlink" title="4.2.2. RecursiveTask"></a>4.2.2. RecursiveTask</h3><p>有返回值</p><h2 id="4-3-简单例子"><a href="#4-3-简单例子" class="headerlink" title="4.3. 简单例子"></a>4.3. 简单例子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">private <span class="keyword">static</span> final int ThRESHOLD = <span class="number">10000</span>;</span><br><span class="line">private long start;</span><br><span class="line">private long end;</span><br><span class="line">public CountTask(long start,long end)&#123;</span><br><span class="line"><span class="keyword">this</span>.start = start;</span><br><span class="line"><span class="keyword">this</span>.end = end;</span><br><span class="line">&#125;</span><br><span class="line">protected Long compute() &#123;</span><br><span class="line">long sum = <span class="number">0</span>;</span><br><span class="line">boolean canCompute = (end - start) &lt; ThRESHOLD;</span><br><span class="line"><span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line"><span class="keyword">for</span> (long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//分成100个小任务</span></span><br><span class="line">long step = (start + end) / <span class="number">100</span>;</span><br><span class="line">ArrayList&lt;CountTask&gt; subTasks = <span class="keyword">new</span> ArrayList&lt;CountTask&gt;();</span><br><span class="line">long pos = start;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">long lastOne = pos + step;</span><br><span class="line"><span class="keyword">if</span> (lastOne&gt;end) &#123;</span><br><span class="line">lastOne  = end;</span><br><span class="line">&#125;</span><br><span class="line">CountTask subTask = <span class="keyword">new</span> CountTask(pos, lastOne);</span><br><span class="line">pos += step + <span class="number">1</span>;</span><br><span class="line">subTasks.add(subTask);</span><br><span class="line"><span class="comment">//将现任务加进去</span></span><br><span class="line">subTask.fork();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (CountTask t : subTasks) &#123;</span><br><span class="line"><span class="comment">//等待所有的任务完成后再继续相应的操作</span></span><br><span class="line">sum += t.join();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">CountTask task = <span class="keyword">new</span> CountTask(<span class="number">0</span>, <span class="number">20000</span>L);</span><br><span class="line">ForkJoinTask&lt;Long&gt; result = forkJoinPool.submit(task);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">long res = result.get();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"sum="</span>+res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=<span class="number">200010000</span></span><br></pre></td></tr></table></figure><p>上面的例子要实现的是将 CountTask task = new CountTask(0, 20000L);<br>这句话中的start到end进行累加运算，如果end-start&lt;ThRESHOLD,就直接累加，如果超过这个阈值就通过ForkJoin将任务分成多个子任务，进行累加，所有的子任务完成之后再求和。</p><h2 id="4-4-实现要素"><a href="#4-4-实现要素" class="headerlink" title="4.4. 实现要素"></a>4.4. 实现要素</h2><p>源码解析<br>在ForkJoin中每个线程都有一个相关的工作队列WorkQueue在ForkJoinPool中有这个内部类</p><h3 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">@sun.misc.Contended</span><br><span class="line">    <span class="keyword">static</span> final <span class="class"><span class="keyword">class</span> <span class="title">WorkQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Capacity of work-stealing queue array upon initialization.</span></span><br><span class="line"><span class="comment">         * Must be a power of two; at least 4, but should be larger to</span></span><br><span class="line"><span class="comment">         * reduce or eliminate cacheline sharing among queues.</span></span><br><span class="line"><span class="comment">         * Currently, it is much larger, as a partial workaround for</span></span><br><span class="line"><span class="comment">         * the fact that JVMs often place arrays in locations that</span></span><br><span class="line"><span class="comment">         * share GC bookkeeping (especially cardmarks) such that</span></span><br><span class="line"><span class="comment">         * per-write accesses encounter serious memory contention.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> final int INITIAL_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Maximum size for queue arrays. Must be a power of two less</span></span><br><span class="line"><span class="comment">         * than or equal to 1 &lt;&lt; (31 - width of array entry) to ensure</span></span><br><span class="line"><span class="comment">         * lack of wraparound of index calculations, but defined to a</span></span><br><span class="line"><span class="comment">         * value a bit less than this to help users trap runaway</span></span><br><span class="line"><span class="comment">         * programs before saturating systems.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> final int MAXIMUM_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">26</span>; <span class="comment">// 64M</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instance fields</span></span><br><span class="line">        volatile int scanState;    <span class="comment">// versioned, &lt;0: inactive; odd:scanning</span></span><br><span class="line">        int stackPred;            <span class="comment">// 记录前一个栈顶的ctl</span></span><br><span class="line"></span><br><span class="line">        int nsteals;               <span class="comment">// number of steals</span></span><br><span class="line">        int hint;                  <span class="comment">// randomization and stealer index hint</span></span><br><span class="line">        int config;                <span class="comment">// pool index and mode</span></span><br><span class="line">        volatile int qlock;        <span class="comment">// 1: locked, &lt; 0: terminate; else 0</span></span><br><span class="line">        volatile int base;         <span class="comment">// index of next slot for poll</span></span><br><span class="line">        int top;                   <span class="comment">// index of next slot for push</span></span><br><span class="line">        ForkJoinTask&lt;?&gt;[] array;   <span class="comment">// the elements (initially unallocated)</span></span><br><span class="line">        final ForkJoinPool pool;   <span class="comment">// the containing pool (may be null)</span></span><br><span class="line">        final ForkJoinWorkerThread owner; <span class="comment">// owning thread or null if shared</span></span><br><span class="line">        volatile Thread parker;    <span class="comment">// == owner during call to park; else null</span></span><br><span class="line">        volatile ForkJoinTask&lt;?&gt; currentJoin;  <span class="comment">// task being joined in awaitJoin</span></span><br><span class="line">        volatile ForkJoinTask&lt;?&gt; currentSteal; <span class="comment">// mainly used by helpStealer</span></span><br><span class="line"></span><br><span class="line">        WorkQueue(ForkJoinPool pool, ForkJoinWorkerThread owner) &#123;</span><br><span class="line">            <span class="keyword">this</span>.pool = pool;</span><br><span class="line">            <span class="keyword">this</span>.owner = owner;</span><br><span class="line">            <span class="comment">// Place indices in the center of array (that is not yet allocated)</span></span><br><span class="line">            base = top = INITIAL_QUEUE_CAPACITY &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns an exportable index (used by ForkJoinWorkerThread).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        final int getPoolIndex() &#123;</span><br><span class="line">            <span class="keyword">return</span> (config &amp; <span class="number">0xffff</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// ignore odd/even tag bit</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns the approximate number of tasks in the queue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        final int queueSize() &#123;</span><br><span class="line">            int n = base - top;       <span class="comment">// non-owner callers must read base first</span></span><br><span class="line">            <span class="keyword">return</span> (n &gt;= <span class="number">0</span>) ? <span class="number">0</span> : -n; <span class="comment">// ignore transient negative</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Provides a more accurate estimate of whether this queue has</span></span><br><span class="line"><span class="comment">         * any tasks than does queueSize, by checking whether a</span></span><br><span class="line"><span class="comment">         * near-empty queue has at least one unclaimed task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        final boolean isEmpty() &#123;</span><br><span class="line">            ForkJoinTask&lt;?&gt;[] a; int n, m, s;</span><br><span class="line">            <span class="keyword">return</span> ((n = base - (s = top)) &gt;= <span class="number">0</span> ||</span><br><span class="line">                    (n == <span class="number">-1</span> &amp;&amp;           <span class="comment">// possibly one task</span></span><br><span class="line">                     ((a = array) == <span class="literal">null</span> || (m = a.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                      U.getObject</span><br><span class="line">                      (a, (long)((m &amp; (s - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE) == <span class="literal">null</span>)));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red">注意：上面的代码出自我本人idea jdk1.8，但是和视频中讲解的jdk1.8代码片不一样，主要讲解了workqueue中的某些字段，线面的讲解是视频中的字段，并非上面的代码片。</font></strong></p><p>不是所有的线程一直都在工作，有的线程有时候会被挂起，挂起的时候线程池需要知道谁被挂起，这样就可以新的任务来的时候，就从挂起的线程里面唤醒一个线程去执行，forkjoin就做这件事情，所有被挂起的线程会被放到一个栈（先进后出）里面，栈的内部是通过链表实现的，nextwait就是链表中很重要的一个东西，会指向下一个等待的线程，poolindex，当前线程在线程池中的id编号，eventcount，当前的线程被挂起了多少次，每次被挂起都会做一个累加如果小于0，就是inactive的状态（没有被激活，）eventcount还有一个含义，就是当前的poolindex是多少，在相关的代码片中（我这里实在是找不到）在注册的时候poolindex和eventactive是赋予了同一个值，eventcount是一个32位的数字，第一个bite表示是否被激活，其他的bite表示poolindex，所有的内容放在array中，array中的base和top中间使我们的线程</p><h3 id="ctl"><a href="#ctl" class="headerlink" title="ctl"></a>ctl</h3><p>在ForkJoinPool中同样有和上面的threadPool一样的ctl的字段<br>并不是原子的整数，是lang型的<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//* Bits and masks for field ctl, packed with 4 16 bit subfields:</span></span><br><span class="line">     <span class="comment">//* AC: Number of active running workers minus target parallelism 活跃的线程数减去目标并行度（大概就是几个cpu就是几个并行度）</span></span><br><span class="line">     <span class="comment">//* TC: Number of total workers minus target parallelism总的线程数减去目标并行度（大概就是几个cpu就是几个并行度）</span></span><br><span class="line">     <span class="comment">//* SS: version count and status of top waiting thread线程池本身是否是激活的</span></span><br><span class="line">     <span class="comment">//EC eventcount顶部等待的堆栈顶端的线程的eventcount的值</span></span><br><span class="line">     <span class="comment">//* ID: poolIndex of top of Treiber stack of waiters poolIndex顶部等待的堆栈顶端的线程的poolIndex的值</span></span><br><span class="line">     <span class="comment">//注意tc ss  id三个相加恰好是一个int，这里就是刚才所说的eventcount</span></span><br><span class="line">volatile long ctl;                   <span class="comment">// main pool control</span></span><br></pre></td></tr></table></figure><p></p><p><strong><font color="red">声明一下：<br>明明有五个变量，为什么不分成五个，一定要打包在ctl中呢？看起来增加了数据的复杂性，可读性也变差了，为什么还要这么做呢？</font></strong></p><p>因为加入多个线程来操作ForkJoin，一个操作了AC，一个操作了TC，这样如何保证AC和TC是属于一个的？用锁吗？这样对效率有很大的降低，但是如果将所有的数据放在一起，数据的一致性是一定能够保证的，读写的时候是原子性的，一次cas（无锁），就可以把所有的数据进行一次更新，并且保证不会和其他线程产生冲突，在性能上能得到大大的提升。通过无锁的操作，代替了多个Synchronize操作<br>目前是不支持对多个变量进行cas操作的。<br>就像如下代码<br>tryAddWorker：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">void</span> tryAddWorker(long c) &#123;</span><br><span class="line">        boolean add = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            long nc = ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">                       (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">            <span class="keyword">if</span> (ctl == c) &#123;</span><br><span class="line">                int rs, stop;                 <span class="comment">// check if terminating</span></span><br><span class="line">                <span class="keyword">if</span> ((stop = (rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                    add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">                unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">                <span class="keyword">if</span> (stop != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (add) &#123;</span><br><span class="line">                    createWorker();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (((c = ctl) &amp; ADD_WORKER) != <span class="number">0</span>L &amp;&amp; (int)c == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>先将ctl中的每一个取出来做相应的操作，在叠加到一起进行cas的操作。</p><h3 id="4-4-1-工作窃取"><a href="#4-4-1-工作窃取" class="headerlink" title="4.4.1. 工作窃取"></a>4.4.1. 工作窃取</h3><p><img alt="" data-original="../images/15499798120897.png"></p><p>scan方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">private ForkJoinTask&lt;?&gt; scan(WorkQueue w, int r) &#123;</span><br><span class="line">        WorkQueue[] ws; int m;</span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; w != <span class="literal">null</span>) &#123;</span><br><span class="line">            int ss = w.scanState;                     <span class="comment">// initially non-negative</span></span><br><span class="line">            <span class="keyword">for</span> (int origin = r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">                WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">                int b, n; long c;</span><br><span class="line">                <span class="keyword">if</span> ((q = ws[k]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((n = (b = q.base) - q.top) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        (a = q.array) != <span class="literal">null</span>) &#123;      <span class="comment">// non-empty</span></span><br><span class="line">                        long i = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                        <span class="keyword">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                                  U.getObjectVolatile(a, i))) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                            q.base == b) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (ss &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="literal">null</span>)) &#123;</span><br><span class="line">                                    q.base = b + <span class="number">1</span>;</span><br><span class="line">                                    <span class="keyword">if</span> (n &lt; <span class="number">-1</span>)       <span class="comment">// signal others</span></span><br><span class="line">                                        signalWork(ws, q);</span><br><span class="line">                                        runtask（）;</span><br><span class="line">                                    <span class="comment">//下面解释</span></span><br><span class="line">                                    <span class="keyword">return</span> t;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span> (oldSum == <span class="number">0</span> &amp;&amp;   <span class="comment">// try to activate</span></span><br><span class="line">                                     w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                                tryRelease(c = ctl, ws[m &amp; (int)c], AC_UNIT);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (ss &lt; <span class="number">0</span>)                   <span class="comment">// refresh</span></span><br><span class="line">                            ss = w.scanState;</span><br><span class="line">                        r ^= r &lt;&lt; <span class="number">1</span>; r ^= r &gt;&gt;&gt; <span class="number">3</span>; r ^= r &lt;&lt; <span class="number">10</span>;</span><br><span class="line">                        origin = k = r &amp; m;           <span class="comment">// move and rescan</span></span><br><span class="line">                        oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    checkSum += b;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">//如果scan操作没有任务的话，activecount就减一，然后将poolindex，nextwait，等堆栈信息，</span></span><br><span class="line">               <span class="comment">//保存到ctl中，并挂起当前线程。</span></span><br><span class="line">             </span><br><span class="line">                <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;    <span class="comment">// continue until stable</span></span><br><span class="line">                    <span class="keyword">if</span> ((ss &gt;= <span class="number">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">                        oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ss &lt; <span class="number">0</span> || w.qlock &lt; <span class="number">0</span>)    <span class="comment">// already inactive</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        int ns = ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line">                        <span class="comment">//UC_MASK &amp; ((c = ctl) - AC_UNIT)，activecount-1，activecount是前十六位，所以减去10000000000000，就是</span></span><br><span class="line">                        long nc = ((SP_MASK &amp; ns) |</span><br><span class="line">                                   (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class="line">                        w.stackPred = (int)c;         <span class="comment">// hold prev stack top</span></span><br><span class="line">                        U.putInt(w, QSCANSTATE, ns);</span><br><span class="line">                        <span class="comment">//然后通过rac操作将nc赋值到ctl上</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc))</span><br><span class="line">                            ss = ns;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            w.scanState = ss;         <span class="comment">// back out</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    checkSum = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>很好的体现出forkjoin是如何工作的，<br>可以看到，scan方法 虽然是在本线程，但是，是在执行其他的workqueue中的base，上面说到线程都保存在了workqueue中，就是说不是盲目的做自己的任务，还看一看周围的线程的任务是否饥饿，会有效的避免饥饿的现象发生。<br>runtask（）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Executes the given task and any remaining local tasks.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     final <span class="keyword">void</span> runTask(ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">         <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">             scanState &amp;= ~SCANNING; <span class="comment">// mark as busy</span></span><br><span class="line">             (currentSteal = task).doExec();</span><br><span class="line">             U.putOrderedObject(<span class="keyword">this</span>, QCURRENTSTEAL, <span class="literal">null</span>); <span class="comment">// release for GC</span></span><br><span class="line">             execLocalTasks();</span><br><span class="line">             ForkJoinWorkerThread thread = owner;</span><br><span class="line">             <span class="keyword">if</span> (++nsteals &lt; <span class="number">0</span>)      <span class="comment">// collect on overflow</span></span><br><span class="line">                 transferStealCount(pool);</span><br><span class="line">             scanState |= SCANNING;</span><br><span class="line">             <span class="keyword">if</span> (thread != <span class="literal">null</span>)</span><br><span class="line">                 thread.afterTopLevelExec();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><img alt="" data-original="../images/15499798252052.png"></p><p>可以看到两个队列，当前线程对应t1队列，它需要看其他队列（t2）的base节点，然后从自己的top节点开始处理，其他线程对应t2队列，则同理，这样能很好的避免冲突。<br>帮助别人做可能比自己做自己的性能要好一点。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;1-线程池的基本使用&quot;&gt;&lt;a href=&quot;#1-线程池的基本使用&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java高并发程序设计学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="高并发" scheme="http://mmmmmm.me/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>通过JAVA中的httpclient刷取CSDN博客访问量</title>
    <link href="http://mmmmmm.me/2019-02-08.html"/>
    <id>http://mmmmmm.me/2019-02-08.html</id>
    <published>2019-02-08T11:20:01.000Z</published>
    <updated>2019-02-09T08:54:43.419Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="config-properties"><a href="#config-properties" class="headerlink" title="config.properties"></a>config.properties</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">The_home_page=https:<span class="comment">//blog.csdn.net/dataiyangu</span></span><br><span class="line">IP_And_Port=<span class="number">171.41</span><span class="number">.81</span><span class="number">.5</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">218.60</span><span class="number">.8</span><span class="number">.98</span>:<span class="number">3129</span>,\</span><br><span class="line">  <span class="number">218.60</span><span class="number">.8</span><span class="number">.99</span>:<span class="number">3129</span>,\</span><br><span class="line">  <span class="number">113.200</span><span class="number">.56</span><span class="number">.13</span>:<span class="number">8010</span>,\</span><br><span class="line">  <span class="number">171.41</span><span class="number">.82</span><span class="number">.89</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">1.48</span><span class="number">.150</span><span class="number">.228</span>:<span class="number">8118</span>,\</span><br><span class="line">  <span class="number">171.41</span><span class="number">.82</span><span class="number">.169</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">115.151</span><span class="number">.2</span><span class="number">.133</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">59.62</span><span class="number">.167</span><span class="number">.5</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">110.52</span><span class="number">.235</span><span class="number">.121</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">124.235</span><span class="number">.135</span><span class="number">.87</span>:<span class="number">80</span>,\</span><br><span class="line">  <span class="number">171.41</span><span class="number">.86</span><span class="number">.55</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">125.123</span><span class="number">.141</span><span class="number">.4</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">111.177</span><span class="number">.179</span><span class="number">.9</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">121.61</span><span class="number">.3</span><span class="number">.130</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">116.209</span><span class="number">.56</span><span class="number">.53</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">110.52</span><span class="number">.235</span><span class="number">.241</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">124.206</span><span class="number">.234</span><span class="number">.126</span>:<span class="number">3128</span>,\</span><br><span class="line">  <span class="number">110.52</span><span class="number">.235</span><span class="number">.150</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">218.204</span><span class="number">.204</span><span class="number">.90</span>:<span class="number">8118</span>,\</span><br><span class="line">  <span class="number">125.123</span><span class="number">.139</span><span class="number">.235</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">116.209</span><span class="number">.58</span><span class="number">.107</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">116.209</span><span class="number">.57</span><span class="number">.207</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">121.61</span><span class="number">.27</span><span class="number">.200</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">110.52</span><span class="number">.235</span><span class="number">.146</span>:<span class="number">9999</span>,\</span><br><span class="line">  <span class="number">121.254</span><span class="number">.214</span><span class="number">.219</span>:<span class="number">80</span>,\</span><br><span class="line">  <span class="number">66.70</span><span class="number">.147</span><span class="number">.197</span>:<span class="number">3128</span>,\</span><br><span class="line">  <span class="number">152.231</span><span class="number">.81</span><span class="number">.122</span>:<span class="number">53281</span>,\</span><br><span class="line">  <span class="number">91.134</span><span class="number">.137</span><span class="number">.31</span>:<span class="number">8118</span>,\</span><br><span class="line">  <span class="number">71.13</span><span class="number">.112</span><span class="number">.152</span>:<span class="number">3128</span>,\</span><br><span class="line">  <span class="number">223.93</span><span class="number">.172</span><span class="number">.248</span>:<span class="number">3128</span>,\</span><br><span class="line">  <span class="number">218.60</span><span class="number">.8</span><span class="number">.98</span>:<span class="number">3129</span>,\</span><br><span class="line">  <span class="number">218.207</span><span class="number">.212</span><span class="number">.86</span>:<span class="number">80</span>,\</span><br><span class="line">  <span class="number">218.60</span><span class="number">.8</span><span class="number">.99</span>:<span class="number">3129</span>,\</span><br><span class="line">  <span class="number">205.204</span><span class="number">.248</span><span class="number">.88</span>:<span class="number">9090</span>,\</span><br><span class="line">  <span class="number">109.236</span><span class="number">.89</span><span class="number">.172</span>:<span class="number">1080</span>,\</span><br><span class="line">  <span class="number">66.119</span><span class="number">.180</span><span class="number">.101</span>:<span class="number">80</span>,\</span><br><span class="line">  <span class="number">113.200</span><span class="number">.56</span><span class="number">.13</span>:<span class="number">8010</span> ,\</span><br><span class="line">  <span class="number">120.52</span><span class="number">.73</span><span class="number">.1</span>:<span class="number">80</span> ,\</span><br><span class="line">  <span class="number">66.119</span><span class="number">.180</span><span class="number">.103</span>:<span class="number">80</span> ,\</span><br><span class="line">  <span class="number">70.29</span><span class="number">.69</span><span class="number">.120</span>:<span class="number">80</span> ,\</span><br><span class="line">  <span class="number">66.119</span><span class="number">.180</span><span class="number">.104</span>:<span class="number">80</span> ,\</span><br><span class="line">  <span class="number">212.237</span><span class="number">.33</span><span class="number">.61</span>:<span class="number">3128</span> ,\</span><br><span class="line">  <span class="number">205.204</span><span class="number">.248</span><span class="number">.76</span>:<span class="number">9090</span> ,\</span><br><span class="line">  <span class="number">94.130</span><span class="number">.14</span><span class="number">.146</span>:<span class="number">31288</span> ,\</span><br><span class="line">  <span class="number">54.39</span><span class="number">.40</span><span class="number">.100</span>:<span class="number">80</span> ,\</span><br><span class="line">  <span class="number">103.205</span><span class="number">.26</span><span class="number">.120</span>:<span class="number">80</span> ,\</span><br><span class="line">  <span class="number">51.254</span><span class="number">.92</span><span class="number">.205</span>:<span class="number">1080</span></span><br></pre></td></tr></table></figure><h1 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketTimeoutException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CSDN</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> Properties getProperties() &#123;</span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">InputStream resourceAsStream = CSDN.class.getResourceAsStream(<span class="string">"config.properties"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">properties.load(resourceAsStream);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> properties;</span><br><span class="line">&#125;</span><br><span class="line">private <span class="built_in">String</span> zhuye;</span><br><span class="line">private <span class="built_in">String</span> sousuo = <span class="string">"/article/details/"</span>;</span><br><span class="line">public CSDN() &#123;</span><br><span class="line">zhuye = getProperties().getProperty(<span class="string">"The_home_page"</span>);</span><br><span class="line">&#125;</span><br><span class="line">public CSDN(<span class="built_in">String</span> url) &#123;</span><br><span class="line">zhuye = url;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="built_in">String</span> getZhuye() &#123;</span><br><span class="line"><span class="keyword">return</span> zhuye;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> setZhuye(<span class="built_in">String</span> zhuye) &#123;</span><br><span class="line"><span class="keyword">this</span>.zhuye = zhuye;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="built_in">String</span> getSousuo() &#123;</span><br><span class="line"><span class="keyword">return</span> sousuo;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">void</span> setSousuo(<span class="built_in">String</span> sousuo) &#123;</span><br><span class="line"><span class="keyword">this</span>.sousuo = sousuo;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="built_in">String</span> open(<span class="built_in">String</span> url) &#123;</span><br><span class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">BufferedReader <span class="keyword">in</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*原来的代码*/</span></span><br><span class="line"><span class="comment">//in = new BufferedReader(new InputStreamReader(u.openStream(), "UTF-8"));</span></span><br><span class="line">HttpURLConnection htpcon = (HttpURLConnection) u.openConnection();</span><br><span class="line">htpcon.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">htpcon.setDoOutput(<span class="literal">true</span>);</span><br><span class="line">htpcon.setDoInput(<span class="literal">true</span>);</span><br><span class="line">htpcon.setUseCaches(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//没有看到调用的地方，应该是在将之前的连接动态的排除异常</span></span><br><span class="line">htpcon.setConnectTimeout(<span class="number">10000</span>);</span><br><span class="line">htpcon.setReadTimeout(<span class="number">10000</span>);</span><br><span class="line">InputStream inputStream = htpcon.getInputStream();</span><br><span class="line"><span class="keyword">in</span> = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">"UTF-8"</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"本次请求超时了，别要慌张。"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"超时了"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">in</span> != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">String</span> s = <span class="keyword">in</span>.readLine();</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> str.append(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"上面的这个代理失效了，请更换。"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"上面的这个代理失效了，请更换。"</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">in</span> != <span class="literal">null</span>) <span class="keyword">in</span>.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public HashSet&lt;<span class="built_in">String</span>&gt; sousuoHTML(<span class="built_in">String</span> str) &#123;</span><br><span class="line">HashSet&lt;<span class="built_in">String</span>&gt; set = <span class="keyword">new</span> HashSet&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">int st, end;</span><br><span class="line"><span class="keyword">while</span> ((st = str.indexOf(zhuye + sousuo)) != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((end = str.indexOf(<span class="string">"\""</span>, st)) != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">String</span> s = str.substring(st, end);</span><br><span class="line"><span class="keyword">if</span> (s.indexOf(<span class="string">"#comments"</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">s = s.substring(<span class="number">0</span>, s.indexOf(<span class="string">"#comments"</span>));</span><br><span class="line">&#125;</span><br><span class="line">set.add(s);</span><br><span class="line">str = str.substring(end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getFangke() &#123;</span><br><span class="line"><span class="built_in">String</span> str = open(zhuye);</span><br><span class="line">int i;</span><br><span class="line"><span class="keyword">if</span> ((i = str.indexOf(<span class="string">"访问："</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">str = str.substring(i);</span><br><span class="line">str = str.substring(str.indexOf(<span class="string">"\""</span>) + <span class="number">1</span>);</span><br><span class="line">str = str.substring(<span class="number">0</span>, str.indexOf(<span class="string">"\""</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((i = str.indexOf(<span class="string">"personal_list"</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">str = str.substring(i);</span><br><span class="line">str.substring(str.indexOf(<span class="string">"&lt;em&gt;"</span>) + <span class="number">4</span>, str.indexOf(<span class="string">"&lt;/em&gt;"</span>));</span><br><span class="line">&#125;</span><br><span class="line">int ii = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ii = Integer.parseInt(str);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ii;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> daili(<span class="built_in">String</span> ip, <span class="built_in">String</span> dk) &#123;</span><br><span class="line">Properties prop = System.getProperties();</span><br><span class="line"><span class="comment">// 设置http访问要使用的代理服务器的地址</span></span><br><span class="line">prop.setProperty(<span class="string">"http.proxyHost"</span>, ip);</span><br><span class="line"><span class="comment">// 设置http访问要使用的代理服务器的端口</span></span><br><span class="line">prop.setProperty(<span class="string">"http.proxyPort"</span>, dk);</span><br><span class="line"><span class="comment">// 设置不需要通过代理服务器访问的主机，可以使用*通配符，多个地址用|分隔</span></span><br><span class="line">prop.setProperty(<span class="string">"http.nonProxyHosts"</span>, <span class="string">"localhost|192.168.168.*"</span>);</span><br><span class="line"><span class="comment">// 设置安全访问使用的代理服务器地址与端口</span></span><br><span class="line"><span class="comment">// 它没有https.nonProxyHosts属性，它按照http.nonProxyHosts 中设置的规则访问</span></span><br><span class="line">prop.setProperty(<span class="string">"https.proxyHost"</span>, ip);</span><br><span class="line">prop.setProperty(<span class="string">"https.proxyPort"</span>, dk);</span><br><span class="line"><span class="comment">// 使用ftp代理服务器的主机、端口以及不需要使用ftp代理服务器的主机</span></span><br><span class="line">prop.setProperty(<span class="string">"ftp.proxyHost"</span>, ip);</span><br><span class="line">prop.setProperty(<span class="string">"ftp.proxyPort"</span>, dk);</span><br><span class="line">prop.setProperty(<span class="string">"ftp.nonProxyHosts"</span>, <span class="string">"localhost|192.168.168.*"</span>);</span><br><span class="line"><span class="comment">// socks代理服务器的地址与端口</span></span><br><span class="line">prop.setProperty(<span class="string">"socksProxyHost"</span>, ip);</span><br><span class="line">prop.setProperty(<span class="string">"socksProxyPort"</span>, dk);</span><br><span class="line">System.out.println(<span class="string">"即将开始代理进行访问 ip:"</span> + ip + <span class="string">" port:"</span> + dk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="built_in">String</span>[] dl = getProperties().getProperty(<span class="string">"IP_And_Port"</span>).split(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Main_thread</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">atomicInteger.set(<span class="number">1</span>);</span><br><span class="line">int i = <span class="number">0</span>;</span><br><span class="line">CSDN csdn = <span class="keyword">new</span> CSDN();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"当前博客访问量："</span> + csdn.getFangke()+<span class="string">""</span>);</span><br><span class="line">long a = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dl.length; i++) &#123;</span><br><span class="line"><span class="built_in">String</span>[] dd = dl[i].split(<span class="string">":"</span>);</span><br><span class="line">csdn.daili(dd[<span class="number">0</span>], dd[<span class="number">1</span>]);</span><br><span class="line">HashSet&lt;<span class="built_in">String</span>&gt; set = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">set = csdn.sousuoHTML(csdn.open(csdn.getZhuye()));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">"上面的这个代理失效了，请更换。。。"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">String</span> url : set) &#123;</span><br><span class="line">csdn.open(url);</span><br><span class="line">System.out.println(<span class="string">"正在打开："</span> + url);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"---------------------------------------------------------------------------"</span>);</span><br><span class="line">System.out.println(<span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"所有的代理已经访问："</span> + atomicInteger.getAndIncrement()+<span class="string">"次"</span>);</span><br><span class="line"><span class="keyword">if</span> (csdn.getFangke() != <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"当前博客访问量："</span> + csdn.getFangke()+<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">long b = System.currentTimeMillis();</span><br><span class="line">long c = b - a;</span><br><span class="line">System.out.println(<span class="string">"本次代理请求耗时："</span>+c+<span class="string">"秒"</span>);</span><br><span class="line"><span class="keyword">if</span>(c&gt;<span class="number">10000</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">double v = <span class="built_in">Math</span>.random() * <span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">"即将休息："</span>+(long) (v*<span class="number">1000</span>)+<span class="string">"毫秒"</span>);</span><br><span class="line">Thread.sleep((long) (v*<span class="number">1000</span>));</span><br><span class="line">System.out.println(<span class="string">"休息完成，即将开始下轮访问。"</span>);</span><br><span class="line">System.out.println(<span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"---------------------------------------------------------------------------"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span> );</span><br><span class="line">Main_thread main_thread = <span class="keyword">new</span> Main_thread();</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">executorService.execute(main_thread);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>只需要将上面两个文件放在java项目中的同一目录下，修改配置文件中的博客地址和代理ip、port即可。<br>然后将项目打成jar包，放到自己服务器上<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar xxx.jar</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;config-properties&quot;&gt;&lt;a href=&quot;#config-properties&quot; class=&quot;he
      
    
    </summary>
    
      <category term="折腾" scheme="http://mmmmmm.me/categories/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="折腾" scheme="http://mmmmmm.me/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>hexo next主题深度优化(十一)，next主题中加入scrollReveal.js，让文章随着鼠标的滚动，出现点小动作。</title>
    <link href="http://mmmmmm.me/2019-02-07.html"/>
    <id>http://mmmmmm.me/2019-02-07.html</id>
    <published>2019-02-07T11:20:01.000Z</published>
    <updated>2019-03-12T12:16:32.859Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><a href="https://mmmmmm.me">https://mmmmmm.me</a></p><h1 id="scrollReveal简单介绍以及简单操作"><a href="#scrollReveal简单介绍以及简单操作" class="headerlink" title="scrollReveal简单介绍以及简单操作"></a>scrollReveal简单介绍以及简单操作</h1><p>就是在鼠标滑动的时候，页面中的某个模块会动态的加载出来，不会显得那么突兀，增加页面的动态效果。</p><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><p><a href="http://www.dowebok.com/134.html" target="_blank" rel="noopener">http://www.dowebok.com/134.html</a><br><a href="https://blog.csdn.net/lp2659359879/article/details/52582892" target="_blank" rel="noopener">https://blog.csdn.net/lp2659359879/article/details/52582892</a></p><h1 id="next主题中加入scrollReveal"><a href="#next主题中加入scrollReveal" class="headerlink" title="next主题中加入scrollReveal"></a>next主题中加入scrollReveal</h1><h2 id="给article标签添加属性"><a href="#给article标签添加属性" class="headerlink" title="给article标签添加属性"></a>给article标签添加属性</h2><p>进入目录themes/next/layout/_macro/post.swig<br>搜索到article标签的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;article data-scroll-reveal=<span class="string">"enter bottom move 60px over 0.6s after 0.05s"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123;&#123; post_class &#125;&#125;"</span> itemscope itemtype=<span class="string">"http://schema.org/Article"</span>&gt;</span><br></pre></td></tr></table></figure><p>如上面的代码data-scroll-reveal=”enter bottom move 60px over 0.6s after 0.05s”，具体的值自行修改。</p><h2 id="给底部的不蒜子添加属性"><a href="#给底部的不蒜子添加属性" class="headerlink" title="给底部的不蒜子添加属性"></a>给底部的不蒜子添加属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.busuanzi_count.enable %&#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"busuanzi-count"</span>&gt;</span><br><span class="line">  &lt;script <span class="keyword">async</span> src=<span class="string">"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &#123;% <span class="keyword">if</span> theme.busuanzi_count.site_uv %&#125;</span><br><span class="line">    &lt;span data-scroll-reveal=<span class="string">"enter left move 60px over 1s after 0.05s"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"site-uv"</span>&gt;</span><br><span class="line">      &#123;&#123; theme.busuanzi_count.site_uv_header &#125;&#125;</span><br><span class="line">      &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"busuanzi-value"</span> id=<span class="string">"busuanzi_value_site_uv"</span>&gt;&lt;/span&gt;</span><br><span class="line">      &#123;&#123; theme.busuanzi_count.site_uv_footer &#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &#123;% endif %&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  &#123;% if theme.busuanzi_count.site_pv %&#125;</span></span><br><span class="line"><span class="regexp">    &lt;span data-scroll-reveal="enter right move 60px over 1s after 0.05s" class="site-pv"&gt;</span></span><br><span class="line"><span class="regexp">      &#123;&#123; theme.busuanzi_count.site_pv_header &#125;&#125;</span></span><br><span class="line"><span class="regexp">      &lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/</span>span&gt;</span><br><span class="line">      &#123;&#123; theme.busuanzi_count.site_pv_footer &#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &#123;% endif %&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>注意这里最好设置为60px，因为太大的话会导致移动端的盒子变大，宽度就会被撑开了。</p><h2 id="本地引入依赖并且编写启动函数"><a href="#本地引入依赖并且编写启动函数" class="headerlink" title="本地引入依赖并且编写启动函数"></a>本地引入依赖并且编写启动函数</h2><p>目录如图：<br><img alt="" data-original="../images/15495295478467.png"></p><p>scrollReveal是我们需要引入的官方的js<br>my_scrollReveal.js（我自定义的启动函数）如下<br>tip:这里我尝试通过js将data-scroll-reveal动态的加入到article中，可能是因为 window.scrollReveal 初始化的操作，会导致报错（数组越界），所以最后通过直接在post.swig文件中添加属性。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果刷新的页面不是首页，即点进去的文章的话，就不进行scrollReveal的操作</span></span><br><span class="line"><span class="comment">//因为在点进去的文章还是article标签包着的。</span></span><br><span class="line"><span class="comment">//我这里是根据pathname即浏览器访问地址进行判断的</span></span><br><span class="line"><span class="keyword">var</span> pathname = <span class="built_in">window</span>.location.pathname</span><br><span class="line"><span class="keyword">if</span> (pathname.indexOf(<span class="string">"html"</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//config默认配置，不过我用着好像不起作用，这里没有研究明白</span></span><br><span class="line">  <span class="keyword">var</span> config = &#123;</span><br><span class="line">    enter: <span class="string">'right'</span>,</span><br><span class="line">    move: <span class="string">'40px'</span>,</span><br><span class="line">    over: <span class="string">'3s'</span>,</span><br><span class="line">    after: <span class="string">'5'</span>,</span><br><span class="line">    reset: <span class="literal">true</span>,</span><br><span class="line">    init: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//根据初始化配置创建一个scrollReveal对象</span></span><br><span class="line">  <span class="built_in">window</span>.scrollReveal = <span class="keyword">new</span> scrollReveal(config);</span><br><span class="line">  <span class="comment">//初始化，会自动去页面中找到含有 data-scroll-reveal 属性的地方进行相关的操作。</span></span><br><span class="line">  scrollReveal.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="修改require-js主函数"><a href="#修改require-js主函数" class="headerlink" title="修改require.js主函数"></a>修改require.js主函数</h2><p>因为在我的next中我应用了require，所以经引用上面两个js的操作放到了这里。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  waitSeconds: <span class="number">0</span>,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">"music"</span>: <span class="string">"/dist/music"</span>,</span><br><span class="line">    <span class="comment">//目前会消耗较多的性能，以后可能会去掉。</span></span><br><span class="line">    <span class="string">"aplayer"</span>: <span class="string">"/js/src/aplayer"</span>,</span><br><span class="line">    <span class="string">"backgroudLine"</span>: <span class="string">"/js/src/backgroudLine"</span>,</span><br><span class="line">    <span class="string">"category"</span>: <span class="string">"/js/src/category"</span>,</span><br><span class="line">    <span class="string">"jquery.share.min"</span>:<span class="string">"/js/src/pjax/share/jquery.share.min"</span>,</span><br><span class="line">    <span class="comment">/*不显示图标的话替换fonts*/</span></span><br><span class="line">    <span class="string">"share"</span>:<span class="string">"/js/src/pjax/share"</span>,</span><br><span class="line">    <span class="string">"css"</span>:<span class="string">"/js/src/pjax/css"</span>,</span><br><span class="line">    <span class="string">"comments"</span>:<span class="string">"/js/src/pjax/comments_git"</span>,</span><br><span class="line">    <span class="string">"love"</span>:<span class="string">"/js/src/love"</span>,</span><br><span class="line">    <span class="string">"eye"</span>:<span class="string">"/js/src/pjax/eye"</span>,</span><br><span class="line">    <span class="string">"header_left"</span>:<span class="string">"/js/src/pjax/header_left"</span>,</span><br><span class="line">    <span class="string">"article_top"</span>:<span class="string">"/js/src/pjax/article_top"</span>,</span><br><span class="line">    <span class="string">"easing"</span>:<span class="string">"/js/src/pjax/easing/jquery.easing.1.3"</span>,</span><br><span class="line">    <span class="string">"scrollReveal"</span>:<span class="string">"/js/src/pjax/scrollReveal/scrollReveal"</span>,</span><br><span class="line">    <span class="string">"my_scrollReveal"</span>:<span class="string">"/js/src/pjax/scrollReveal/my_scrollReveal"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  shim: &#123;</span><br><span class="line">    <span class="string">'share'</span>: &#123;</span><br><span class="line">      deps: [</span><br><span class="line">        <span class="string">'css!/js/src/pjax/share/share.min'</span>,<span class="string">'jquery.share.min'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'comments'</span>: &#123;</span><br><span class="line">      deps: [</span><br><span class="line">        <span class="string">'css!/js/src/pjax/comments/gitalk'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'header_left'</span>: &#123;</span><br><span class="line">      deps: [</span><br><span class="line">        <span class="string">'easing'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'my_scrollReveal'</span>:&#123;</span><br><span class="line">      deps:[</span><br><span class="line">        <span class="string">'scrollReveal'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">require</span>([<span class="string">'backgroudLine'</span>,<span class="string">'music'</span>,<span class="string">'aplayer'</span>,<span class="string">'category'</span>,<span class="string">'jquery.share.min'</span>,<span class="string">'share'</span>,<span class="string">'css'</span>,<span class="string">'comments'</span>,<span class="string">'love'</span>,<span class="string">'eye'</span>,</span><br><span class="line"><span class="string">'header_left'</span>,<span class="string">'article_top'</span>,<span class="string">'easing'</span>,<span class="string">'scrollReveal'</span>,<span class="string">'my_scrollReveal'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>在最后加入了scrollReveal和my_scrollReveal这两个函数，分别对应于引入官方的js和自定义的启动函数。</p><h1 id="修改pjax的函数"><a href="#修改pjax的函数" class="headerlink" title="修改pjax的函数"></a>修改pjax的函数</h1><p>如果没有加入pjax的看到上面就结束了，我这里应用的pjax所以记录下。<br>通过require引入的方式，发现并不能成功，<br>并且报错：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pjaxMain.js:<span class="number">78</span> Uncaught <span class="built_in">TypeError</span>: scrollReveal is not a <span class="keyword">constructor</span></span><br><span class="line">    at pjaxMain.js:78</span><br><span class="line">    at Object.execCb (require.js:30)</span><br><span class="line">    at $.check (require.js:19)</span><br><span class="line">    at $.enable (require.js:24)</span><br><span class="line">    at $.init (require.js:18)</span><br><span class="line">    at require.js:27</span><br></pre></td></tr></table></figure><p></p><p>也是是说并没有定义，而且有时候会出现pjax处理后第一次没问题，第二次就又会报出同样的错误。<br>最后解决的方法是将上面官方的js和自己写的js封装在一个函数中然后通过我的pjax函数进行引用（跳转和回退）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*pjax主函数*/</span></span><br><span class="line">$(<span class="built_in">document</span>).pjax(<span class="string">'a[target!=_blank]'</span>, <span class="string">'#pjax-container'</span>, &#123;</span><br><span class="line">  fragment: <span class="string">'#pjax-container'</span>,</span><br><span class="line">  timeout: <span class="number">5000</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//用户通过浏览器的前进后退按钮，需要加载的js</span></span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'popstate.pjax'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*必须加*/</span></span><br><span class="line">  <span class="comment">// $(document).on('pjax:complete',</span></span><br><span class="line">  <span class="comment">//   function () &#123;</span></span><br><span class="line">      pjax();</span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'pjax:start'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="built_in">document</span>).unbind(<span class="string">'keyup'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'pjax:complete'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>.config(&#123;</span><br><span class="line">      waitSeconds: <span class="number">0</span>,</span><br><span class="line">      paths: &#123;</span><br><span class="line">        <span class="comment">//这个是单独的</span></span><br><span class="line">        <span class="string">"jquery.share.min"</span>:<span class="string">"/js/src/pjax/share/jquery.share.min"</span>,</span><br><span class="line">        <span class="comment">// "share":"/js/src/pjax/share",</span></span><br><span class="line">        <span class="comment">//这个也是单独的</span></span><br><span class="line">        <span class="string">"css"</span>:<span class="string">"/js/src/pjax/css"</span>,</span><br><span class="line">        <span class="string">"pjax_function_public"</span>:<span class="string">"/js/src/pjax/pjax_function_public"</span>,</span><br><span class="line">        <span class="string">"comments"</span>:<span class="string">"/js/src/pjax/comments_git"</span>,</span><br><span class="line">        <span class="string">"love"</span>:<span class="string">"/js/src/love"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      shim: &#123;</span><br><span class="line">        <span class="string">'share'</span>: &#123;</span><br><span class="line">          deps: [</span><br><span class="line">            <span class="string">'css!/js/src/pjax/share/share.min'</span>,<span class="string">'jquery.share.min'</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'comments'</span>: &#123;</span><br><span class="line">          deps: [</span><br><span class="line">            <span class="string">'css!/js/src/pjax/comments/gitalk'</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">require</span>([<span class="string">'jquery.share.min'</span>,<span class="string">'share'</span>,<span class="string">'css'</span>,<span class="string">'pjax_function_public'</span>,<span class="string">'comments'</span></span><br><span class="line">    ], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      pjax();</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*来必力评论*/</span></span><br><span class="line"> <span class="comment">//    comments_js();</span></span><br><span class="line"><span class="comment">/*gitalk评论*/</span></span><br><span class="line">  gitalk();</span><br><span class="line">  <span class="comment">//护眼</span></span><br><span class="line">  eye_js()</span><br><span class="line">    <span class="comment">//如果是文章，实现滚动效果</span></span><br><span class="line">  article_top_js();</span><br><span class="line"><span class="comment">//不蒜子</span></span><br><span class="line">  busuanzi_js();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自己写的分享</span></span><br><span class="line">  pjaxshare();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类的js</span></span><br><span class="line">  category_js();</span><br><span class="line"><span class="comment">// 局部刷新后文章内容不显示bug的js</span></span><br><span class="line">  opacity_js()</span><br><span class="line"><span class="comment">//点击有目录的文章sidebar不显示的bug解决</span></span><br><span class="line">  motion_js()</span><br><span class="line">  scrollspy_js()</span><br><span class="line">  <span class="comment">//utils_js()</span></span><br><span class="line">  postdetails_js()</span><br><span class="line"><span class="comment">//lean数量统计的js，原来的js是在themes/next/layout/_third-party/analytics/lean-analytics.swig文件中</span></span><br><span class="line">  lean_analytics();</span><br><span class="line">  <span class="comment">//百度推送js</span></span><br><span class="line">  baidutuisong();</span><br><span class="line"><span class="comment">//     //右边sidebar滚轮效果消失了。</span></span><br><span class="line">  initSidebarDimension()</span><br><span class="line">  <span class="comment">//懒加载</span></span><br><span class="line">  lazyLoad();</span><br><span class="line">  <span class="comment">//捐赠的函数</span></span><br><span class="line">  donate();</span><br><span class="line">  <span class="comment">//随鼠标的滚动文章动态出现的动画</span></span><br><span class="line">  my_scrollReveal_js();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;效果&quot;&gt;&lt;a href=&quot;#效果&quot; class=&quot;headerlink&quot; title=&quot;效果&quot;&gt;&lt;/a&gt;效果&lt;/h
      
    
    </summary>
    
      <category term="hexo" scheme="http://mmmmmm.me/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://mmmmmm.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发程序设计学习笔记（五）：JDK并发包(各种同步控制工具的使用、并发容器及典型源码分析（Hashmap等）)</title>
    <link href="http://mmmmmm.me/2019-01-31-3.html"/>
    <id>http://mmmmmm.me/2019-01-31-3.html</id>
    <published>2019-01-18T11:20:04.000Z</published>
    <updated>2019-03-12T12:16:32.777Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="1-各种同步控制工具的使用"><a href="#1-各种同步控制工具的使用" class="headerlink" title="1. 各种同步控制工具的使用"></a>1. 各种同步控制工具的使用</h1><h2 id="1-1-ReentrantLock"><a href="#1-1-ReentrantLock" class="headerlink" title="1.1. ReentrantLock"></a>1.1. ReentrantLock</h2><p>在synchronize的基础上新加了功能，如果是特别简单的场景，两者是没有太大的区别的。</p><h3 id="1-1-1-可重入"><a href="#1-1-1-可重入" class="headerlink" title="1.1.1.可重入"></a>1.1.1.可重入</h3><p>单线程可以重复进入，但要重复退出<br>对于同一个线程，自己是可以重复进入的，否则会把自己卡死。<br>结论：<br>重入锁是可重复获得资源的锁，已经获得锁的线程可以对当前的资源重入加锁而不会引起阻塞；不可重入锁是不可重复获得资源的锁，当已经获得锁的线程对当前资源再次加锁时，会把自己阻塞</p><p>广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。ReentrantLock和synchronized都是可重入锁，下面是一个用synchronized实现的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ReentrantTest</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    public synchronized <span class="keyword">void</span> get() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        set();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized <span class="keyword">void</span> set() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> run() &#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        ReentrantTest rt = <span class="keyword">new</span> ReentrantTest();</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(rt).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个过程没有发生死锁的情况，截取一部分输出结果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread<span class="number">-8492</span></span><br><span class="line">Thread<span class="number">-8492</span></span><br><span class="line">Thread<span class="number">-8494</span></span><br><span class="line">Thread<span class="number">-8494</span></span><br><span class="line">Thread<span class="number">-8495</span></span><br><span class="line">Thread<span class="number">-8495</span></span><br><span class="line">Thread<span class="number">-8493</span></span><br><span class="line">Thread<span class="number">-8493</span></span><br></pre></td></tr></table></figure><p>set()和get()同时输出了线程名称，表明即使递归使用synchronized也没有发生死锁，证明其是可重入的。</p><p>以上原文：<a href="https://blog.csdn.net/rickiyeat/article/details/78314451" target="_blank" rel="noopener">https://blog.csdn.net/rickiyeat/article/details/78314451</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">public <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">public <span class="keyword">static</span> int i = <span class="number">0</span>;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//不论如何都进行unlock</span></span><br><span class="line"><span class="comment">//加两次锁必须解锁两次。</span></span><br><span class="line">lock.unlock();</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//synchronize只要在大括号外面，出了大括号，虚拟机会自动释放锁，可是lock是通过unlock来控制什么时候释放锁</span></span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">Lock tl = <span class="keyword">new</span> Lock();</span><br><span class="line"><span class="comment">//同时开两个一样的线程</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">t1.start();t2.start();</span><br><span class="line">t1.join();t2.join();</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20000</span></span><br></pre></td></tr></table></figure><h3 id="1-1-2-可中断-lockInterruptibly"><a href="#1-1-2-可中断-lockInterruptibly" class="headerlink" title="1.1.2. 可中断 lockInterruptibly()"></a>1.1.2. 可中断 lockInterruptibly()</h3><p>在发生死锁或者其他的导致长期等待的情况，希望锁停下来的功能，synchronize没有这个功能，ReentrantLock提供了可中断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Interruptible</span>  <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">public <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">public <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">int lock;</span><br><span class="line">public Interruptible(int lock)&#123;</span><br><span class="line"><span class="keyword">this</span>.lock = lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//lock=1的时候lock1上锁,lock=2的时候lock2上锁，刚才的lock1上了锁</span></span><br><span class="line"><span class="comment">//之后还要给lock2上锁,lock2上了锁之后还要给lock1上锁，</span></span><br><span class="line"><span class="comment">// 可是lock2在lock=2的时候被locl=2拿到了，lock1在lock=1的时候</span></span><br><span class="line"><span class="comment">//被locl=1拿到了所以形成了死锁</span></span><br><span class="line"><span class="keyword">if</span> (lock == <span class="number">1</span>)&#123;</span><br><span class="line">lock1.lockInterruptibly();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">lock2.lockInterruptibly();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">lock2.lockInterruptibly();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">lock1.lockInterruptibly();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//如果lock1还拿着这把锁的话，就解掉。</span></span><br><span class="line"><span class="keyword">if</span> (lock1.isHeldByCurrentThread())</span><br><span class="line">lock1.unlock();</span><br><span class="line"><span class="keyword">if</span> (lock2.isHeldByCurrentThread())</span><br><span class="line">lock2.unlock();</span><br><span class="line">System.out.println(Thread.currentThread().getId()+<span class="string">":线程退出"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">Interruptible interruptible1 = <span class="keyword">new</span> Interruptible(<span class="number">1</span>);</span><br><span class="line">Interruptible interruptible2 = <span class="keyword">new</span> Interruptible(<span class="number">2</span>);</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(interruptible1);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(interruptible2);</span><br><span class="line">t1.start();t2.start();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">DeadlockChecker.check();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DeadlockChecker.check();如果将这句话注释，将会进行无限期的死锁。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadInfo;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadMXBean;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DeadLockChecker</span> </span>&#123;</span><br><span class="line">private final <span class="keyword">static</span> ThreadMXBean mbean = ManagementFactory.getThreadMXBean();</span><br><span class="line">final  <span class="keyword">static</span>  Runnable deadLockCheck = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">long [] deadLockedThreadIds = mbean.findDeadlockedThreads();</span><br><span class="line"><span class="keyword">if</span> (deadLockedThreadIds != <span class="literal">null</span>) &#123;</span><br><span class="line">ThreadInfo[] threadInfos = mbean.getThreadInfo(deadLockedThreadIds);</span><br><span class="line"><span class="keyword">for</span> (Thread t : Thread.getAllStackTraces().keySet()) &#123;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i&lt;threadInfos.length ; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (t.getId() == threadInfos[i].getThreadId()) &#123;</span><br><span class="line">t.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> check()&#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(deadLockCheck);</span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="1-1-3-可限时"><a href="#1-1-3-可限时" class="headerlink" title="1.1.3. 可限时"></a>1.1.3. 可限时</h3><p>超时不能获得锁，就返回false，不会永久等待构成死锁</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeLock</span> <span class="title">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">public <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//如果线程在5秒之内没有拿到锁就走else里面的内容</span></span><br><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"get lock failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">TimeLock tl = <span class="keyword">new</span> TimeLock();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(t1);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-4-公平锁"><a href="#1-1-4-公平锁" class="headerlink" title="1.1.4. 公平锁"></a>1.1.4. 公平锁</h3><p>什么是公平锁？<br>先来先得，避免产生饥饿现象，但是性能差很多。所以不是特殊情况下，不要使用公平锁。<br>public ReentrantLock(boolean fair)<br>public static ReentrantLock fairLock = new ReentrantLock(true);</p><h2 id="1-2-Condition"><a href="#1-2-Condition" class="headerlink" title="1.2. Condition"></a>1.2. Condition</h2><h3 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1. 概述"></a>1.2.1. 概述</h3><p>类似于 Object.wait()和Object.notify() 与ReentrantLock结合使用</p><h3 id="1-2-2-主要接口"><a href="#1-2-2-主要接口" class="headerlink" title="1.2.2. 主要接口"></a>1.2.2. 主要接口</h3><p>void await() throws InterruptedException;//等待<br>void awaitUninterruptibly();<br>long awaitNanos(long nanosTimeout) throws InterruptedException; boolean await(long time, TimeUnit unit) throws InterruptedException; boolean awaitUntil(Date deadline) throws InterruptedException;<br>void signal();//通知继续往下走<br>void signalAll();</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ReenTerLockCondition</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">public <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line">condition.await();</span><br><span class="line">System.out.println(<span class="string">"Thread is going on "</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">ReenTerLockCondition tl = <span class="keyword">new</span> ReenTerLockCondition();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">t1.start();</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">condition.signal();</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//必须在lock和unlock执行完了之后才会到上面将t1的锁解开。</span></span><br><span class="line"><span class="comment">//类似于之前的Synchronize代码块。</span></span><br></pre></td></tr></table></figure><h3 id="1-2-3-API详解"><a href="#1-2-3-API详解" class="headerlink" title="1.2.3. API详解"></a>1.2.3. API详解</h3><p>await()方法会使当前线程等待，同时释放当前锁，当其他线程中使用signal()时或者signalAll()方法时，线<br>程会重新获得锁并继续执行。或者当线程被中断时，也能跳出等待。这和Object.wait()方法很相似。</p><p>awaitUninterruptibly()方法与await()方法基本相同，但是它并不会再等待过程中响应中断。不会被中断。<br>singal()方法用于唤醒一个在等待中的线程。相对的singalAll()方法会唤醒所有在等待中的线程。这和Obej ct.notify()方法很类似。</p><h2 id="1-3-Semaphore"><a href="#1-3-Semaphore" class="headerlink" title="1.3. Semaphore"></a>1.3. Semaphore</h2><p><strong><font color="red">信号量<br>互斥的、排他的<br>可以有多个线程去共享这个临界区，广义上的锁，比如每个信号量指定十个许可，每个许可分配若干个线程，当然每个线程也可以持有多个许可，如果有多余的许可就可以进入，如果没有许可，后面的线程就必须等待，不能进入。<br>信号量允许多个线程进入临界区，信号量的许可等于一的时候就相当于一把锁。</font></strong></p><h3 id="1-3-1-概述"><a href="#1-3-1-概述" class="headerlink" title="1.3.1. 概述"></a>1.3.1. 概述</h3><p>共享锁 运行多个线程同时临界区</p><h3 id="1-3-2-主要接口"><a href="#1-3-2-主要接口" class="headerlink" title="1.3.2. 主要接口"></a>1.3.2. 主要接口</h3><p>public void acquire()//获得信号量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> acquire() throws InterruptedException &#123;</span><br><span class="line">       sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//也可以拿到多个许可</span></span><br><span class="line">public <span class="keyword">void</span> acquire(int permits) throws InterruptedException &#123;</span><br><span class="line">       <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       sync.acquireSharedInterruptibly(permits);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>public void acquireUninterruptibly()//不支持中断的获得信号量<br>public boolean tryAcquire()//不会等待，只是试一试，拿不到就返回false<br>public boolean tryAcquire(long timeout, TimeUnit unit)//try的时间，等待的时间，和上线功能差差不多<br>public void release()释放。<br>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span>  <span class="title">SemapDemo</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">final Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//也可以semp.acquire(2);下面将会每两个线程输出一次</span></span><br><span class="line">semp.acquire();</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getId()+<span class="string">":done!"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">semp.release();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">ExecutorService exec = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">final SemapDemo demo = <span class="keyword">new</span> SemapDemo();</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">exec.submit(demo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:done!</span><br><span class="line"><span class="number">19</span>:done!</span><br><span class="line"><span class="number">12</span>:done!</span><br><span class="line"><span class="number">10</span>:done!</span><br><span class="line"><span class="number">13</span>:done!</span><br><span class="line"><span class="number">14</span>:done!</span><br><span class="line"><span class="number">15</span>:done!</span><br><span class="line"><span class="number">18</span>:done!</span><br><span class="line"><span class="number">17</span>:done!</span><br><span class="line"><span class="number">16</span>:done!</span><br><span class="line"><span class="number">20</span>:done!</span><br><span class="line"><span class="number">22</span>:done!</span><br><span class="line"><span class="number">23</span>:done!</span><br><span class="line"><span class="number">21</span>:done!</span><br><span class="line"><span class="number">19</span>:done!</span><br><span class="line"><span class="number">25</span>:done!</span><br><span class="line"><span class="number">28</span>:done!</span><br><span class="line"><span class="number">24</span>:done!</span><br><span class="line"><span class="number">27</span>:done!</span><br><span class="line"><span class="number">26</span>:done!</span><br></pre></td></tr></table></figure><p>可以看到每五个线程输出一次，每次停留两秒，同样的如果semp.acquire(2);每个线程拿到两个许可，一共有五个许可，release（2），所以每次只有两个线程输出。</p><h2 id="1-4-ReadWriteLock"><a href="#1-4-ReadWriteLock" class="headerlink" title="1.4. ReadWriteLock"></a>1.4. ReadWriteLock</h2><p>写会修改数据，读不会修改数据，从性能上来看，如果不管读还是写都加锁，会十分影响性能，synchronized并行度只有一，一次只允许一个线程经过。如果没有写操作，这个所有的read线程必然是无等待的。</p><h3 id="1-4-1-概述"><a href="#1-4-1-概述" class="headerlink" title="1.4.1. 概述"></a>1.4.1. 概述</h3><p>ReadWriteLock是JDK5中提供的读写分离锁</p><h3 id="1-4-2-访问情况"><a href="#1-4-2-访问情况" class="headerlink" title="1.4.2. 访问情况"></a>1.4.2. 访问情况</h3><p>读-读不互斥:读读之间不阻塞。<br>读-写互斥:读阻塞写，写也会阻塞读。<br>写-写互斥:写写阻塞。<br><img alt="" data-original="../images/15488916638470.png"></p><h3 id="1-4-3-主要接口"><a href="#1-4-3-主要接口" class="headerlink" title="1.4.3. 主要接口"></a>1.4.3. 主要接口</h3><p>private static ReentrantReadWriteLock readWriteLock=newReentrantReadWriteLock();<br>private static Lock readLock = readWriteLock.readLock();<br>获得readLock，然后通过readLock.lock()惊醒操作<br>private static Lock writeLock = readWriteLock.writeLock();<br>获得readLock，然后通过readLock.lock()惊醒操作</p><h2 id="1-5-CountDownLatch"><a href="#1-5-CountDownLatch" class="headerlink" title="1.5. CountDownLatch"></a>1.5. CountDownLatch</h2><h3 id="1-5-1-概述"><a href="#1-5-1-概述" class="headerlink" title="1.5.1. 概述"></a>1.5.1. 概述</h3><p>倒数计时器 一种典型的场景就是火箭发射。在火箭发射前，为了保证万无一失，往往还要进行各项设备、仪器的检查。 只有等所有检查完毕后，引擎才能点火。这种场景就非常适合使用CountDownLatch。它可以使得点火线程 ，等待所有检查线程全部完工后，再执行</p><h3 id="1-5-2-主要接口"><a href="#1-5-2-主要接口" class="headerlink" title="1.5.2. 主要接口"></a>1.5.2. 主要接口</h3><p>static final CountDownLatch end = new CountDownLatch(10); //加入有十个检查项（十个线程）<br>end.countDown();//没通过一个就减一<br>end.await();//见到最后就返回，执行比如发射火箭的操作</p><h3 id="1-5-3-示意图"><a href="#1-5-3-示意图" class="headerlink" title="1.5.3. 示意图"></a>1.5.3. 示意图</h3><p><img alt="" data-original="../images/15488916716971.png"></p><p>主线程在这里等待，等到所有的检查任务都到达临界点之后，主线程就继续执行。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> final CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);<span class="comment">//开启十个线程来进行检查</span></span><br><span class="line"><span class="keyword">static</span> final CountDownLatchDemo demo = <span class="keyword">new</span> CountDownLatchDemo();</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)*<span class="number">1000</span>);</span><br><span class="line">System.out.println(<span class="string">"check complete"</span>);</span><br><span class="line">end.countDown();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">ExecutorService exec = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">exec.submit(demo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等待检查</span></span><br><span class="line">end.await();</span><br><span class="line"><span class="comment">//发射火箭</span></span><br><span class="line">System.out.println(<span class="string">"Fire"</span>);</span><br><span class="line">exec.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">check complete</span><br><span class="line">Fire</span><br></pre></td></tr></table></figure><h2 id="1-6-CyclicBarrier"><a href="#1-6-CyclicBarrier" class="headerlink" title="1.6. CyclicBarrier"></a>1.6. CyclicBarrier</h2><h3 id="1-6-1-概述"><a href="#1-6-1-概述" class="headerlink" title="1.6.1. 概述"></a>1.6.1. 概述</h3><p>循环栅栏 Cyclic意为循环，也就是说这个计数器可以反复使用。比如，假设我们将计数器设置为10。那么凑齐第一批1 0个线程后，计数器就会归零，然后接着凑齐下一批10个线程<br>它和CountDownLatch的区别是CountDownLatch的计数器只能有一次，而CyclicBarrier可以再重复利用。</p><h3 id="1-6-2-主要接口"><a href="#1-6-2-主要接口" class="headerlink" title="1.6.2. 主要接口"></a>1.6.2. 主要接口</h3><p>public CyclicBarrier(int parties（几个参与者相当于上一节中的10）, Runnable barrierAction（所有的线程到了之后，栅栏（系统）执行的动作）)<br>barrierAction就是当计数器一次计数完成后，系统会执行的动作<br>await() //都到了之后再往下执行</p><h3 id="1-6-3-示意图"><a href="#1-6-3-示意图" class="headerlink" title="1.6.3. 示意图"></a>1.6.3. 示意图</h3><p><img alt="" data-original="../images/15488917438815.png"></p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">private <span class="built_in">String</span> soldier;</span><br><span class="line">private final CyclicBarrier cyclic;</span><br><span class="line"></span><br><span class="line">Soldier(CyclicBarrier cyclic,<span class="built_in">String</span> soldierName) &#123;</span><br><span class="line"><span class="keyword">this</span>.soldier = soldierName;</span><br><span class="line"><span class="keyword">this</span>.cyclic = cyclic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">cyclic.await();</span><br><span class="line">doWork();</span><br><span class="line">cyclic.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> doWork()&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="built_in">Math</span>.abs(<span class="keyword">new</span> Random().nextInt()%<span class="number">10000</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(soldier+<span class="string">":任务完成"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarrierRun</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">boolean flag;</span><br><span class="line">int N;</span><br><span class="line"></span><br><span class="line">public BarrierRun(boolean flag, int N) &#123;</span><br><span class="line"><span class="keyword">this</span>.flag = flag;</span><br><span class="line"><span class="keyword">this</span>.N = N;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">System.out.println(<span class="string">"司令:[士兵"</span>+N+<span class="string">"个，任务完成！]"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"司令:[士兵"</span>+N+<span class="string">"个，集合完毕！]"</span>);</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">final int N = <span class="number">10</span>;</span><br><span class="line">Thread[] allSoldier = <span class="keyword">new</span> Thread[N];</span><br><span class="line">boolean flag = <span class="literal">false</span>;</span><br><span class="line">CyclicBarrier cyclic = <span class="keyword">new</span> CyclicBarrier(N, <span class="keyword">new</span> BarrierRun(flag, N));</span><br><span class="line">System.out.println(<span class="string">"集合队伍!"</span>);</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;N ; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"士兵"</span>+i+<span class="string">"报道！"</span>);</span><br><span class="line">allSoldier[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Soldier(cyclic, <span class="string">"士兵"</span> + i));</span><br><span class="line">allSoldier[i].start();</span><br><span class="line"><span class="comment">//if (i == 5) &#123;</span></span><br><span class="line"><span class="comment">//allSoldier[0].interrupt();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">集合队伍！</span><br><span class="line">士兵<span class="number">0</span>报道</span><br><span class="line">士兵<span class="number">1</span>报道</span><br><span class="line">士兵<span class="number">2</span>报道</span><br><span class="line">士兵<span class="number">3</span>报道</span><br><span class="line">士兵<span class="number">4</span>报道</span><br><span class="line">士兵<span class="number">5</span>报道</span><br><span class="line">士兵<span class="number">6</span>报道</span><br><span class="line">士兵<span class="number">7</span>报道</span><br><span class="line">士兵<span class="number">8</span>报道</span><br><span class="line">士兵<span class="number">9</span>报道</span><br><span class="line">司令[士兵<span class="number">10</span>个，集合完毕！]</span><br><span class="line">士兵<span class="number">2</span>：任务完成</span><br><span class="line">士兵<span class="number">7</span>：任务完成</span><br><span class="line">士兵<span class="number">0</span>：任务完成</span><br><span class="line">士兵<span class="number">4</span>：任务完成</span><br><span class="line">士兵<span class="number">3</span>：任务完成</span><br><span class="line">士兵<span class="number">9</span>：任务完成</span><br><span class="line">士兵<span class="number">6</span>：任务完成</span><br><span class="line">士兵<span class="number">8</span>：任务完成</span><br><span class="line">士兵<span class="number">1</span>：任务完成</span><br><span class="line">士兵<span class="number">5</span>：任务完成</span><br><span class="line">司令：[士兵<span class="number">10</span>个，任务完成！]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if (i == 5) &#123;</span></span><br><span class="line"><span class="comment">//allSoldier[0].interrupt();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>将这个注释打开的话<br><img alt="" data-original="../images/15488919151578.png"></p><p>第零个终端之后，将会抛出InterruptedException异常，剩下的九个线程将会抛出BrokenBarrierException异常。</p><h2 id="1-7-LockSupport"><a href="#1-7-LockSupport" class="headerlink" title="1.7. LockSupport"></a>1.7. LockSupport</h2><h3 id="1-7-1-概述"><a href="#1-7-1-概述" class="headerlink" title="1.7.1. 概述"></a>1.7.1. 概述</h3><p>比较偏底层。<br>提供线程阻塞原语<br>挂起</p><h3 id="1-7-2-主要接口"><a href="#1-7-2-主要接口" class="headerlink" title="1.7.2. 主要接口"></a>1.7.2. 主要接口</h3><p>LockSupport.park(); //停下来、挂起，将线程挂起，除非许可是可用的。<br>LockSupport.unpark(t1);//将t1继续执行，使得许可是可用的</p><h3 id="1-7-3-与suspend-比较"><a href="#1-7-3-与suspend-比较" class="headerlink" title="1.7.3. 与suspend()比较"></a>1.7.3. 与suspend()比较</h3><p>LockSupport不容易引起线程冻结，suspend将来可能会被废弃。<br>有点类似于信号量中的许可，如果unpark发生在park之前，park并不会将线程阻塞住。<br>如果rewiew发生在suspend之前，suspend就不能再继续执行了，永久挂起。</p><h3 id="1-7-4-中断响应"><a href="#1-7-4-中断响应" class="headerlink" title="1.7.4. 中断响应"></a>1.7.4. 中断响应</h3><p>wait等是能够try catch 终端异常的，但是park是没有捕获这个异常的，所以：<br>能够响应中断，但不抛出异常。<br>中断响应的结果是，park()函数的返回，可以从Thread.interrupted()得到中断标志</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="built_in">Object</span> u = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t1"</span>);</span><br><span class="line"><span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">public ChangeObjectThread(<span class="built_in">String</span> name) &#123;</span><br><span class="line"><span class="keyword">super</span>.setName(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line">synchronized (u)&#123;</span><br><span class="line">System.out.println(<span class="string">"in"</span>+getName());</span><br><span class="line">LockSupport.park();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">t1.start();</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">t2.start();</span><br><span class="line">LockSupport.unpark(t1);</span><br><span class="line">LockSupport.unpark(t2);</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int <span class="number">1</span> </span><br><span class="line">int <span class="number">2</span></span><br></pre></td></tr></table></figure><p></p><p>不论unpark在park的前面还是后面都不会阻塞。</p><h2 id="1-8-ReentrantLock-的实现"><a href="#1-8-ReentrantLock-的实现" class="headerlink" title="1.8. ReentrantLock 的实现"></a>1.8. ReentrantLock 的实现</h2><h3 id="1-8-1-CAS状态"><a href="#1-8-1-CAS状态" class="headerlink" title="1.8.1. CAS状态"></a>1.8.1. CAS状态</h3><p>锁到底有没有被人占用，通过是否到达期望值，通过值是否改变来判断是否应该拿到锁。</p><h3 id="1-8-2-等待队列"><a href="#1-8-2-等待队列" class="headerlink" title="1.8.2. 等待队列"></a>1.8.2. 等待队列</h3><p>如果没有拿到锁，线程应该怎么办呢，应该进入等待的队列，如果有多个线程进来，多个线程在队列中进行等待。</p><h3 id="1-8-3-park"><a href="#1-8-3-park" class="headerlink" title="1.8.3. park()"></a>1.8.3. park()</h3><p>在队列中的线程都进行park操作。unlock的时候，从等待的队列中挑出一个出来进行unpark操作。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">         * acquire on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        final <span class="keyword">void</span> lock() &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))<span class="comment">//期望值是0，更新成1</span></span><br><span class="line">            <span class="comment">//如果成功了，便能拿到锁，就能继续往下走。</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则就尝试去做申请。</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">     public final <span class="keyword">void</span> acquire(int arg) &#123;</span><br><span class="line">     <span class="comment">//在尝试一下，万一别人释放了呢？</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果尝试了还是不行就把自己放到等待队列中去</span></span><br><span class="line">      private Node addWaiter(Node mode) &#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">//放到队列的尾巴上去。</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//返回的node然后再去尝试请求锁</span></span><br><span class="line">    final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean failed = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            boolean interrupted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">//如果确实是拿不到就会在这里挂起，下面会有详细</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过park进行挂起</span></span><br><span class="line"> private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//unlock操作</span></span><br><span class="line"> public <span class="keyword">void</span> unlock() &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">  *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    public final boolean release(int arg) &#123;</span></span><br><span class="line"><span class="regexp">        if (tryRelease(arg)) &#123;</span></span><br><span class="line"><span class="regexp">            Node h = head;</span></span><br><span class="line"><span class="regexp">            if (h != null &amp;&amp; h.waitStatus != 0)</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/将队列头部的node进行unpark操作</span></span><br><span class="line"><span class="regexp">                unparkSuccessor(h);</span></span><br><span class="line"><span class="regexp">            return true;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        return false;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">private void unparkSuccessor(Node node) &#123;</span></span><br><span class="line"><span class="regexp">        /</span>*</span><br><span class="line">         * If status is negative (i.e., possibly needing signal) <span class="keyword">try</span></span><br><span class="line">         * to clear <span class="keyword">in</span> anticipation <span class="keyword">of</span> signalling.  It is OK <span class="keyword">if</span> <span class="keyword">this</span></span><br><span class="line">         * fails or <span class="keyword">if</span> status is changed by waiting thread.</span><br><span class="line">         *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        int ws = node.waitStatus;</span></span><br><span class="line"><span class="regexp">        if (ws &lt; 0)</span></span><br><span class="line"><span class="regexp">            compareAndSetWaitStatus(node, ws, 0);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        /</span>*</span><br><span class="line">         * Thread to unpark is held <span class="keyword">in</span> successor, which is normally</span><br><span class="line">         * just the next node.  But <span class="keyword">if</span> cancelled or apparently <span class="literal">null</span>,</span><br><span class="line">         * traverse backwards <span class="keyword">from</span> tail to find the actual</span><br><span class="line">         * non-cancelled successor.</span><br><span class="line">         *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        Node s = node.next;</span></span><br><span class="line"><span class="regexp">        if (s == null || s.waitStatus &gt; 0) &#123;</span></span><br><span class="line"><span class="regexp">            s = null;</span></span><br><span class="line"><span class="regexp">            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span></span><br><span class="line"><span class="regexp">                if (t.waitStatus &lt;= 0)</span></span><br><span class="line"><span class="regexp">                    s = t;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        if (s != null)</span></span><br><span class="line"><span class="regexp">            LockSupport.unpark(s.thread);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br></pre></td></tr></table></figure><h1 id="2-并发容器及典型源码分析"><a href="#2-并发容器及典型源码分析" class="headerlink" title="2. 并发容器及典型源码分析"></a>2. 并发容器及典型源码分析</h1><h2 id="2-1-集合包装"><a href="#2-1-集合包装" class="headerlink" title="2.1. 集合包装"></a>2.1. 集合包装</h2><h3 id="2-1-1-HashMap"><a href="#2-1-1-HashMap" class="headerlink" title="2.1.1. HashMap"></a>2.1.1. HashMap</h3><p>HashMap不是一个线程安全的容器，可以通过如下的方法变成线程安全的，但是只适用于并发量比较小的情况。<br>Collections.synchronizedMap<br><img alt="" data-original="../images/15488921053227.png"></p><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        private <span class="keyword">static</span> final long serialVersionUID = <span class="number">1978198479659022715</span>L;</span><br><span class="line"></span><br><span class="line">        private final <span class="built_in">Map</span>&lt;K,V&gt; m;     <span class="comment">// Backing Map</span></span><br><span class="line">        final <span class="built_in">Object</span>      mutex;        <span class="comment">// Object on which to synchronize</span></span><br><span class="line"></span><br><span class="line">        SynchronizedMap(<span class="built_in">Map</span>&lt;K,V&gt; m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">this</span>.m = m;</span><br><span class="line">            mutex = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SynchronizedMap(<span class="built_in">Map</span>&lt;K,V&gt; m, <span class="built_in">Object</span> mutex) &#123;</span><br><span class="line">            <span class="keyword">this</span>.m = m;</span><br><span class="line">            <span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int size() &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.size();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean isEmpty() &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.isEmpty();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean containsKey(<span class="built_in">Object</span> key) &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.containsKey(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean containsValue(<span class="built_in">Object</span> value) &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.containsValue(value);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public V get(<span class="built_in">Object</span> key) &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.get(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public V put(K key, V value) &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public V remove(<span class="built_in">Object</span> key) &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.remove(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public <span class="keyword">void</span> putAll(<span class="built_in">Map</span>&lt;? extends K, ? extends V&gt; map) &#123;</span><br><span class="line">            synchronized (mutex) &#123;m.putAll(map);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public <span class="keyword">void</span> clear() &#123;</span><br><span class="line">            synchronized (mutex) &#123;m.clear();&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private transient <span class="built_in">Set</span>&lt;K&gt; keySet = <span class="literal">null</span>;</span><br><span class="line">        private transient <span class="built_in">Set</span>&lt;<span class="built_in">Map</span>.Entry&lt;K,V&gt;&gt; entrySet = <span class="literal">null</span>;</span><br><span class="line">        private transient Collection&lt;V&gt; values = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        public <span class="built_in">Set</span>&lt;K&gt; keySet() &#123;</span><br><span class="line">            synchronized (mutex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (keySet==<span class="literal">null</span>)</span><br><span class="line">                    keySet = <span class="keyword">new</span> SynchronizedSet&lt;&gt;(m.keySet(), mutex);</span><br><span class="line">                <span class="keyword">return</span> keySet;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public <span class="built_in">Set</span>&lt;<span class="built_in">Map</span>.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">            synchronized (mutex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entrySet==<span class="literal">null</span>)</span><br><span class="line">                    entrySet = <span class="keyword">new</span> SynchronizedSet&lt;&gt;(m.entrySet(), mutex);</span><br><span class="line">                <span class="keyword">return</span> entrySet;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Collection&lt;V&gt; values() &#123;</span><br><span class="line">            synchronized (mutex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (values==<span class="literal">null</span>)</span><br><span class="line">                    values = <span class="keyword">new</span> SynchronizedCollection&lt;&gt;(m.values(), mutex);</span><br><span class="line">                <span class="keyword">return</span> values;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean equals(<span class="built_in">Object</span> o) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.equals(o);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public int hashCode() &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.hashCode();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public <span class="built_in">String</span> toString() &#123;</span><br><span class="line">            synchronized (mutex) &#123;<span class="keyword">return</span> m.toString();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        private <span class="keyword">void</span> writeObject(ObjectOutputStream s) throws IOException &#123;</span><br><span class="line">            synchronized (mutex) &#123;s.defaultWriteObject();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过观察分析，是将map封装到了synchronizeMap中，并且，将get put 等操作都放在了Synchronize代码块中，下面的List和Set同理，因为是放在了synchronize代码块中所以是串行的不是并行的，只能适用于并发量比较小的场景。</p><h3 id="2-1-2-List"><a href="#2-1-2-List" class="headerlink" title="2.1.2. List"></a>2.1.2. List</h3><p>synchronizedList</p><h3 id="2-1-3-Set"><a href="#2-1-3-Set" class="headerlink" title="2.1.3. Set"></a>2.1.3. Set</h3><p>synchronizedSet</p><h2 id="2-2-ConcurrentHashMap"><a href="#2-2-ConcurrentHashMap" class="headerlink" title="2.2. ConcurrentHashMap"></a>2.2. ConcurrentHashMap</h2><p>高性能HashMap（解决synchronize只适用于并发量小的场景）</p><h3 id="2-2-1HashMap源码分析"><a href="#2-2-1HashMap源码分析" class="headerlink" title="2.2.1HashMap源码分析"></a>2.2.1HashMap源码分析</h3><p>HashMap内部是一个数组<br>拿put方法来看<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        int hash = hash(key);</span><br><span class="line">        int i = indexFor(hash, table.length);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="built_in">Object</span> k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入inflateTable方法</span></span><br><span class="line">  private <span class="keyword">void</span> inflateTable(int toSize) &#123;</span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">        int capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">        threshold = (int) <span class="built_in">Math</span>.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看到是将疏浚存到了table中</span></span><br><span class="line">    transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line">    <span class="comment">//每一个table中是entry表象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//每个entry里面是key value next hash</span></span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        int hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates new entry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final K getKey() &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final V getValue() &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final boolean equals(<span class="built_in">Object</span> o) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> <span class="built_in">Map</span>.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">Map</span>.Entry e = (<span class="built_in">Map</span>.Entry)o;</span><br><span class="line">            <span class="built_in">Object</span> k1 = getKey();</span><br><span class="line">            <span class="built_in">Object</span> k2 = e.getKey();</span><br><span class="line">            <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="literal">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">                <span class="built_in">Object</span> v1 = getValue();</span><br><span class="line">                <span class="built_in">Object</span> v2 = e.getValue();</span><br><span class="line">                <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="literal">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final int hashCode() &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final <span class="built_in">String</span> toString() &#123;</span><br><span class="line">            <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is invoked whenever the value in an entry is</span></span><br><span class="line"><span class="comment">         * overwritten by an invocation of put(k,v) for a key k that's already</span></span><br><span class="line"><span class="comment">         * in the HashMap.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> recordAccess(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is invoked whenever the entry is</span></span><br><span class="line"><span class="comment">         * removed from the table.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> recordRemoval(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><p><img alt="" data-original="../images/15488919681106.png"></p><p>get（key）是通过哈希算法来判断应该映射到哪个槽位的<br>两个不同的key比如，key1 key2可能被映射到同一个槽位中，这里叫做哈希冲突<br>一种解决方法是，既然你映射到了同一个槽位中，我就把你方法同一个槽位中，可是在一个entry的数组中如何放两个entry呢？？通过entry中的next指向下一个entry</p><p>事实上HashMap的内部主要实现是数组，数组中放着entry，每个entry都是链表中的一环，链表的头部，当发生大量的hash冲突的时候蜕化成一个链表。</p><p>一般情况下HashMap不会放满，因为放满之后必然产生冲突，所以一般HashMap需要预留空间</p><h3 id="2-2-2-ConcurrentHashMap源码分析"><a href="#2-2-2-ConcurrentHashMap源码分析" class="headerlink" title="2.2.2. ConcurrentHashMap源码分析"></a>2.2.2. ConcurrentHashMap源码分析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">       Segment&lt;K,V&gt; s;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       int hash = hash(key);</span><br><span class="line">       int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">       <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">           s = ensureSegment(j);</span><br><span class="line">       <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Segment 段<br>如果大量线程进来，会一起竞争HashMap的赋值操作<br>把大的HashMap切割成若干个小的HashMap，每个线程进来的时候，先把当前的key映射到其中的一个小HashMap中去，在小HashMap中做一个普通HashMap应该做的事情，假如大的HashMap中有十六个小的HashMap，意味着大的HashMap可以同时接受十六个线程的赋值操作，相比于之前只有一个HasnMap，性能提高了十六倍。</p><p>这里的Segment就是上面说的小HashMap，通过移位操作拿到当前的偏移量如果不存在就创建一个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</span><br><span class="line">       final Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">       long u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">       Segment&lt;K,V&gt; seg;</span><br><span class="line">       <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="literal">null</span>) &#123;</span><br><span class="line">           Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">           int cap = proto.table.length;</span><br><span class="line">           float lf = proto.loadFactor;</span><br><span class="line">           int threshold = (int)(cap * lf);</span><br><span class="line">           HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">           <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">               == <span class="literal">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">               Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">               <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                      == <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="literal">null</span>, seg = s))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> seg;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>将第零个Segment作为原型将第k个Segment设置出来。</p><p><strong><font color="red">注意这里的put虽然是线程安全的但是并没有使用锁。<br></font></strong><br>上面的s.put():</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line"> <span class="comment">//这里的tryLock还是一个CAS操作tryLock不会等待，Lock才会等待</span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">            <span class="comment">//如果trylock失败，代码在线面详细解释这个函数</span></span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                int index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                槽位映射到index上，拿出index中的第一个</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="comment">//尝试将first插到entry中</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                <span class="comment">//如果有hash冲突</span></span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//有Hash冲突就将value串起来</span></span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果没有hash冲突</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        int c = count + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//就将entry set到数组中去</span></span><br><span class="line">                            setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">            HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">            HashEntry&lt;K,V&gt; node = <span class="literal">null</span>;</span><br><span class="line">            int retries = <span class="number">-1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">            <span class="comment">//不断的trylock</span></span><br><span class="line">            <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">                <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        e = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果trylock超过了一定的次数，就会挂起</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">                    lock();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                <span class="comment">//这里可能是hash进行了扩容重hash等操作，将retrues复制为-1，</span></span><br><span class="line">                <span class="comment">//再不断的进行trylock</span></span><br><span class="line">                         (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">                    e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">                    retries = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red">这里的不断的trylock，如果到达一定的次数在挂起，是concurrentHashMap的核心优化</font></strong><br>但是注意在concurrentHashMap中有一个size操作中的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">        final Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        int size;</span><br><span class="line">        boolean overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">        long sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">        long last = <span class="number">0</span>L;   <span class="comment">// previous sum</span></span><br><span class="line">        int retries = <span class="number">-1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">                &#125;</span><br><span class="line">                sum = <span class="number">0</span>L;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                overflow = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        sum += seg.modCount;</span><br><span class="line">                        int c = seg.count;</span><br><span class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                            overflow = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum == last)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                last = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的代码中重复进行了lock和unlock，因为在想要得到map的size的时候是不能够再进行修改的，所以加上锁，这里可能会有性能问题，可是size操作用的并不是很频繁，所以可以忽略。</p><p>rehash操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在put操作中</span></span><br><span class="line"><span class="comment">//如果大于了hash的阈值，就会进行rehash</span></span><br><span class="line"><span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Doubles size of table and repacks entries, also adding the</span></span><br><span class="line"><span class="comment">         * given node to new table</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> private <span class="keyword">void</span> rehash(HashEntry&lt;K,V&gt; node) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">            int oldCapacity = oldTable.length;</span><br><span class="line">            int newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">            HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">                (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">            int sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    int idx = e.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="literal">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                        newTable[idx] = e;</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                        HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                        int lastIdx = idx;</span><br><span class="line">                        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                             last != <span class="literal">null</span>;</span><br><span class="line">                             last = last.next) &#123;</span><br><span class="line">                            int k = last.hash &amp; sizeMask;</span><br><span class="line">                            <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                                lastIdx = k;</span><br><span class="line">                                lastRun = last;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        newTable[lastIdx] = lastRun;</span><br><span class="line">                        <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            V v = p.value;</span><br><span class="line">                            int h = p.hash;</span><br><span class="line">                            int k = h &amp; sizeMask;</span><br><span class="line">                            HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                            newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">            node.setNext(newTable[nodeIndex]);</span><br><span class="line">            newTable[nodeIndex] = node;</span><br><span class="line">            table = newTable;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>rehash会将空间容量翻倍，将node放进去，是一个比较耗时的操作，做了一点油画，尽量重用现有的元素，不去新建元素，也就是说在翻倍前和翻倍后，同一个元素，很可能在用一个位置</p><h2 id="2-3-BlockingQueue"><a href="#2-3-BlockingQueue" class="headerlink" title="2.3. BlockingQueue"></a>2.3. BlockingQueue</h2><p>阻塞队列</p><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。<br><img alt="" data-original="../images/15488919944790.png"></p><p>以上两段内容转自：<a href="http://ifeve.com/java-blocking-queue/" target="_blank" rel="noopener">http://ifeve.com/java-blocking-queue/</a><br><img alt="" data-original="../images/15488920002086.png"></p><p>是一个接口，不是一个实际的类，是一个并发容器，但不是一个高性能的并发容器，和concurrentHashMap（高性能）不一样，但它本身的好处是在多个线程共享数据的容器</p><p>如上图，如果队列为空，还试图往队列里面读数据，读的线程就会等待，等待有其他的线程往里面写数据的时候，才会唤醒，并且去拿到数据。如果队列已经满了，还想往队列中存数据，写的线程就会等待，等有人将数据拿掉之后才会写进去。</p><p>所以会引起线程的阻塞。</p><h3 id="ArrayBlockingQueue源码"><a href="#ArrayBlockingQueue源码" class="headerlink" title="ArrayBlockingQueue源码"></a>ArrayBlockingQueue源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Main lock guarding all access */</span></span><br><span class="line">    final ReentrantLock lock;<span class="comment">//保证线程安全</span></span><br><span class="line">    <span class="comment">/** Condition for waiting takes */</span></span><br><span class="line">    private final Condition notEmpty;<span class="comment">//提示读操作不为空</span></span><br><span class="line">    <span class="comment">/** Condition for waiting puts */</span></span><br><span class="line">    private final Condition notFull;<span class="comment">//提示写操作不为满</span></span><br><span class="line"></span><br><span class="line"> public <span class="keyword">void</span> put(E e) throws InterruptedException &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        final ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">//put操作直接加锁，所以是比较耗性能的。</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            <span class="comment">//如果是满的会进行等待，直到下面的take操作</span></span><br><span class="line">                notFull.await();</span><br><span class="line">            insert(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">        final ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//这里是为了读操作</span></span><br><span class="line">                notEmpty.await();</span><br><span class="line">                <span class="comment">//去掉写操作的锁，具体代码往下看</span></span><br><span class="line">            <span class="keyword">return</span> extract();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> private E extract() &#123;</span><br><span class="line">        final <span class="built_in">Object</span>[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        E x = <span class="keyword">this</span>.&lt;E&gt;cast(items[takeIndex]);</span><br><span class="line">        items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">        takeIndex = inc(takeIndex);</span><br><span class="line">        --count;</span><br><span class="line">        <span class="comment">//在这里讲锁打开</span></span><br><span class="line">        notFull.signal();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-ConcurrentLinkedQueue"><a href="#2-4-ConcurrentLinkedQueue" class="headerlink" title="2.4. ConcurrentLinkedQueue"></a>2.4. ConcurrentLinkedQueue</h2><p>高性能的链表队列，处理类似于concurrentHashMap，内部使用大量的无锁的算法。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;1-各种同步控制工具的使用&quot;&gt;&lt;a href=&quot;#1-各种同步控制工具的使用&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java高并发程序设计学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="高并发" scheme="http://mmmmmm.me/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发程序设计学习笔记（四）：无锁</title>
    <link href="http://mmmmmm.me/2019-01-31-2.html"/>
    <id>http://mmmmmm.me/2019-01-31-2.html</id>
    <published>2019-01-18T11:20:03.000Z</published>
    <updated>2019-03-12T12:16:32.827Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="1-无锁类的原理详解"><a href="#1-无锁类的原理详解" class="headerlink" title="1. 无锁类的原理详解"></a>1. 无锁类的原理详解</h1><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>前面已经介绍过无锁：<br>– 无障碍<br>无障碍是一种最弱的非阻塞调度<br>自由出入临界区<br>无竞争时，有限步内完成操作<br>有竞争时，回滚数据有竞争时，回滚数据<br>好进不好出，很容易进去，但是进去发现很多线程竞争相同的资源的时候，会需要回滚数据，比如要读取xy，已经读过了x，读到y的时候发现在竞争，会从x重新读。</p><p>– 无锁<br>是无障碍的<br>保证有一个线程可以胜出<br>while (!atomicVar.compareAndSet(localVar, localVar+1)) {<br>localVar = atomicVar.get();<br>}<br>因为无障碍中，如果存在不断的竞争，将会所有的都出不来，所以无锁就需要每次竞争都能胜出一个，这样保证程序能够顺畅的执行下去。</p><h2 id="1-1-CAS"><a href="#1-1-CAS" class="headerlink" title="1.1. CAS"></a>1.1. CAS</h2><p>CAS算法的过程是这样:它包含3个参数CAS(V,E,N)。V表示要更新的变量，E表示预期值，N表示新值。仅当V 值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么 都不做。最后，CAS返回当前V的真实值。CAS操作是抱着乐观的态度进行的，它总是认为自己可以成功完成 操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程 不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即时没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</p><p>CAS是一个原子操作，是由一条cpu指令完成的。</p><p>java中提供了很多无所类的使用，如果一个线程被挂起，将会消耗八万个时光周期，但是如果是无锁的，最多只是循环，也就只会消耗几个时光周期，所以无锁的方式比阻塞的方式要好很多。</p><h2 id="1-2-CPU指令"><a href="#1-2-CPU指令" class="headerlink" title="1.2. CPU指令"></a>1.2. CPU指令</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cmpxchg</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">accumulator = AL, AX, or EAX, depending on whether</span></span><br><span class="line"><span class="comment">a byte, word, or doubleword comparison is being performed */</span></span><br><span class="line"><span class="keyword">if</span>(accumulator == Destination) &#123;</span><br><span class="line">ZF = <span class="number">1</span>;         <span class="comment">//判断是否和期望值相等，相等的话就给一个转换标志。同时进行转换。</span></span><br><span class="line">Destination = Source; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ZF = <span class="number">0</span>;         <span class="comment">//不相等的话就给一个不转换的标志。同时不转换。</span></span><br><span class="line">accumulator = Destination; &#125;</span><br></pre></td></tr></table></figure><p>这是一个原子操作是安全的。</p><h1 id="2-无锁类的使用"><a href="#2-无锁类的使用" class="headerlink" title="2. 无锁类的使用"></a>2. 无锁类的使用</h1><h2 id="2-1-AtomicInteger"><a href="#2-1-AtomicInteger" class="headerlink" title="2.1. AtomicInteger"></a>2.1. AtomicInteger</h2><h3 id="2-1-1-概述"><a href="#2-1-1-概述" class="headerlink" title="2.1.1. 概述"></a>2.1.1. 概述</h3><p>Number</p><h3 id="2-1-2-主要接口"><a href="#2-1-2-主要接口" class="headerlink" title="2.1.2. 主要接口"></a>2.1.2. 主要接口</h3><p>public final int get()//取得当前值<br>public final void set(int newValue)//设置当前值<br>public final int getAndSet(int newValue)//设置新值，并返回旧值<br>public final boolean compareAndSet(int expect, int u)//如果当前值为expect，则设置为u<br>public final int getAndIncrement() //当前值加1，返回旧值<br>public final int getAndDecrement()//当前值减1，返回旧值<br>public final int getAndAdd(int delta)//当前值增加delta，返回旧值<br>public final int incrementAndGet() //当前值加1，返回新值<br>public final int decrementAndGet() //当前值减1，返回新值<br>public final int addAndGet(int delta)//当前值增加delta，返回新值</p><h3 id="2-1-3-主要接口的实现"><a href="#2-1-3-主要接口的实现" class="headerlink" title="2.1.3. 主要接口的实现"></a>2.1.3. 主要接口的实现</h3><p>compareAndSet方法<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//expect期望值，update更新的新值，成功返回true，失败返回false</span></span><br><span class="line">  public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//unsafe是不安全的，java将指针进行了屏蔽封装，而unsafe会提供类似指针的操作，对这个类的偏移量上的期望值</span></span><br></pre></td></tr></table></figure><p></p><p>偏移量valueOffset哪里来的？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valueOffset = unsafe.objectFieldOffset</span><br></pre></td></tr></table></figure><p>getAndIncrement方法<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回当前值，并且加一</span></span><br><span class="line">    public final int getAndIncrement() &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        int current = get();</span><br><span class="line">        int next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(compareAndSet(current,next))</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>get是得到当前这个类的private volatile int value;这个值加一，然后compareAndSet，如果当前的值和期望值相等的时候返回当前的这个值，否则，继续循环，和无锁的机制是一样的。如果在判断之前有其他的线程拿到了current值，在下面的if将会失败</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="title">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">public <span class="keyword">void</span> run()&#123;</span><br><span class="line"><span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">i.incrementAndGet();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">Thread[] ts = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (int k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">ts[k] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (int k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">ts[k].start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (int k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">ts[k].join();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100000</span></span><br></pre></td></tr></table></figure><h2 id="2-2-Unsafe"><a href="#2-2-Unsafe" class="headerlink" title="2.2. Unsafe"></a>2.2. Unsafe</h2><h3 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1. 概述"></a>2.2.1. 概述</h3><p>非安全的操作，比如: 根据偏移量设置值 、park() 、底层的CAS操作<br>非公开API，在不同版本的JDK中， 可能有较大差异</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>拿到value这个字段在本类（相当于c中的首地址）中的偏移量是多少。</p><h3 id="2-2-2-主要接口"><a href="#2-2-2-主要接口" class="headerlink" title="2.2.2. 主要接口"></a>2.2.2. 主要接口</h3><p>//获得给定对象偏移量上的int值<br>public native int getInt(Object o, long offset); //设置给定对象偏移量上的int值<br>public native void putInt(Object o, long offset, int x); //获得字段在对象中的偏移量<br>public native long objectFieldOffset(Field f); //设置给定对象的int值，使用volatile语义<br>public native void putIntVolatile(Object o, long offset, int x); //获得给定对象对象的int值，使用volatile语义<br>public native int getIntVolatile(Object o, long offset); //和putIntVolatile()一样，但是它要求被操作字段就是volatile类型的 public native void putOrderedInt(Object o, long offset, int x);</p><h2 id="2-3-AtomicReference"><a href="#2-3-AtomicReference" class="headerlink" title="2.3. AtomicReference"></a>2.3. AtomicReference</h2><h3 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1. 概述"></a>2.3.1. 概述</h3><p>对象的引用<br>对引用进行修改 是一个模板类，抽象化了数据类型</p><h3 id="2-3-2-主要接口"><a href="#2-3-2-主要接口" class="headerlink" title="2.3.2. 主要接口"></a>2.3.2. 主要接口</h3><p>get()<br>set(V) compareAndSet() getAndSet(V)<br>大部分的方法和compareAndSet差不多。<br>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">public final <span class="keyword">static</span> AtomicReference&lt;<span class="built_in">String</span>&gt; atomicStr = <span class="keyword">new</span> AtomicReference&lt;<span class="built_in">String</span>&gt;(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">final int num = i;</span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="built_in">Math</span>.abs((int)<span class="built_in">Math</span>.random()*<span class="number">100</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (atomicStr.compareAndSet((<span class="string">"abc"</span>), <span class="string">"def"</span>)) &#123;</span><br><span class="line">System.out.println(<span class="string">"Thread"</span>+Thread.currentThread().getId()+<span class="string">"change value to"</span>+atomicStr.compareAndSet((<span class="string">"abc"</span>), <span class="string">"def"</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Thread"</span>+Thread.currentThread().getId()+<span class="string">"FALED"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread10change value tofalse</span><br><span class="line">Thread1FALED</span><br><span class="line">Thread2FALED</span><br><span class="line">Thread3FALED</span><br><span class="line">Thread4FALED</span><br><span class="line">Thread5FALED</span><br><span class="line">Thread6FALED</span><br><span class="line">Thread7FALED</span><br><span class="line">Thread8FALED</span><br><span class="line">Thread9FALED</span><br></pre></td></tr></table></figure><h2 id="2-4-AtomicStampedReference"><a href="#2-4-AtomicStampedReference" class="headerlink" title="2.4. AtomicStampedReference"></a>2.4. AtomicStampedReference</h2><p>和对象的引用差不多<br>stamped表示时间戳、唯一性等</p><h3 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1. 概述"></a>2.4.1. 概述</h3><p>ABA问题</p><p><img alt="" data-original="../images/15488913529012.png"></p><p>如图，一个值为A，期初一个线程1拿到它，然后做相关的操作，这个时候线程2拿到这个A并且改为了B，线程3拿到了B改为了A，这个时候线程1将拿到的A和讲过了线程2 线程3后的A进行比较，相同的话A就改为C。<br>发现是没问题的，因为A还是变为了A，如果是加法，没问题，可是如果比较关注中间的过程呢？比如网吧充钱，没钱机器就自动冲，可是只能自动充值一次，这个时候第二次还是到了临界点呢？？<br>这个时候就需要给一个时间戳或者唯一的标识。每次改变的时候都传递一个包含A和时间戳的对象，每次在比价A的同时比较时间戳。<br>源码解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将原来的value做了一层封装分为了reference和stamp</span></span><br><span class="line">private <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        final T reference;</span><br><span class="line">        final int stamp;</span><br><span class="line">        private Pair(T reference, int stamp) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="keyword">of</span>(T reference, int stamp) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//compareAndSet的参数也由原来的两个，变为了四个，包括期望值和新的值</span></span><br><span class="line">public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                                 V   newReference,</span><br><span class="line">                                 int expectedStamp,</span><br><span class="line">                                 int newStamp) &#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        <span class="comment">//当两个都相等的时候才有机会向下执行</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk中经常会有函数叫做cas...来更新列表的头部、尾部等操作</span></span><br><span class="line"><span class="comment">//pairOffset就是</span></span><br><span class="line">private boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-AtomicIntegerArray"><a href="#2-5-AtomicIntegerArray" class="headerlink" title="2.5. AtomicIntegerArray"></a>2.5. AtomicIntegerArray</h2><h3 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1. 概述"></a>2.5.1. 概述</h3><p>支持无锁的数组</p><h3 id="2-5-2-主要接口"><a href="#2-5-2-主要接口" class="headerlink" title="2.5.2. 主要接口"></a>2.5.2. 主要接口</h3><p>//获得数组第i个下标的元素<br>public final int get(int i)<br>//获得数组的长度<br>public final int length()<br>//将数组第i个下标设置为newValue，并返回旧的值<br>public final int getAndSet(int i, int newValue) //进行CAS操作，如果第i个下标的元素等于expect，则设置为update，设置成功返回true public final boolean compareAndSet(int i, int expect, int update)<br>//将第i个下标的元素加1<br>public final int getAndIncrement(int i) //将第i个下标的元素减1<br>public final int getAndDecrement(int i) //将第i个下标的元素增加delta(delta可以是负数) public final int getAndAdd(int i, int delta)</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> AtomicIntegerArray arr = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">arr.getAndIncrement(i % arr.length());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">Thread[] ts = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">ts[i] = <span class="keyword">new</span> Thread((<span class="keyword">new</span> AddThread()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">ts[i].start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">ts[i].join();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是不安全的话，不会每个都是1000，应该比这个小。<br>运行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>]</span><br></pre></td></tr></table></figure><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">static</span> final int base = unsafe.arrayBaseOffset(int[].class);</span><br><span class="line"></span><br><span class="line">public final int get(int i) &#123;</span><br><span class="line">        <span class="keyword">return</span> getRaw(checkedByteOffset(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private int getRaw(long offset) &#123;</span><br><span class="line"><span class="comment">//数组所在的基地址开始取offset的偏移量</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.getIntVolatile(array, offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回第i个元素在数组中的偏移量是多少</span></span><br><span class="line">private long checkedByteOffset(int i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"index "</span> + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">&#125;</span><br><span class="line">private <span class="keyword">static</span> long byteOffset(int i) &#123;</span><br><span class="line"><span class="comment">//i偏移了shift的数值</span></span><br><span class="line">        <span class="keyword">return</span> ((long) i &lt;&lt; shift) + base;</span><br><span class="line">        <span class="comment">//通过下面的计算 i左移两位（二进制，即在末尾加两个零</span></span><br><span class="line">        <span class="comment">//，如果是十进制就是乘以4）</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">//数组中每个元素有多宽，int就是4（每个int是4个byte）</span></span><br><span class="line">        int scale = unsafe.arrayIndexScale(int[].class);</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"data type scale not a power of two"</span>);</span><br><span class="line">            <span class="comment">//shift的值</span></span><br><span class="line">            <span class="comment">//numberOfLeadingZeros前导零，一个数字化成二进制</span></span><br><span class="line">            <span class="comment">//前面的零的个数</span></span><br><span class="line">            <span class="comment">//4------&gt;   00000....100       32-3=29</span></span><br><span class="line">            <span class="comment">//4的前导零就是29</span></span><br><span class="line">        shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">        <span class="comment">//所以shift=2</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-AtomicIntegerFieldUpdater"><a href="#2-6-AtomicIntegerFieldUpdater" class="headerlink" title="2.6. AtomicIntegerFieldUpdater"></a>2.6. AtomicIntegerFieldUpdater</h2><h3 id="2-6-1-概述"><a href="#2-6-1-概述" class="headerlink" title="2.6.1. 概述"></a>2.6.1. 概述</h3><p>让普通变量也享受原子操作<br>希望拥有原子操作，但是不改变原原子的类型。<br>使用尽量少的代码、在不改变原来类型的基础上、做出较少的改变来实现原子操作。</p><h3 id="2-6-2-主要接口-AtomicIntegerFieldUpdater-newUpdater"><a href="#2-6-2-主要接口-AtomicIntegerFieldUpdater-newUpdater" class="headerlink" title="2.6.2. 主要接口 AtomicIntegerFieldUpdater.newUpdater()"></a>2.6.2. 主要接口 AtomicIntegerFieldUpdater.newUpdater()</h3><p>AtomicIntegerFieldUpdate.newUpdate()<br>incrementAndGet()</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Candidate</span></span>&#123;</span><br><span class="line">int id;</span><br><span class="line">volatile  int score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater =</span><br><span class="line">AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="string">"score"</span>);</span><br><span class="line">public <span class="keyword">static</span> AtomicInteger allScore = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">final Candidate stu  = <span class="keyword">new</span> Candidate();</span><br><span class="line">Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">threads[i] = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">public <span class="keyword">void</span> run()&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Math</span>.random()&gt;<span class="number">0.4</span>)&#123;</span><br><span class="line">scoreUpdater.incrementAndGet(stu);</span><br><span class="line">allScore.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">threads[i].start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">threads[i].join();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"sore="</span>+stu.score);</span><br><span class="line">System.out.println(<span class="string">"allScore="</span>+allScore);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过AtomicInteger来验证，发现是相同的安全的结果，主要就是上面提到的两个方法，通过反射实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sore=<span class="number">5948</span></span><br><span class="line">allScore=<span class="number">5948</span></span><br></pre></td></tr></table></figure><h3 id="2-6-3-小说明"><a href="#2-6-3-小说明" class="headerlink" title="2.6.3. 小说明"></a>2.6.3. 小说明</h3><ol><li>Updater只能修改它可见范围内的变量。因为Updater使用反射得到这个变量。如果变量不可见，就会出错。<br>比如如果score申明为private，就是不可行的。</li><li>为了确保变量被正确的读取，它必须是volatile类型的。如果我们原有代码中未申明这个类型，那么简单得 申明一下就行，这不会引起什么问题。</li><li>由于CAS操作会通过对象实例中的偏移量直接进行赋值，因此，它不支持static字段(Unsafe. objectFieldOffset()不支持静态变量)。<h1 id="3-无锁算法详解"><a href="#3-无锁算法详解" class="headerlink" title="3. 无锁算法详解"></a>3. 无锁算法详解</h1></li></ol><p>jdk中的vector是有锁的。<br>源码解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this Vector.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param e element to be appended to this Vector</span></span><br><span class="line"><span class="comment">     * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     * @since 1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public synchronized boolean add(E e) &#123;</span><br><span class="line">    <span class="comment">//记录vector被修改的次数</span></span><br><span class="line">        modCount++;</span><br><span class="line">       <span class="comment">// vector底层是数组</span></span><br><span class="line">       <span class="comment">// 判断时候越界，如果越界了就进行扩展，扩展代码在下面</span></span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//不越界就将e加在后面</span></span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 是一个同步的方法，每次只有一个线程能进行add操作，所有的元素都保存在elementData</span></span><br><span class="line">    中</span><br><span class="line">    private <span class="keyword">void</span> ensureCapacityHelper(int minCapacity) &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">private <span class="keyword">void</span> grow(int minCapacity) &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">//扩展增量（扩容）capacityIncrement可以自己制定，如果自己不指定的话就</span></span><br><span class="line">        <span class="comment">//是默认的oldCapacity+oldCapacity------&gt;newCapacity也就是</span></span><br><span class="line">        <span class="comment">//乘以二</span></span><br><span class="line">        int newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                         capacityIncrement : oldCapacity);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">            <span class="comment">//把老元素放到新的元素中去</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建了一个新的数组，把原来的数组复制过去。</span></span><br><span class="line"> public <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">        T[] copy = ((<span class="built_in">Object</span>)newType == (<span class="built_in">Object</span>)<span class="built_in">Object</span>[].class)</span><br><span class="line">            ? (T[]) <span class="keyword">new</span> <span class="built_in">Object</span>[newLength]</span><br><span class="line">            : (T[]) <span class="built_in">Array</span>.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                         <span class="built_in">Math</span>.min(original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意看里面的注释很重要：<br>提取出来几个<br><strong><font color="red">vector底层是数组<br>判断时候越界，如果越界了就进行扩展，<br>add是一个同步的方法（有锁的），每次只有一个线程能进行add操作<br>扩展增量（扩容）capacityIncrement可以自己制定，如果自己不指定的话就<br>是默认的oldCapacity+oldCapacity——&gt;newCapacity也就是<br>乘以二（有次面试我被问过）!!!!!!!!!!!!所以当扩容的数字很大的时候，建议给个扩容的大小<br>把老元素放到新的元素中去<br>创建了一个新的数组，把原来的数组复制过去。</font></strong></p><h2 id="3-1-无锁的Vector实现"><a href="#3-1-无锁的Vector实现" class="headerlink" title="3.1. 无锁的Vector实现"></a>3.1. 无锁的Vector实现</h2><p>这里只将源码贴出来<br>和普通的vector实现的区别是原来的vector是一维数组，而这里的数组是二维的数组，为什么用二维数组？二维数组中的第一个容量是n，第二个就是2n，第三个就是4n。。。。以此类推，就像是一个个不同容量的篮子。<br>FIRST_BUCKET_SIZE给定第一个篮子的大小<br>N_BUCKET有多少个篮子<br>private final AtomicReferenceArray&lt;AtomicReferenceArray<e>&gt; buckets;<br>通过AtomicReferenceArray的二重数组来封装这些篮子。AtomicReferenceArray和AtomicArray差不多只是将array的值换成了对象。</e></p><p><strong><font color="red">有个分析的很不错的博文：</font></strong><br><a href="http://reimuwang.org/2018/05/17/Java%20%E5%B9%B6%E5%8F%91-%E6%97%A0%E9%94%81%E7%9A%84Vector%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">http://reimuwang.org/2018/05/17/Java%20%E5%B9%B6%E5%8F%91-%E6%97%A0%E9%94%81%E7%9A%84Vector%E5%AE%9E%E7%8E%B0/</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2007 IBM Corporation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line">package main.java.org.amino.ds.lockfree;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.AbstractList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReferenceArray;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * It is a thread safe and lock-free vector.</span></span><br><span class="line"><span class="comment"> * This class implement algorithm from:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Lock-free Dynamically Resizable Arrays &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * Texas A&amp;M University College Station, TX 77843-3112&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * &#123;dechev, peter.pirkelbauer&#125;@tamu.edu, bs@cs.tamu.edu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author Zhi Gan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &lt;E&gt; type of element in the vector</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LockFreeVector</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    private <span class="keyword">static</span> final boolean debug = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Size of the first bucket. sizeof(bucket[i+1])=2*sizeof(bucket[i])</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private <span class="keyword">static</span> final int FIRST_BUCKET_SIZE = <span class="number">8</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * number of buckets. 30 will allow 8*(2^30-1) elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private <span class="keyword">static</span> final int N_BUCKET = <span class="number">30</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * We will have at most N_BUCKET number of buckets. And we have</span></span><br><span class="line"><span class="comment">     * sizeof(buckets.get(i))=FIRST_BUCKET_SIZE**(i+1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private final AtomicReferenceArray&lt;AtomicReferenceArray&lt;E&gt;&gt; buckets;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @author ganzhi</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param &lt;E&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteDescriptor</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        public E oldV;</span><br><span class="line">        public E newV;</span><br><span class="line">        public AtomicReferenceArray&lt;E&gt; addr;</span><br><span class="line">        public int addr_ind;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creating a new descriptor.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * @param addr Operation address</span></span><br><span class="line"><span class="comment">         * @param addr_ind  Index of address</span></span><br><span class="line"><span class="comment">         * @param oldV old operand</span></span><br><span class="line"><span class="comment">         * @param newV new operand</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        public WriteDescriptor(AtomicReferenceArray&lt;E&gt; addr, int addr_ind,</span><br><span class="line">                E oldV, E newV) &#123;</span><br><span class="line">            <span class="keyword">this</span>.addr = addr;</span><br><span class="line">            <span class="keyword">this</span>.addr_ind = addr_ind;</span><br><span class="line">            <span class="keyword">this</span>.oldV = oldV;</span><br><span class="line">            <span class="keyword">this</span>.newV = newV;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * set newV.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        public <span class="keyword">void</span> doIt() &#123;</span><br><span class="line">            addr.compareAndSet(addr_ind, oldV, newV);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @author ganzhi</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param &lt;E&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Descriptor</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        public int size;</span><br><span class="line">        volatile WriteDescriptor&lt;E&gt; writeop;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Create a new descriptor.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * @param size Size of the vector</span></span><br><span class="line"><span class="comment">         * @param writeop Executor write operation</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        public Descriptor(int size, WriteDescriptor&lt;E&gt; writeop) &#123;</span><br><span class="line">            <span class="keyword">this</span>.size = size;</span><br><span class="line">            <span class="keyword">this</span>.writeop = writeop;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        public <span class="keyword">void</span> completeWrite() &#123;</span><br><span class="line">            WriteDescriptor&lt;E&gt; tmpOp = writeop;</span><br><span class="line">            <span class="keyword">if</span> (tmpOp != <span class="literal">null</span>) &#123;</span><br><span class="line">                tmpOp.doIt();</span><br><span class="line">                writeop = <span class="literal">null</span>; <span class="comment">// this is safe since all write to writeop use</span></span><br><span class="line">                <span class="comment">// null as r_value.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private AtomicReference&lt;Descriptor&lt;E&gt;&gt; descriptor;</span><br><span class="line">    private <span class="keyword">static</span> final int zeroNumFirst = Integer</span><br><span class="line">            .numberOfLeadingZeros(FIRST_BUCKET_SIZE);;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public LockFreeVector() &#123;</span><br><span class="line">        buckets = <span class="keyword">new</span> AtomicReferenceArray&lt;AtomicReferenceArray&lt;E&gt;&gt;(N_BUCKET);</span><br><span class="line">        buckets.set(<span class="number">0</span>, <span class="keyword">new</span> AtomicReferenceArray&lt;E&gt;(FIRST_BUCKET_SIZE));</span><br><span class="line">        descriptor = <span class="keyword">new</span> AtomicReference&lt;Descriptor&lt;E&gt;&gt;(<span class="keyword">new</span> Descriptor&lt;E&gt;(<span class="number">0</span>,</span><br><span class="line">                <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add e at the end of vector.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param e</span></span><br><span class="line"><span class="comment">     *            element added</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="keyword">void</span> push_back(E e) &#123;</span><br><span class="line">        Descriptor&lt;E&gt; desc;</span><br><span class="line">        Descriptor&lt;E&gt; newd;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            desc = descriptor.get();</span><br><span class="line">            desc.completeWrite();</span><br><span class="line">            <span class="comment">//desc.size   Vector 本身的大小</span></span><br><span class="line">            <span class="comment">//FIRST_BUCKET_SIZE  第一个一位数组的大小</span></span><br><span class="line">            int pos = desc.size + FIRST_BUCKET_SIZE;</span><br><span class="line">            int zeroNumPos = Integer.numberOfLeadingZeros(pos);  <span class="comment">// 取出pos 的前导领</span></span><br><span class="line">            <span class="comment">//zeroNumFirst  为FIRST_BUCKET_SIZE 的前导领</span></span><br><span class="line">            int bucketInd = zeroNumFirst - zeroNumPos;  <span class="comment">//哪个一位数组</span></span><br><span class="line">            <span class="comment">//判断这个一维数组是否已经启用</span></span><br><span class="line">            <span class="keyword">if</span> (buckets.get(bucketInd) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//newLen  一维数组的长度</span></span><br><span class="line">                int newLen = <span class="number">2</span> * buckets.get(bucketInd - <span class="number">1</span>).length();</span><br><span class="line">                <span class="keyword">if</span> (debug)</span><br><span class="line">                    System.out.println(<span class="string">"New Length is:"</span> + newLen);</span><br><span class="line">                buckets.compareAndSet(bucketInd, <span class="literal">null</span>,</span><br><span class="line">                        <span class="keyword">new</span> AtomicReferenceArray&lt;E&gt;(newLen));</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            int idx = (<span class="number">0x80000000</span>&gt;&gt;&gt;zeroNumPos) ^ pos;   <span class="comment">//在这个一位数组中，我在哪个位置</span></span><br><span class="line">            newd = <span class="keyword">new</span> Descriptor&lt;E&gt;(desc.size + <span class="number">1</span>, <span class="keyword">new</span> WriteDescriptor&lt;E&gt;(</span><br><span class="line">                    buckets.get(bucketInd), idx, <span class="literal">null</span>, e));</span><br><span class="line">        &#125; <span class="keyword">while</span> (!descriptor.compareAndSet(desc, newd));</span><br><span class="line">        descriptor.get().completeWrite();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Remove the last element in the vector.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return element removed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public E pop_back() &#123;</span><br><span class="line">        Descriptor&lt;E&gt; desc;</span><br><span class="line">        Descriptor&lt;E&gt; newd;</span><br><span class="line">        E elem;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            desc = descriptor.get();</span><br><span class="line">            desc.completeWrite();</span><br><span class="line"> </span><br><span class="line">            int pos = desc.size + FIRST_BUCKET_SIZE - <span class="number">1</span>;</span><br><span class="line">            int bucketInd = Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)</span><br><span class="line">                    - Integer.numberOfLeadingZeros(pos);</span><br><span class="line">            int idx = Integer.highestOneBit(pos) ^ pos;</span><br><span class="line">            elem = buckets.get(bucketInd).get(idx);</span><br><span class="line">            newd = <span class="keyword">new</span> Descriptor&lt;E&gt;(desc.size - <span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!descriptor.compareAndSet(desc, newd));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get element with the index.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param index</span></span><br><span class="line"><span class="comment">     *            index</span></span><br><span class="line"><span class="comment">     * @return element with the index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Override</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        int pos = index + FIRST_BUCKET_SIZE;</span><br><span class="line">        int zeroNumPos = Integer.numberOfLeadingZeros(pos);</span><br><span class="line">        int bucketInd = zeroNumFirst - zeroNumPos;</span><br><span class="line">        int idx = (<span class="number">0x80000000</span>&gt;&gt;&gt;zeroNumPos) ^ pos;</span><br><span class="line">        <span class="keyword">return</span> buckets.get(bucketInd).get(idx);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the element with index to e.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param index</span></span><br><span class="line"><span class="comment">     *            index of element to be reset</span></span><br><span class="line"><span class="comment">     * @param e</span></span><br><span class="line"><span class="comment">     *            element to set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * &#123;@inheritDoc&#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    public E set(int index, E e) &#123;</span><br><span class="line">        int pos = index + FIRST_BUCKET_SIZE;</span><br><span class="line">        int bucketInd = Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)</span><br><span class="line">                - Integer.numberOfLeadingZeros(pos);</span><br><span class="line">        int idx = Integer.highestOneBit(pos) ^ pos;</span><br><span class="line">        AtomicReferenceArray&lt;E&gt; bucket = buckets.get(bucketInd);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            E oldV = bucket.get(idx);</span><br><span class="line">            <span class="keyword">if</span> (bucket.compareAndSet(idx, oldV, e))</span><br><span class="line">                <span class="keyword">return</span> oldV;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reserve more space.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param newSize</span></span><br><span class="line"><span class="comment">     *            new size be reserved</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="keyword">void</span> reserve(int newSize) &#123;</span><br><span class="line">        int size = descriptor.get().size;</span><br><span class="line">        int pos = size + FIRST_BUCKET_SIZE - <span class="number">1</span>;</span><br><span class="line">        int i = Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)</span><br><span class="line">                - Integer.numberOfLeadingZeros(pos);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        int initialSize = buckets.get(i - <span class="number">1</span>).length();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)</span><br><span class="line">                - Integer.numberOfLeadingZeros(newSize + FIRST_BUCKET_SIZE - <span class="number">1</span>)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            initialSize *= FIRST_BUCKET_SIZE;</span><br><span class="line">            buckets.compareAndSet(i, <span class="literal">null</span>, <span class="keyword">new</span> AtomicReferenceArray&lt;E&gt;(</span><br><span class="line">                    initialSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * size of vector.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return size of vector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        <span class="keyword">return</span> descriptor.get().size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * &#123;@inheritDoc&#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    @Override</span><br><span class="line">    public boolean add(E object) &#123;</span><br><span class="line">        push_back(object);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;1-无锁类的原理详解&quot;&gt;&lt;a href=&quot;#1-无锁类的原理详解&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java高并发程序设计学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="高并发" scheme="http://mmmmmm.me/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发程序设计学习笔记（三）：Java内存模型和线程安全</title>
    <link href="http://mmmmmm.me/2019-01-31-1.html"/>
    <id>http://mmmmmm.me/2019-01-31-1.html</id>
    <published>2019-01-18T11:20:02.000Z</published>
    <updated>2019-06-08T05:16:06.565Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就 不会被其它线程干扰。<br>i++是原子操作吗?<br>不是，因为包含了三次操作：读i，i+1，新值写到i中。<br>比如i=1，i是static的，一个线程a读到了1，另一个线程b在线程一做加法之前也读到了i=1, a线程和b线程同时拿到了i，做i++的操作，a线程i++后变成了2，b线程i++后也变成了2， <strong><font color="red">所以最后的i的值是2，但是实际上i的值应该是3</font></strong></p><h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><p>在并发时，程序的执行可能就会出现乱序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderExample</span> </span>&#123; int a = <span class="number">0</span>;</span><br><span class="line">boolean flag = <span class="literal">false</span>; public <span class="keyword">void</span> writer() &#123;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">flag = <span class="literal">true</span>; &#125;</span><br><span class="line">public <span class="keyword">void</span> reader() &#123; <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">inti= a+<span class="number">1</span>;</span><br><span class="line">...... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="" data-original="../images/15488909175833.png"></p><p>一条指令（汇编指令）的执行是可以分为很多步骤的<br>– 取指IF （把指令取出来）<br>– 译码和取寄存器操作数 ID （参数取出来）<br>– 执行或者有效地址计算 EX （执行）<br>– 存储器访问 MEM （存储器访问）<br>– 写回WB （数据写会到寄存器中去）<br><strong><font color="red">注意：每一个部分会占用计算机不同的硬件</font></strong><br><img alt="" data-original="../images/15488909301951.png"></p><p>复杂一点的：<br><img alt="" data-original="../images/15488909358761.png"></p><p>发现加了很多的气泡进去<br><img alt="" data-original="../images/15488909482711.png"><br><img alt="" data-original="../images/15488909498914.png"></p><h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。</p><h2 id="–-编译器优化"><a href="#–-编译器优化" class="headerlink" title="– 编译器优化"></a>– 编译器优化</h2><p>比如上面的重排，并不知道另一个线程中的值是多少，或者编译期，一个线程中，一个值优化到了某个寄存器中，另一个线程中将这个值放到了高速缓存cache中，这两个线程就不能再同一时间知道对方修改了值。多核cpu，每一个cpu中都有自己的寄存器，变量被不同的cpu不同的寄存器不同的cache中保存，所以不能保证可见。</p><h2 id="–-硬件优化-如写吸收，批操作"><a href="#–-硬件优化-如写吸收，批操作" class="headerlink" title="– 硬件优化(如写吸收，批操作)"></a>– 硬件优化(如写吸收，批操作)</h2><p>cpu想把数据写到内存里的时候，很可能不会是直接把数据写到内存里面，因为这样很慢，先把数据写到硬件队列里面，然后通过批量操作的方式批量写到内存里面去，这样会比较快一些，还会做优化，比如对同一个内存地址多次做了不同的读写，认为是没有必要，因为是以最后一个为准，所以干脆就把老的读写，就不读写进去，只将最后的地址读写进去<br><img alt="" data-original="../images/15488909591307.png"></p><p><strong><font color="red">如果不做优化，就不会有这些问题，可是不做优化的话，性能就会很差。</font></strong></p><h2 id="Java虚拟机层面的可见性"><a href="#Java虚拟机层面的可见性" class="headerlink" title="Java虚拟机层面的可见性"></a>Java虚拟机层面的可见性</h2><p>博文：<a href="http://hushi55.github.io/2015/01/05/volatile-assembly" target="_blank" rel="noopener">http://hushi55.github.io/2015/01/05/volatile-assembly</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">VisibilityTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; private boolean stop;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line">int i = <span class="number">0</span>; <span class="keyword">while</span>(!stop) &#123;</span><br><span class="line">i++; &#125;</span><br><span class="line">System.out.println(<span class="string">"finish loop,i="</span> + i); &#125;</span><br><span class="line">public <span class="keyword">void</span> stopIt() &#123; stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">public boolean getStop()&#123; <span class="keyword">return</span> stop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123; VisibilityTest v = <span class="keyword">new</span> VisibilityTest();</span><br><span class="line">v.start();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">v.stopIt();</span><br><span class="line">Thread.sleep(<span class="number">2000</span>); System.out.println(<span class="string">"finish main"</span>); System.out.println(v.getStop());</span><br><span class="line">DATAGURU专业数据分析社区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red">就是希望在v.stopIt();之后让stop=true，输出System.out.println(“finish loop,i=” + i); }<br>可是实际的操作，是并没有输出这句话的。<br></font></strong></p><p><img alt="" data-original="../images/15488909684910.png"></p><p>如何查看是什么模式？<br><img alt="" data-original="../images/15488909800340.png"></p><p>虚拟机执行有两种方式client方式和server模式，client不会做太多的优化，就是系统启动的比较快，server模式系统启动的慢，但是有很多的优化，现在64位的机器都是server模式。<br>通过server模式发现是永远不会执行完。<br><strong><font color="red">如何进行查看汇编指令 ？</font></strong><br>1、可以使用命令</p><blockquote><p>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly Main<br>(Main是class文件)</p></blockquote><p>2、在IDEA配置VM options，打印汇编指令，如下图。</p><blockquote><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p></blockquote><p>原文：<a href="https://blog.csdn.net/ljheee/article/details/82218156" target="_blank" rel="noopener">https://blog.csdn.net/ljheee/article/details/82218156</a></p><p>上图是博客作者整理的汇编代码，这里解释一下：<br><strong><font color="red">因为jvm的内部优化，导致不断的在红色的代码部分进行循环，并没有走!stop的这个而判断指令，这个判断只是在刚刚进来的时候回进行了一次判断，所以会不断的执行下去。也就出现了上面的结果。</font></strong></p><p>引用博文中的一句话：<br>程序比较简单，在主线程中启动一个线程，这个线程不停的对局部变量做自增操作，主线程休眠 1 秒中后改变启动线程的循环控制变量，想让它停止循环。这个程序在 client 模式下是能停止线程做自增操作的，但是在 server 模式先将是无限循环。若是改成<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile boolean stop;</span><br></pre></td></tr></table></figure><p></p><p><strong><font color="red">用 volatile 修饰 stop 变量，将不会出现死循环。</font></strong><br>我们知道 volatile 在 JVM 内存模型中是保证修饰变量的可见性，这个不是我们今天讨论的重点，我们今天想看看在 volatile 修饰下和不修饰代码编译成的汇编代码的区别，以便我们学习 JVM 的内存模型。</p><p>再来看一个例子</p><p><img alt="" data-original="../images/15488909905972.png"><br><img alt="" data-original="../images/15488909965152.png"></p><p>上图是从java语言规范中拿到的，描述可见性和指令重排的一些问题</p><h1 id="Happen-Before规则（先行发生）"><a href="#Happen-Before规则（先行发生）" class="headerlink" title="Happen-Before规则（先行发生）"></a>Happen-Before规则（先行发生）</h1><h2 id="程序顺序原则"><a href="#程序顺序原则" class="headerlink" title="程序顺序原则:"></a>程序顺序原则:</h2><p>一个线程内保证语义的串行性<br>对于单线程来说，重排前和重排后的结果必须一致<br><img alt="" data-original="../images/15488910504012.png"></p><h2 id="volatile规则"><a href="#volatile规则" class="headerlink" title="volatile规则:"></a>volatile规则:</h2><p>volatile变量的写，先发生于读，这保证了volatile变量的可见性</p><h2 id="锁规则"><a href="#锁规则" class="headerlink" title="锁规则:"></a>锁规则:</h2><p>解锁(unlock)必然发生在随后的加锁(lock)前<br>如果加锁被重排到解锁前面，因为还没有解锁，肯定是获取不到锁的</p><h2 id="传递性"><a href="#传递性" class="headerlink" title="传递性:"></a>传递性:</h2><p>A先于B，B先于C，那么A必然先于C</p><h3 id="线程的start-方法先于它的每一个动作"><a href="#线程的start-方法先于它的每一个动作" class="headerlink" title="线程的start()方法先于它的每一个动作"></a>线程的start()方法先于它的每一个动作</h3><h3 id="线程的所有操作先于线程的终结-Thread-join"><a href="#线程的所有操作先于线程的终结-Thread-join" class="headerlink" title="线程的所有操作先于线程的终结(Thread.join())"></a>线程的所有操作先于线程的终结(Thread.join())</h3><h3 id="线程的中断-interrupt-先于被中断线程的代码"><a href="#线程的中断-interrupt-先于被中断线程的代码" class="headerlink" title="线程的中断(interrupt())先于被中断线程的代码"></a>线程的中断(interrupt())先于被中断线程的代码</h3><h3 id="对象的构造函数执行结束先于finalize-方法"><a href="#对象的构造函数执行结束先于finalize-方法" class="headerlink" title="对象的构造函数执行结束先于finalize()方法"></a>对象的构造函数执行结束先于finalize()方法</h3><h1 id="线程安全的概念"><a href="#线程安全的概念" class="headerlink" title="线程安全的概念"></a>线程安全的概念</h1><p>指某个函数、函数库在多线程环境中被调用时，能够正确地处理各个线程的局部变量，使程序功 能正确完成。</p><p>i++在多线程下访问的情况<br><img alt="" data-original="../images/15488910582903.png"></p><p>i++是static的一个变量，在多线程中不是线程安全的，一个线程在读的时候，另一个线程也在读，一个线程在写的时候，另一个线程也在写，所以写和读的时候值会被另外一个线程覆盖掉。甚至线程很多的时候，i可能会越加越小，</p><p>解决：阻塞的方式<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> AccountingSync instance=<span class="keyword">new</span> AccountingSync(); <span class="keyword">static</span> int i=<span class="number">0</span>;</span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;<span class="number">10000000</span>;j++)&#123; synchronized(instance)&#123;</span><br><span class="line">  &#125; &#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;原子性&quot;&gt;&lt;a href=&quot;#原子性&quot; class=&quot;headerlink&quot; title=&quot;原子性&quot;&gt;&lt;/a&gt;原子
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java高并发程序设计学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="高并发" scheme="http://mmmmmm.me/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发程序设计学习笔记（二）：多线程基础</title>
    <link href="http://mmmmmm.me/2019-01-31.html"/>
    <id>http://mmmmmm.me/2019-01-31.html</id>
    <published>2019-01-18T11:20:01.000Z</published>
    <updated>2019-03-12T12:16:32.758Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h1><p>线程是进程内的执行单元。<br>每个进程中有若干个线程，进程的切换是非常重量型的，所线程可以作为较为广泛的并发涉及</p><p>java中调动了线程会映射到操作系统中，两者是等价的</p><h1 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h1><p><img alt="" data-original="../images/15488896735763.png"></p><h1 id="线程的基本操作-1"><a href="#线程的基本操作-1" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h1><h2 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread t1=<span class="keyword">new</span> Thread(); t1.start();</span><br><span class="line">每一个线程都是runable接口的实现</span><br><span class="line">start方法就能把这个线程跑起来，开启一个线程</span><br><span class="line">在一个新的操作系统的线程上面调用run方法</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1=<span class="keyword">new</span> Thread(); t1.run(); </span><br><span class="line">不能开启线程</span><br></pre></td></tr></table></figure><p><strong><font color="red">调用run方法和调用start方法做的事情是一样的 ，但是run并不会开启新的线程而是在调用run的当前的这个线程当中执行这个操作，只有使用的start方法才是在真的一个新的线程当中执行run中的事情</font></strong></p><p>Thread.run()的实现 target 是Runnable接口（run是runnable接口中的一个方法）<br>run方法源码<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Runnable target;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line"> target.run();</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><p></p><p>Thread 的init方法：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Thread()&#123;</span><br><span class="line">init(<span class="literal">null</span>,<span class="literal">null</span>,<span class="string">"Thread-"</span>+nextThreadNum(),<span class="number">0</span>)</span><br><span class="line"><span class="comment">//init方法是在new对象的时候自动执行的</span></span><br><span class="line">&#125;</span><br><span class="line">private <span class="keyword">void</span> init(ThreadGroup g, Runnable target, <span class="built_in">String</span> name,</span><br><span class="line">                      long stackSize) &#123;</span><br><span class="line">        init(g, target, name, stackSize, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="调用run的一种方式"><a href="#调用run的一种方式" class="headerlink" title="调用run的一种方式"></a>调用run的一种方式</h2><p>这里的target本身就是传的null，所以就可以把run方法重载，把我们的方法写进去<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread t1=<span class="keyword">new</span> Thread()&#123; </span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run()&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello, I am t1"</span>);</span><br><span class="line">&#125; &#125;;</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p></p><h2 id="调用run另的一种方式"><a href="#调用run另的一种方式" class="headerlink" title="调用run另的一种方式"></a>调用run另的一种方式</h2><p>将target传到init方法中，来运行run方法。如下面CreateThread3（一个runnable的实例），这里不需要重载run方法，t1.start()的时候会自动去调用target.run。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> CreateThread3()); t1.start();</span><br></pre></td></tr></table></figure><p></p><h2 id="终止线程-（弃用）"><a href="#终止线程-（弃用）" class="headerlink" title="终止线程  （弃用）"></a>终止线程 <strong><font color="red">（弃用）</font></strong></h2><p>– Thread.stop() 不推荐使用。它会释放所有monitor<br>记录1:ID=1，NAME=小明<br>记录2:ID=2，NAME=小王</p><p><img alt="" data-original="../images/15488896869599.png"></p><p>如上图，在读和写的时候加入锁，当写完id，正要写name的时候，stop掉了thread，这个时候，会把锁释放掉，导致将id写了进去，name没有写进去，出现数据的不一致。</p><h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>public void Thread.interrupt() // 中断线程<br>public boolean Thread.isInterrupted() // 判断是否被中断<br>public static boolean Thread.interrupted() // 判断是否被中断，并清除当前中断状态<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> run()&#123; <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">Thread.yield();</span><br><span class="line">&#125; &#125;</span><br><span class="line">t1.interrupt();</span><br></pre></td></tr></table></figure><p></p><p>t1.interrupt();我只是告诉线程你应该终止了，对线程没有任何的影响，还是在跑着的。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> run()&#123; <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">System.out.println(<span class="string">"Interruted!"</span>); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Thread.yield();</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><p></p><p>通过Thread.currentThread().isInterrupted()判断当前的线程是不是被interrupt（），告知过要中断，是的话就break出while循环，同时终止run方法，也就自动终止了thread，这里不会出现数据的不一致，因为是在Thread.yield();（下一次数据处理之前）对线程进行终止的。<br><strong><font color="red">拓展</font></strong></p><p>public static native void sleep(long millis) throws InterruptedException<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> run()&#123; <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123; </span><br><span class="line">System.out.println(<span class="string">"Interruted!"</span>);</span><br><span class="line"><span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"Interruted When Sleep"</span>); </span><br><span class="line"><span class="comment">//设置中断状态，抛出异常后会清除中断标记位 </span></span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line"> Thread.yield();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>sleep即休眠方法。为什么休眠方法需要抛出 throws InterruptedException异常呢？<br>如果我在休眠的过程中，线程出现了isInterrupted（中断）的请求怎么办？这个时候如果sleep会抛出一个异常，同时自动清除interrupt（）设置的标志位，所以需要在抛出的异常中添加Thread.currentThread().interrupt();以保证能够被上面的Thread.currentThread().isInterrupted()检测到从而中断线程。</p><h2 id="挂起-suspend-和继续执行-resume-线程-弃用"><a href="#挂起-suspend-和继续执行-resume-线程-弃用" class="headerlink" title="挂起(suspend)和继续执行(resume)线程     (弃用)"></a>挂起(suspend)和继续执行(resume)线程 <strong><font color="red">(弃用)</font></strong></h2><p><strong><font color="red">suspend()不会释放锁 </font></strong>，发现suspend之后现场称还是runnable的状态，当然不代表所有的挂起后线程会runnable。<br>如果加锁发生在resume()之前 ，则死锁发生<br><img alt="" data-original="../images/15488897021929.png"></p><p>如上图，线程1挂起可，这个时候没有释放锁，希望通过线程2来resume锁，但是线程2的resume可能意外的发生在suspend之前，这个时候线程1将会永远的挂，其他的锁（如上图线程3）将会无线等待线程1拿到的锁。</p><h2 id="等待线程结束-join-和谦让-yeild"><a href="#等待线程结束-join-和谦让-yeild" class="headerlink" title="等待线程结束(join)和谦让(yeild)"></a>等待线程结束(join)和谦让(yeild)</h2><h3 id="yeild"><a href="#yeild" class="headerlink" title="yeild"></a>yeild</h3><p>当前线程优先级不是特别高，希望其他线程有机会争夺cpu时间，所以讲当前占用的cpu事件释放掉，使得其他的线程有更多的机会继续往下执行，但是下次还是有机会拿到cpu时间，不代表永远的让出去。</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>线程a希望知道线程b什么时候结束，因为需要在线程b结束的时候来立马做某些事情。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JoinMain</span> </span>&#123;</span><br><span class="line">public volatile <span class="keyword">static</span> int i=<span class="number">0</span>;</span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">@Override public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++); &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">AddThread at=<span class="keyword">new</span> AddThread();</span><br><span class="line"> at.start();</span><br><span class="line">at.join();</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><p></p><p>如上面的代码，希望在主线程中加入at方法，在at方法执行完毕之后再执行System.out.println(i);这句话。</p><p>join（有时间和没时间的，如果有无参数就是无限等待，有参数，就是等待一段时间如果还没有结束就继续往下执行，我等不起。）<br>join的本质<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">wait(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果线程是isalive（没死掉的），就无线等待，直到线程执行完毕后， 系统会调用 notifyAll()，注意 **<font color="red"> 不要在Thread实例上使用 wait()和notify()方法</font></p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>在后台默默地完成一些系统性的服务，比如垃圾回收线程、JIT线程就可以理解为守护线程<br>当一个Java应用内，只有守护线程时，Java虚拟机就会自然退出<br>Thread t=new DaemonT(); t.setDaemon(true); t.start();<br>举例子：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  psvm()&#123;</span><br><span class="line">Thread t =<span class="keyword">new</span> DeamonT();</span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>会发现，刚启动程序，就自动停掉了。</p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>public final static int MIN_PRIORITY = 1;<br>public final static int NORM_PRIORITY = 5;<br>public final static int MAX_PRIORITY = 10;<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread high=<span class="keyword">new</span> HightPriority(); LowPriority low=<span class="keyword">new</span> LowPriority(); </span><br><span class="line">high.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">low.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">low.start();</span><br><span class="line">high.start();</span><br></pre></td></tr></table></figure><p></p><p>low的优先级比high高<br>高优先级的线程更容易再竞争中获胜</p><h1 id="基本的线程同步操作"><a href="#基本的线程同步操作" class="headerlink" title="基本的线程同步操作"></a>基本的线程同步操作</h1><h2 id="synchronized-（注意拿到的东西必须是同一个"><a href="#synchronized-（注意拿到的东西必须是同一个" class="headerlink" title="synchronized     （注意拿到的东西必须是同一个)"></a>synchronized <strong><font color="red">（注意拿到的东西必须是同一个)</font></strong></h2><p>这个关键字是java内置的，所有的实现是在虚拟机内部做的，包括拿锁、线程挂起、挂起之前做的优化等待等。<br>– 指定加锁对象:对给定对象加锁，进入同步代码前要获得给定对象的锁。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AccoutingSync2</span>  <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> AccoutingSync2 instance = <span class="keyword">new</span> AccoutingSync2();</span><br><span class="line"><span class="keyword">static</span> int i =<span class="number">0</span> ;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">synchronized (instance) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>– 直接作用于实例方法:相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AccoutingSync2</span>  <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="comment">//static AccoutingSync2 instance = new AccoutingSync2();</span></span><br><span class="line"><span class="keyword">static</span> int i =<span class="number">0</span> ;</span><br><span class="line">public synchronized <span class="keyword">void</span> increase()&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">increase();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line"><span class="comment">//Thread t1 = new Thread(new AccoutingSync2());</span></span><br><span class="line"><span class="comment">//Thread t2 = new Thread(new AccoutingSync2());</span></span><br><span class="line">AccoutingSync2 accoutingSync2 = <span class="keyword">new</span> AccoutingSync2();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(accoutingSync2);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(accoutingSync2);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong><font color="red">注意上面的mian方法的两行注释，如果new两次AccoutingSync2，是两个对象，这样作用于方法上的锁，并不是一个实例对象，是不对的，必须是一个实例对象才能用这种方法。</font></strong></p><p>– 直接作用于静态方法:相当于对当前类加锁，进入同步代码前要获得当前类的锁。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> public <span class="class"><span class="keyword">class</span> <span class="title">AccoutingSync2</span>  <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="comment">//static AccoutingSync2 instance = new AccoutingSync2();</span></span><br><span class="line"><span class="keyword">static</span> int i =<span class="number">0</span> ;</span><br><span class="line">public synchronized <span class="keyword">void</span> increase()&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">increase();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AccoutingSync2());</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AccoutingSync2());</span><br><span class="line"><span class="comment">//AccoutingSync2 accoutingSync2 = new AccoutingSync2();</span></span><br><span class="line"><span class="comment">//Thread t1 = new Thread(accoutingSync2);</span></span><br><span class="line"><span class="comment">//Thread t2 = new Thread(accoutingSync2);</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong><font color="red">将上面的代码微整，将synchronized修饰的方法变为static的，这个方法是属于类的，此时main函数中的Thread可以通过new AccoutingSync2()的方式来new。</font></strong></p><h2 id="Object-wait-Obejct-notify"><a href="#Object-wait-Obejct-notify" class="headerlink" title="Object.wait() Obejct.notify()"></a>Object.wait() Obejct.notify()</h2><p>Object.wait()线程等待在当前对象上<br>Obejct.notify()通知等待在这个对象上的wait（）函数返回</p><p>Object.wait()必须要先获得当前object的锁才能去调用wait方法<br>Obejct.notify()也必须获得当前的object<br><strong><font color="red">注意：共有的锁必须在执行到synchronized代码之后才会被完全的释放</font></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.SQLOutput;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="built_in">Object</span> object = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">public <span class="keyword">void</span> run()&#123;</span><br><span class="line">synchronized (object)&#123;</span><br><span class="line">System.out.println(System.currentTimeMillis()+<span class="string">":T1 start!"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">System.out.println(System.currentTimeMillis()+<span class="string">":T1 wait for object "</span>);</span><br><span class="line">object.wait();</span><br><span class="line">&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis()+<span class="string">"T1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">public <span class="keyword">void</span> run()&#123;</span><br><span class="line">synchronized (object)&#123;</span><br><span class="line">System.out.println(System.currentTimeMillis()+<span class="string">":T2 start! notify one thread!"</span>);</span><br><span class="line">object.notify();</span><br><span class="line">System.out.println(System.currentTimeMillis()+<span class="string">"T2 end"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> T1();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> T2();</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="red"><br>注意上面的代码中wait和notify两个方法执行之前都需要获得object这个锁，包括wait的继续向下也需要这个锁<br>比如，打印出System.out.println(System.currentTimeMillis()+”T2 end”);这句话之后会不会立即打印出System.out.println(System.currentTimeMillis()+”T1 end”);？<br>答：不会因为wait和notify都在共用object这个锁，在输出System.out.println(System.currentTimeMillis()+”T2 end”);这句话的时候还没有完全释放object对象，简单来说就是代码还在synchronized (object){}这个代码块中，所以只能在等待sleep2000之后再重新回来执行T1 end的操作。</font><p>运行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">154604567447</span>：T1 start</span><br><span class="line"><span class="number">154604567441</span>：T1  wait <span class="keyword">for</span> object</span><br><span class="line"><span class="number">154604567442</span>：T2 start ! notify one thread!</span><br><span class="line"><span class="number">154604567443</span>：T2 end</span><br><span class="line"><span class="number">154604567444</span>：T1 end</span><br></pre></td></tr></table></figure><p>具体停留两秒的效果还需要读者自己尝试</p><p><img alt="" data-original="../images/15488897542597.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.omg.PortableServer.THREAD_POLICY_ID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLOutput;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="built_in">Object</span> object = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">public <span class="keyword">void</span> run()&#123;</span><br><span class="line">synchronized (object)&#123;</span><br><span class="line">System.out.println(System.currentTimeMillis()+<span class="string">":T1 start!"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">System.out.println(System.currentTimeMillis()+<span class="string">":T1 wait for object "</span>);</span><br><span class="line">object.wait();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis()+<span class="string">"T1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">public <span class="keyword">void</span> run()&#123;</span><br><span class="line">synchronized (object)&#123;</span><br><span class="line">System.out.println(System.currentTimeMillis()+<span class="string">":T2 start! notify one thread!"</span>);</span><br><span class="line">object.notifyAll();</span><br><span class="line">System.out.println(System.currentTimeMillis()+<span class="string">"T2 end"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> T1();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> T2();</span><br><span class="line">Thread t3 = <span class="keyword">new</span> T1();</span><br><span class="line">t1.start();</span><br><span class="line">t3.start();</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>描述：<br>可以看到上面的代码中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object.wait();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>这里在wait方法后进行了sleep，创建了两个t1，将两个释放都释放的时候，中间会间断一秒，同时印证了上面必须要让程序执行到synchronize代码块外面之后再进行下一步。</p><p>运行结果<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">154604567447</span>：T1 start</span><br><span class="line"><span class="number">154604567441</span>：T1  wait <span class="keyword">for</span> object</span><br><span class="line"><span class="number">154604567442</span>：T1 start</span><br><span class="line"><span class="number">154604567443</span>：T1  wait <span class="keyword">for</span> object</span><br><span class="line"><span class="number">154604567444</span>：T2 start ! notify one thread!</span><br><span class="line"><span class="number">154604567445</span>：T2 end</span><br><span class="line"><span class="number">154604567446</span>：T1 end</span><br><span class="line"><span class="number">154604567448</span>：T1 end</span><br></pre></td></tr></table></figure><p></p><p>具体停留效果需要读者亲自尝试。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;什么是线程？&quot;&gt;&lt;a href=&quot;#什么是线程？&quot; class=&quot;headerlink&quot; title=&quot;什么是线程
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java高并发程序设计学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="高并发" scheme="http://mmmmmm.me/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发程序设计学习笔记（一）：并行简介以及重要概念</title>
    <link href="http://mmmmmm.me/2019-01-30.html"/>
    <id>http://mmmmmm.me/2019-01-30.html</id>
    <published>2019-01-18T11:20:00.000Z</published>
    <updated>2019-03-13T03:34:02.123Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="为什么需要并行"><a href="#为什么需要并行" class="headerlink" title="为什么需要并行?"></a>为什么需要并行?</h1><p>– 业务要求<br>– 性能</p><h1 id="反对意见"><a href="#反对意见" class="headerlink" title="反对意见"></a>反对意见</h1><p>– Linus Torvalds :忘掉那该死的并行吧!<br>– 需要有多么奇葩的想象力才能想象出并行计算的用武之地?<br>Linus Torvalds炮轰过的技术<br>– GNU Emacs<br>– GNOME<br>– HFS+ (Mac OS 文件系统)<br>– Java<br>• “本质上我看到的只是 Java 引擎在走下坡路，因为它别无去处。 ”1998年8月<br>• “我不关心Java。多么可怕的语言。“2011年11月<br>– C++<br>• “事实是，C++编译器不值得信任。整个C++异常处理从根本上是错误的。“2004年1月19日 “<br>• 尽管 C++ 可以用于原型或简单的 GUI 编程，但它不能使事情更简单。C 语言虽然并不精益于系统编程语言，但它积极鼓励你使用简单和直接的结构。 “2007年9月7日<br>• “C ++ 是一个可怕的语言。”2007年9月6日<br>– XML<br>– Solaris<br>– MINIX</p><p>Linus Torvalds :并行计算只有在图像处理和服务端编程2个领域可以使用，并且它在这2个 领域确实有着大量广泛的使用。但是在其它任何地方，并行计算毫无建树!</p><h1 id="大势所趋"><a href="#大势所趋" class="headerlink" title="大势所趋"></a>大势所趋</h1><p>摩尔定律的失效<br>– 预计18个月会将芯片的性能提高一倍<br>– Intel CEO Barret单膝下跪对取消4GHz感到抱歉 • 在2004年秋季，Intel宣布彻底取消4GHz计划<br>– 虽然现在已经有了4GHZ的芯片，但频率极限已经逼近 10年过去了，我们还停留在4GHZ</p><p>顶级计算机科学家唐纳德·尔文·克努斯<br>– 在我看来，这种现象(并发)或多或少是由于硬件设计者 – 已经无计可施了导致的，他们将摩尔定律失效的责任 – 推脱给软件开发者。</p><p>并行计算还出于业务模型的需要<br>– 并不是为了提高系统性能，而是确实在业务上需要多个执行单元。 – 比如HTTP服务器，为每一个Socket连接新建一个处理线程<br>– 让不同线程承担不同的业务工作<br>– 简化任务调度</p><h1 id="几个重要的概念"><a href="#几个重要的概念" class="headerlink" title="几个重要的概念"></a>几个重要的概念</h1><h2 id="同步-synchronous-和异步-asynchronous"><a href="#同步-synchronous-和异步-asynchronous" class="headerlink" title="同步(synchronous)和异步(asynchronous)"></a>同步(synchronous)和异步(asynchronous)</h2><p><img alt="" data-original="../images/15488603988188.png"></p><p>同步异步是对于方法调用而言的。<br>同步调用会等待方法的返回，方法执行多久就要等待多久。<br>异步调用瞬间返回，但是调用并没有完成，会在后台起一个线程，所以不影响做下面的事情。</p><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p><img alt="" data-original="../images/15488604073805.png"></p><p>并发和并行的外在表象基本上是一致的。<br>并行：两个线程或者进程同时进行<br>并发：一会做事件a一会做事件b，如此重复调度<br>对于单核cpu来说只能是并发，对于多核cpu来说是可以并行的，但是对于外在表象来看，事件a和事件b不论是并行还是并发，都是在同时执行</p><h2 id="临界区"><a href="#临界区" class="headerlink" title="  临界区  "></a><strong><font color="red"> 临界区</font></strong></h2><p>– 临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程<br>使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。<br><img alt="" data-original="../images/15488604162301.png"></p><h2 id="阻塞-Blocking-和非阻塞-Non-Blocking"><a href="#阻塞-Blocking-和非阻塞-Non-Blocking" class="headerlink" title="阻塞(Blocking)和非阻塞(Non-Blocking)"></a>阻塞(Blocking)和非阻塞(Non-Blocking)</h2><p>– 阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其它所有需要 这个资源的线程就必须在这个临界区中进行等待，等待会导致线程挂起。这种情况就是阻塞。此时，如 果占用资源的线程一直不愿意释放资源，那么其它所有阻塞在这个临界区上的线程都不能工作。<br>– 非阻塞允许多个线程同时进入临界区</p><p>阻塞是在操作系统层面被挂起，阻塞的方式性能比较差，据统计，如果一个线程在操作系统层面被挂起，做了上下文切换，需要八万个时间周期来做这件事情，所以不是一个特别好的办法，但是是最简单的方法，虽然效率不是很高。</p><h2 id="死锁-Deadlock-、饥饿-Starvation-和活锁-Livelock"><a href="#死锁-Deadlock-、饥饿-Starvation-和活锁-Livelock" class="headerlink" title="死锁(Deadlock)、饥饿(Starvation)和活锁(Livelock)"></a>死锁(Deadlock)、饥饿(Starvation)和活锁(Livelock)</h2><p><img alt="" data-original="../images/15488604280104.png"></p><ol><li><p>死锁：a堵住了d，d堵住了c，c堵住了b，b堵住了a，a需要b开动，b需要c开动，c需要d开动，d需要a开动—–谁也不能动。<br>死锁虽然不好，但是是一个静态的问题，一旦死锁，所有的线程都停止，cpu的占用率是零</p></li><li><p>活锁：电梯里人想出来，外面的人想进去，都想避开，里面的人往左面靠，外面的人往右边靠，还是不能避开，里面的人往右面靠，外面的人往左边靠，如此往复。<br>又或者a线程需要资源1、2，b线程需要资源1、2，这个时候a抢到了1，b抢到了2，都不能工作，这个时候都释放出来，a又去抢到了2，b抢到了1，如此往复。<br>简言之，就是资源来线程之间跳来跳去，也无法进行下去。<br>活锁比死锁更难查找，因为是动态的问题。</p></li><li><p>饥饿：a线程优先级比b低，所以调度的时候调度不到a，就不能继续往下执行，就会饿死，或者资源竞争优先级比较低，也会导致饿死。<br>饥饿是指某一个或 者多个线程因为种 种原因无法获得所 需要的资源，导致 一直无法执行。</p><h2 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h2></li><li>阻塞:当一个线程进入临界区后，其他线程必须等待</li><li>非阻塞（下面三个）</li></ol><h3 id="–-无障碍"><a href="#–-无障碍" class="headerlink" title="– 无障碍"></a>– 无障碍</h3><p>无障碍是一种最弱的非阻塞调度<br>自由出入临界区<br>无竞争时，有限步内完成操作<br>有竞争时，回滚数据有竞争时，回滚数据<br>好进不好出，很容易进去，但是进去发现很多线程竞争相同的资源的时候，会需要回滚数据，比如要读取xy，已经读过了x，读到y的时候发现在竞争，会从x重新读。</p><h3 id="–-无锁"><a href="#–-无锁" class="headerlink" title="– 无锁"></a>– 无锁</h3><p>是无障碍的<br>保证有一个线程可以胜出<br>while (!atomicVar.compareAndSet(localVar, localVar+1)) {<br>localVar = atomicVar.get();<br>}<br>因为无障碍中，如果存在不断的竞争，将会所有的都出不来，所以无锁就需要每次竞争都能胜出一个，这样保证程序能够顺畅的执行下去。</p><h3 id="–-无等待"><a href="#–-无等待" class="headerlink" title="–   无等待"></a>– 无等待</h3><p>无锁的<br>要求所有的线程都必须在有限步内完成 ，所有的线程都能在有线的事件内都从临界区出来。<br>无饥饿的，因为所有的线程都必须在有限步内完成 ，所以是无饥饿的。<br>举例子：<br>只有读线程没有写线程，就是无等待的。<br>如果有写线程的话，就会出现资源竞争也就是上面的无障碍的状态，怎么办呢？在每次写之前把数据拷贝一次副本，在写线程中拿到副本，修改副本，修改数据的过程可能需要点时间，可是修改的是副本不是原始的数据，所以在这个过程中的读线程仍然是无等待的。写线程也只是一直在写，所以也是无等待的。<br>最后需要时就是将副本覆盖原始数据而已。</p><h1 id="有关并行的2个重要定律"><a href="#有关并行的2个重要定律" class="headerlink" title="有关并行的2个重要定律"></a>有关并行的2个重要定律</h1><p>Amdahl定律(阿姆达尔定律)<br>Gustafson定律(古斯塔夫森)</p><h2 id="Amdahl定律-阿姆达尔定律"><a href="#Amdahl定律-阿姆达尔定律" class="headerlink" title="Amdahl定律(阿姆达尔定律)"></a>Amdahl定律(阿姆达尔定律)</h2><p>– 定义了串行系统并行化后的加速比的计算公式和理论上限 – 加速比定义:加速比=优化前系统耗时/优化后系统耗时<br><img alt="" data-original="../images/15488604384317.png"></p><p>在步骤二和步骤五的地方运用了并行<br>加速比=优化前系统耗时/优化后系统耗时=500/400=1.25<br><img alt="" data-original="../images/15488604475199.png"></p><p>将上面的例子代入公式：f（串行比例）= 五分之三，这里默认两个cpu<br><img alt="" data-original="../images/15488604582818.png"></p><p>由上面的公式可以得出：<br>增加CPU处理器的数量（n）并不一定能起到有效的作用 提高系统内可并行化的模块比重，合理增加并行处 理器数量（1-f），才能以最小的投入，得到最大的加速比</p><h2 id="Gustafson定律-古斯塔夫森"><a href="#Gustafson定律-古斯塔夫森" class="headerlink" title="Gustafson定律(古斯塔夫森)"></a>Gustafson定律(古斯塔夫森)</h2><p>– 说明处理器个数，串行比例和加速比之间的关系<br><img alt="" data-original="../images/15488604673216.png"></p><p>只要有足够的并行化，那么加速 比和CPU个数成正比</p><p>结论：两个结论虽然不同，但是总的来说就是要处理好n（cpu的个数）和f（串行化比例），因为公式中只和这两个参数有关系。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;为什么需要并行&quot;&gt;&lt;a href=&quot;#为什么需要并行&quot; class=&quot;headerlink&quot; title=&quot;为什么
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java高并发程序设计学习笔记" scheme="http://mmmmmm.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="高并发" scheme="http://mmmmmm.me/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>hexo next主题深度优化(十)，博文加密，不需要插件，极简模式，相对安全，融合pjax</title>
    <link href="http://mmmmmm.me/hexo_shi_jiami.html"/>
    <id>http://mmmmmm.me/hexo_shi_jiami.html</id>
    <published>2018-12-20T14:52:00.000Z</published>
    <updated>2019-08-14T11:30:09.561Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><p>果想自定义功能样式的往下面看看也许会有点收获，为了避免读者不耐烦的看我的废话，所以移到了下面。<br>本人博客：mmmmmm.me</p><h1 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h1><p><img alt="upload successful" data-original="../images/my_blog_25.png"></p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><p>/blog/themes/next/layout/_layout.swig，找到main标签在吐下代码处添加自定义的swig<br>_layout.swig：<br></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"pjax-container"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">main</span> <span class="attr">id</span>=<span class="string">"main"</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main-inner"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-wrap"</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            </span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> content %&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          </span><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> '_third-party/duoshuo-hot-articles.swig' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">          </span><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> '_partials/comments.swig' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.sidebar.display !== 'remove' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">          </span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> sidebar %&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      //这个是我自己写的swig，因为需要得到post的password参数，名字自己随便起。</span></span><br><span class="line"><span class="xml">      //如果博客中加入了pjax需要放在pjax的container中，每次刷新会重新加载container中的内容，也就默认重新加载我们这个简单的js了，如果没有加入pjax的话，位置就不重要了</span></span><br><span class="line"><span class="xml">      </span><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> 'password.swig' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p></p><p>新建swig，目录：themes/next/layout/password.swig（和上面的_layout.swig在同级目录，具体路径在上面的include中可以自定义的。）<br>password.swig：<br></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">//暂时储存文章中的内容</span></span><br><span class="line"><span class="keyword">var</span> div = $('.<span class="keyword">post</span>-body');</span><br><span class="line"><span class="comment">//暂时储存目录的内容</span></span><br><span class="line"><span class="keyword">var</span> toc=$('.<span class="keyword">post</span>-toc-wrap')</span><br><span class="line">function password() &#123;</span><br><span class="line">  <span class="keyword">if</span>('&#123;&#123; page.password &#125;&#125;')&#123;</span><br><span class="line">  <span class="comment">//将文章内容删除</span></span><br><span class="line">    div.remove();</span><br><span class="line"> <span class="comment">//将目录删除 </span></span><br><span class="line">    toc.remove();</span><br><span class="line">  <span class="comment">//将文章删除后，向原来文章的地方添加，应该出现的提示用户输入密码的样式</span></span><br><span class="line">  <span class="comment">//下面这里的第一个用textarea是因为如果在手机端的时候只能显示一部分文字，</span></span><br><span class="line">  <span class="comment">//只是拓展:input里面的字只能显示一行，不会自动换行，目前上网搜索没有发现好的办法，所以用了textarea，右下角的小三角通过resize:none 去掉。</span></span><br><span class="line">   $('.<span class="keyword">post</span>-header').after('&lt;textarea <span class="keyword">class</span>=<span class="string">"description"</span> value=<span class="string">"Please enter your password and press enter to build"</span> style=<span class="string">"border: none;display: block;' +'width: 60%;margin: 0 auto;text-align: center;outline: none;margin-bottom: 50px;resize:none "</span>&gt;</span><br><span class="line">      Please enter your password and press enter to build&lt;/textarea&gt;' +</span><br><span class="line">      '&lt;div <span class="keyword">class</span>=<span class="string">"qiang"</span> style=<span class="string">"height: 100px;width: 60%;margin:0 auto"</span>&gt;' +</span><br><span class="line">      '&lt;<span class="keyword">input</span> <span class="keyword">class</span>=<span class="string">"password"</span>  <span class="keyword">type</span>=<span class="string">"text"</span> value=<span class="string">""</span> style="border: none;<span class="keyword">display</span>: block;border-bottom: 1px solid #ccc;' +</span><br><span class="line">      'margin: 0 auto;outline: none;width:95%"/&gt;' +</span><br><span class="line">      '&lt;/div&gt;')</span><br><span class="line">      <span class="comment">//绑定点击事件，如果是点击的.password 这个div就改变样式，如果是document中除了div之外的其他任何元素，就变回原来的样式。</span></span><br><span class="line">    document.onclick = function (event) &#123;</span><br><span class="line">      <span class="keyword">var</span> <span class="keyword">e</span> = event || <span class="keyword">window</span>.event;</span><br><span class="line">      <span class="keyword">var</span> elem = <span class="keyword">e</span>.srcElement || <span class="keyword">e</span>.target;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (elem) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem != document) &#123;</span><br><span class="line">          <span class="keyword">if</span> (elem.className == <span class="string">"password"</span>) &#123;</span><br><span class="line">            $(<span class="string">".password"</span>).animate(&#123;paddingTop:<span class="string">"30px"</span>,width:<span class="string">"100%"</span>,borderWidth:<span class="string">"2px"</span>&#125;,300)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          elem = elem.parentNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          $(<span class="string">".password"</span>).animate(&#123;paddingTop:<span class="string">"0px"</span>,width:<span class="string">"95%"</span>,borderWidth:<span class="string">"1px"</span>&#125;,300)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定enter键按下后离开的事件</span></span><br><span class="line">    $(document).keyup(function(event)&#123;</span><br><span class="line">      <span class="keyword">if</span>(event.keyCode ==13&amp;&amp;$('.password').length&gt;0)&#123;</span><br><span class="line">        <span class="comment">//console.log($('.password').val())</span></span><br><span class="line">        <span class="comment">//console.log('&#123;&#123; page.password &#125;&#125;')</span></span><br><span class="line">        <span class="keyword">if</span> ($('.password').val() == '&#123;&#123; page.password &#125;&#125;') &#123;</span><br><span class="line">        <span class="comment">//恢复文章内容</span></span><br><span class="line">          (div).appendTo($(<span class="string">".post-header"</span>))</span><br><span class="line">          <span class="comment">//恢复目录</span></span><br><span class="line">          toc.appendTo($(<span class="string">".sidebar-inner"</span>))</span><br><span class="line">                 <span class="comment">//删除本页面的输入密码组件</span></span><br><span class="line">           $(<span class="string">".description"</span>).remove();</span><br><span class="line">          $(<span class="string">".qiang"</span>).remove();</span><br><span class="line">          $(<span class="string">".password"</span>).remove();</span><br><span class="line">          <span class="comment">//重新处理pjax事件,如果没有加pjax的从下面这行起到下面的else之间的代码需要去掉。</span></span><br><span class="line">          <span class="comment">//图片懒加载，没有加入此功能的这个函数需要去掉</span></span><br><span class="line">          $('img').lazyload(&#123;</span><br><span class="line">             placeholder: '../images/loading.gif',</span><br><span class="line">             effect: 'fadeIn',</span><br><span class="line">             threshold : 100,</span><br><span class="line">             failure_limit : 20,</span><br><span class="line">             skip_invisible : false</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="comment">//pjax后出现文章不显示，没有pjax的下面四行需要去掉</span></span><br><span class="line">            $(<span class="string">".post-block"</span>).css(&#123;opacity:1&#125;);</span><br><span class="line">            $(<span class="string">".post-header"</span>).css(&#123;opacity:1&#125;);</span><br><span class="line">            $(<span class="string">".post-body"</span>).css(&#123;opacity:1&#125;);</span><br><span class="line">            $(<span class="string">".pagination"</span>).css(&#123;opacity:1&#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          alert(<span class="string">"Sorry, the password is wrong."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将document的keyup移除，防止在pjax的情况下会重复绑定事件</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">password();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p></p><p>新建一个test.md<br>test.md<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">测试</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-30</span> <span class="number">21</span><span class="string">:18:02</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">aaa</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># aaaaaa</span></span><br><span class="line"><span class="string">我就很反感大家老是那么说我，</span></span><br><span class="line"><span class="comment">## bbbbbb</span></span><br><span class="line"><span class="string">除了有才，就只剩下那无可比拟的颜值。</span></span><br></pre></td></tr></table></figure><p></p><p>上面的password后面的值自定义。</p><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><p>如果自己的博客源码中的这篇文章上传到github，密码也就公诸于世了，可以再push到github的时候将这篇文章忽略。</p><h1 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h1><p>预给自己加入文章加密的功能。</p><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><h2 id="https-www-jianshu-com-p-90c0a15c6f36"><a href="#https-www-jianshu-com-p-90c0a15c6f36" class="headerlink" title="https://www.jianshu.com/p/90c0a15c6f36"></a><a href="https://www.jianshu.com/p/90c0a15c6f36" target="_blank" rel="noopener">https://www.jianshu.com/p/90c0a15c6f36</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script&gt;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">'&#123;&#123; page.password &#125;&#125;'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (prompt(<span class="string">'请输入查看密码'</span>) !== <span class="string">'&#123;&#123; page.password &#125;&#125;'</span>)&#123;</span><br><span class="line">                alert(<span class="string">'密码不正确,请询问主编大大'</span>);</span><br><span class="line">                history.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>不用试看看也知道没问题，可是网上说这个容易被破解，因为只是在alert的时候不显示，但是懂编程的人只要打开审查工具就能看到了。pass</p><h2 id="http-zhailiange-com-2017-07-06-hexo-encrypt"><a href="#http-zhailiange-com-2017-07-06-hexo-encrypt" class="headerlink" title="http://zhailiange.com/2017/07/06/hexo-encrypt/"></a><a href="http://zhailiange.com/2017/07/06/hexo-encrypt/" target="_blank" rel="noopener">http://zhailiange.com/2017/07/06/hexo-encrypt/</a></h2><p>hexo-blog-encrypt插件和hexo-encrypt插件，同样尝试过，如果没有pjax肯定是没问题的，因为我加入了pjax在跳转页面的时候有的js会不加载，所以会报错，放弃</p><h2 id="自己写"><a href="#自己写" class="headerlink" title="自己写"></a>自己写</h2><p>一开始通过网_layout.swig里面引入 script的方式，可是在js文件中是的不到hexo自定义的page变量的（hexo中还有好多变量，比如site，theme等），所以在swig中能够得到这个变量，也就是我们文章中的password，当然你还可以自定义许多变量，比如在config文件中定义是否使用password功能，在文章中增加message（简称就是输入密码上方给用户说的话，或者文章的简单概要等，自定义即可）标签，然后通过js读到本篇文章的message，自定义的添加到页面中展示给用户，等等都可以通过来得到。<br>当然自己写的初衷就是因为自己的pjax，这下子，终于可以成功的完美融合到pjax中，还学到不少的只是呢。</p><h1 id="2018-12-23代码更新"><a href="#2018-12-23代码更新" class="headerlink" title="2018.12.23代码更新"></a>2018.12.23代码更新</h1><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>发现输入密码成功之后，在页面的底部还有请输入密码的组件,在恢复文章的后面加下面三行（已在上面的代码中更新）<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".description"</span>).remove();</span><br><span class="line">$(<span class="string">".qiang"</span>).remove();</span><br><span class="line">$(<span class="string">".password"</span>).remove();</span><br></pre></td></tr></table></figure><p></p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>因为博客中加入了pjax，在局部刷新的时候，$(document).keyup并没有移除，所以当点击某文章的时候第一次没问题，再不刷新页面的情况下，再次进入，第二次进入的时候是通过pjax进入的，这样就给$(document)绑定了两次keyup事件，第三次的话就会绑定三次，第四次绑定四次，如此往复，出现的现象是前几次报密码错误，最后一次进入正常，调试的时候前几次得到的password的value值都是undifined<br>解决：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'pjax:start'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="built_in">document</span>).unbind(<span class="string">'keyup'</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p></p><p>在每次pjax发送请求开始就移除事件。</p><h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><p>当输入密码进入页面，按回车键会不断的alert 密码错误<br>加入判断（上面已经修改）<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;$(<span class="string">'.password'</span>).length&gt;<span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;果想自定义功能样式的往下面看看也许会有点收获，为了避免读者不耐烦的看我的废话，所以移到了下面。&lt;br&gt;本人博客：mmmmmm
      
    
    </summary>
    
      <category term="hexo" scheme="http://mmmmmm.me/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://mmmmmm.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo next主题深度优化(九)，给博客加入主题，护眼主题，护眼色</title>
    <link href="http://mmmmmm.me/hexo_jiu_eye.html"/>
    <id>http://mmmmmm.me/hexo_jiu_eye.html</id>
    <published>2018-12-18T12:37:00.000Z</published>
    <updated>2019-08-14T11:30:09.534Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我从小爱打游戏，所以视力下降厉害，加上现在工作天天对着电脑，所以想给自己的博客加上护眼色。</p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>博客：mmmmmm.me</p><p><img alt="upload successful" data-original="../images/my_blog_23.png"></p><p><img alt="upload successful" data-original="../images/my_blog_24.png"></p><h1 id="码"><a href="#码" class="headerlink" title="码"></a>码</h1><h2 id="layout-swig"><a href="#layout-swig" class="headerlink" title="_layout.swig"></a>_layout.swig</h2><p>在body下面<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"eye"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"eye1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:#C7EDCC"</span>&gt;</span>豆沙绿<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:#FAF9DE"</span>&gt;</span>杏仁黄 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:#FFFFFF"</span>&gt;</span>银河白<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:#000000"</span>&gt;</span>极光黑<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"eye2"</span>&gt;</span>满天星<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><h2 id="custom-styl"><a href="#custom-styl" class="headerlink" title="custom.styl"></a>custom.styl</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.eye</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">68px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">66px</span>;</span><br><span class="line">  <span class="comment">//background-color:transparent;</span></span><br><span class="line">  <span class="attribute">font-size</span> :<span class="number">12px</span>;</span><br><span class="line"><span class="attribute">line-height</span> :<span class="number">33px</span>;</span><br><span class="line">  <span class="attribute">text-align</span> :center;</span><br><span class="line">  <span class="attribute">z-index</span> :<span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.eye1</span>&#123;</span><br><span class="line">    <span class="attribute">float</span> :left;</span><br><span class="line"><span class="attribute">display</span> :none;</span><br><span class="line">  <span class="attribute">height</span> :<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.eye1</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">height</span> :<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">  <span class="attribute">padding</span> :<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span> :<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">.eye1 ul li&#123;</span><br><span class="line">  float :left;</span><br><span class="line">  <span class="attribute">width</span> :<span class="number">23px</span>;</span><br><span class="line">  <span class="attribute">line-height</span> :<span class="number">22px</span></span><br><span class="line">  text-align :center;</span><br><span class="line">  <span class="attribute">font-size</span> :<span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.eye1</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>:hover &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span> : <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: scale(<span class="number">1.1</span>);</span><br><span class="line">  -moz-<span class="attribute">transform</span>: scale(<span class="number">1.1</span>);</span><br><span class="line">  -ms-<span class="attribute">transform</span>: scale(<span class="number">1.1</span>);</span><br><span class="line">  -o-<span class="attribute">transform</span>: scale(<span class="number">1.1</span>);</span><br><span class="line">  <span class="attribute">transform</span>: scale(<span class="number">1.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.eye2</span>&#123;</span><br><span class="line">  <span class="attribute">float</span> :left;</span><br><span class="line">  <span class="attribute">width</span> :<span class="number">18px</span>;</span><br><span class="line">  <span class="attribute">line-height</span> :<span class="number">22px</span></span><br><span class="line">  text-align :center;</span><br><span class="line">  <span class="attribute">font-size</span> :<span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#e6e6e6</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="selector-class">.eye2</span>:hover&#123;</span><br><span class="line">    <span class="attribute">border-bottom</span> : <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: scale(<span class="number">1.1</span>);</span><br><span class="line">    -moz-<span class="attribute">transform</span>: scale(<span class="number">1.1</span>);</span><br><span class="line">    -ms-<span class="attribute">transform</span>: scale(<span class="number">1.1</span>);</span><br><span class="line">    -o-<span class="attribute">transform</span>: scale(<span class="number">1.1</span>);</span><br><span class="line">    <span class="attribute">transform</span>: scale(<span class="number">1.1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="eye-js"><a href="#eye-js" class="headerlink" title="eye.js"></a>eye.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">eye</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">".eye .eye2"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">".eye .eye1"</span>).slideToggle();</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  $(<span class="string">".eye ul li"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">".eye .eye1"</span>).slideToggle();</span><br><span class="line">    $color=$(<span class="keyword">this</span>).css(<span class="string">"background-color"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log($color);</span><br><span class="line">    $(<span class="string">".eye .eye1"</span>).css(<span class="string">"background"</span>,$color);</span><br><span class="line">      $(<span class="string">"#canvas"</span>).css(<span class="string">"background"</span>,$color);</span><br><span class="line">      $(<span class="string">"article"</span>).css(<span class="string">"background"</span>,$color);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">eye()</span><br></pre></td></tr></table></figure><h1 id="引用eye-js"><a href="#引用eye-js" class="headerlink" title="引用eye.js"></a>引用eye.js</h1><h2 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h2><p>在_layout.swig<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"xxxxxxxxxx.eye.js"</span>&gt;</span><span class="undefined"></span></span><br></pre></td></tr></table></figure><p></p><p>没有用到require.js和pjax的到这里就结束了，用了的往下看</p><hr><h2 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">"eye"</span>:<span class="string">"/js/src/pjax/eye"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">require</span>([<span class="string">'eye'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="pjax的函数中重写"><a href="#pjax的函数中重写" class="headerlink" title="pjax的函数中重写"></a>pjax的函数中重写</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eye_js</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $color=$(<span class="string">"#canvas"</span>).css(<span class="string">"background"</span>);</span><br><span class="line">  $(<span class="string">"article"</span>).css(<span class="string">"background"</span>,$color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h
      
    
    </summary>
    
      <category term="hexo" scheme="http://mmmmmm.me/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://mmmmmm.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo next主题深度优化(八)，微加速</title>
    <link href="http://mmmmmm.me/hexo_ba_jiasu.html"/>
    <id>http://mmmmmm.me/hexo_ba_jiasu.html</id>
    <published>2018-12-18T12:32:00.000Z</published>
    <updated>2019-08-14T11:30:09.525Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><p>通过不断地上网查资料，引用的js、css、图片文件，通过cdn的方式是比直接放到本地要慢的，所以将自己博客能找到的cdn全部换成本地文件。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;通过不断地上网查资料，引用的js、css、图片文件，通过cdn的方式是比直接放到本地要慢的，所以将自己博客能找到的cdn全部
      
    
    </summary>
    
      <category term="hexo" scheme="http://mmmmmm.me/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://mmmmmm.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo next主题深度优化(七)，cdn加速</title>
    <link href="http://mmmmmm.me/hexo_qi_cdn.html"/>
    <id>http://mmmmmm.me/hexo_qi_cdn.html</id>
    <published>2018-12-18T12:27:00.000Z</published>
    <updated>2019-08-14T11:30:09.529Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h1><p>千万不要被我的标题迷惑，这不是一个给博客加cdn的博文。</p><h1 id="正题："><a href="#正题：" class="headerlink" title="正题："></a>正题：</h1><p>想给网站各种加速，终于到了cdn这块。</p><h2 id="免费cdn"><a href="#免费cdn" class="headerlink" title="免费cdn"></a>免费cdn</h2><p>“免费的都是最贵的”，百度的移动节点不能用，还有很多都是单节点，很多都是自己能访问，有的地区就访问不到，只有收费才能提供更好的服务，都是打着免费的幌子，变相的收费，遂放弃。</p><h2 id="收费cdn"><a href="#收费cdn" class="headerlink" title="收费cdn"></a>收费cdn</h2><p>有点贵，貌似100或者200 1Mb/s,对于我的小blog有点贵，以后流量多了肯定会接入的，经过前面的优化，感觉速度已经上升了一大截了，希望以后有机会搞大型网站，这样就可以不花自己的钱玩cdn了，坏坏哒~</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;注：&quot;&gt;&lt;a href=&quot;#注：&quot; class=&quot;headerlink&quot; title=&quot;注：&quot;&gt;&lt;/a&gt;注：&lt;/h
      
    
    </summary>
    
      <category term="hexo" scheme="http://mmmmmm.me/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://mmmmmm.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo next主题深度优化(六)，使用hexo-neat插件压缩页面，大幅度提升页面性能和响应速度</title>
    <link href="http://mmmmmm.me/hexo_liu_yasuo.html"/>
    <id>http://mmmmmm.me/hexo_liu_yasuo.html</id>
    <published>2018-12-18T12:20:00.000Z</published>
    <updated>2019-08-14T11:30:09.544Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="感谢："><a href="#感谢：" class="headerlink" title="感谢："></a>感谢：</h1><p><a href="https://blog.csdn.net/lewky_liu/article/details/82432003" target="_blank" rel="noopener">https://blog.csdn.net/lewky_liu/article/details/82432003</a><br><a href="https://blog.csdn.net/qq_21808961/article/details/84639472" target="_blank" rel="noopener">https://blog.csdn.net/qq_21808961/article/details/84639472</a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>hexo 的文章是通过md格式的文件经过swig转换成的html，生成的html会有很多空格，而且自己写的js以及css中会有很多的空格和注释。<br>js和java不一样，注释也会影响一部分的性能，空格同样是的。<br>经过上网查阅，发现hexo有自带的压缩插件。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="试水"><a href="#试水" class="headerlink" title="试水"></a>试水</h2><p>gulp<br>上网查阅资料，自己尝试过。<br>npm下载插件都下载中断了，可能我操作有误，有兴趣的小伙伴可以试一试。</p><h2 id="成功的案例"><a href="#成功的案例" class="headerlink" title="成功的案例"></a>成功的案例</h2><h3 id="安装插件，执行命令。"><a href="#安装插件，执行命令。" class="headerlink" title="安装插件，执行命令。"></a>安装插件，执行命令。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-neat <span class="comment">--save</span></span><br></pre></td></tr></table></figure><h3 id="hexo-config-yml文件添加"><a href="#hexo-config-yml文件添加" class="headerlink" title="hexo _config.yml文件添加"></a>hexo _config.yml文件添加</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-neat</span></span><br><span class="line"><span class="comment"># 博文压缩</span></span><br><span class="line"><span class="attr">neat_enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 压缩html</span></span><br><span class="line"><span class="attr">neat_html:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  exclude:</span></span><br><span class="line"><span class="comment"># 压缩css  </span></span><br><span class="line"><span class="attr">neat_css:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  exclude:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/*.min.css'</span></span><br><span class="line"><span class="comment"># 压缩js</span></span><br><span class="line"><span class="attr">neat_js:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  mangle:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  output:</span></span><br><span class="line"><span class="attr">  compress:</span></span><br><span class="line"><span class="attr">  exclude:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/*.min.js'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/jquery.fancybox.pack.js'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/index.js'</span></span><br></pre></td></tr></table></figure><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><h4 id="跳过压缩文件的正确配置方式"><a href="#跳过压缩文件的正确配置方式" class="headerlink" title="跳过压缩文件的正确配置方式"></a>跳过压缩文件的正确配置方式</h4><p>如果按照官方插件的文档说明来配置exclude，你会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。你需要给这些文件指定正确的路径，万能的配置方式如下：<br>neat_css:<br>enable: true<br>exclude:</p><pre><code>- &apos;**/*.min.css&apos;</code></pre><h4 id="压缩html时不要跳过-md文件"><a href="#压缩html时不要跳过-md文件" class="headerlink" title="压缩html时不要跳过.md文件"></a>压缩html时不要跳过.md文件</h4><p>.md文件就是我们写文章时的markdown文件，如果跳过压缩.md文件，而你又刚好在文章中使用到了NexT自带的tab标签，那么当hexo在生成静态页面时就会发生解析错误。这会导致使用到了tab标签的页面生成失败而无法访问。</p><h4 id="压缩html时不要跳过-swig文件"><a href="#压缩html时不要跳过-swig文件" class="headerlink" title="压缩html时不要跳过.swig文件"></a>压缩html时不要跳过.swig文件</h4><p>.swig文件是模板引擎文件，简单的说hexo可以通过这些文件来生成对应的页面。如果跳过这些文件，那么你将会发现，你的所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白。</p><h4 id="点击的桃心效果消失"><a href="#点击的桃心效果消失" class="headerlink" title="点击的桃心效果消失"></a>点击的桃心效果消失</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    -<span class="ruby"> <span class="string">'**/*.min.js'</span></span></span><br><span class="line"><span class="ruby">    - <span class="string">'**/jquery.fancybox.pack.js'</span></span></span><br><span class="line"><span class="ruby">    - <span class="string">'**/index.js'</span>  </span></span><br><span class="line"><span class="ruby">    - <span class="string">'**/love.js'</span></span></span><br></pre></td></tr></table></figure><h4 id="gitalk-js文件报错"><a href="#gitalk-js文件报错" class="headerlink" title="gitalk js文件报错"></a>gitalk js文件报错</h4><p>在上面的代码底部加入如下代码</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> <span class="string">'**/comments.gitalk.js'</span></span></span><br></pre></td></tr></table></figure><h4 id="jquery-pjax-min-js报错"><a href="#jquery-pjax-min-js报错" class="headerlink" title="jquery pjax min js报错"></a>jquery pjax min js报错</h4><p>我这里的 jquery pjax min js是指的加入pjax前需要以来的两个cdn文件，一个是jq，一个是它，我将它下载到了本地，不要在意这些细节~<br>同样加入如下代码<br></p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> <span class="string">'**/jquery_pjax_min_js.js'</span></span></span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;感谢：&quot;&gt;&lt;a href=&quot;#感谢：&quot; class=&quot;headerlink&quot; title=&quot;感谢：&quot;&gt;&lt;/a&gt;感谢
      
    
    </summary>
    
      <category term="hexo" scheme="http://mmmmmm.me/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://mmmmmm.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo next主题深度优化(五)，评论系统换成gittalk</title>
    <link href="http://mmmmmm.me/hexo_wu_gitalk.html"/>
    <id>http://mmmmmm.me/hexo_wu_gitalk.html</id>
    <published>2018-12-18T12:19:00.000Z</published>
    <updated>2019-08-14T11:30:09.541Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h1><p>之前一直用的是来必力的评论系统，还不错，但是因为我加入了pjax，能力有限，虽然降来必力的js重现，但是每次返回到首页都会报错id notfound ，阅读了来必力的api，全是并没有找到很多好的答案。遂换成gittalk的评论系统。</p><h1 id="开始："><a href="#开始：" class="headerlink" title="开始："></a>开始：</h1><h2 id="新建comments-git-js"><a href="#新建comments-git-js" class="headerlink" title="新建comments_git.js"></a>新建comments_git.js</h2><p>注：配置文件中的详细，自己网上查查。<br></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>($(<span class="string">'#gitalk-container'</span>).length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">  var gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gitalk的主要参数</span></span><br><span class="line"><span class="string">clientID:</span> `Github Application clientID`,</span><br><span class="line"><span class="string">clientSecret:</span> `Github Application clientSecret`,</span><br><span class="line"><span class="string">repo:</span> `Github 仓库名`,<span class="comment">//存储你评论 issue 的 Github 仓库名（建议直接用 GitHub Page 的仓库名）</span></span><br><span class="line"><span class="string">owner:</span> <span class="string">'Github 用户名'</span>,</span><br><span class="line"><span class="string">admin:</span> [<span class="string">'Github 用户名'</span>], <span class="comment">//这个仓库的管理员，可以有多个，用数组表示，一般写自己,</span></span><br><span class="line"><span class="string">id:</span> <span class="string">'window.location.pathname'</span>, <span class="comment">//页面的唯一标识，gitalk 会根据这个标识自动创建的issue的标签,我们使用页面的相对路径作为标识</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">  gitalk.render(<span class="string">'gitalk-container'</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="找到comments-swig在最后一个endif之前"><a href="#找到comments-swig在最后一个endif之前" class="headerlink" title="找到comments.swig在最后一个endif之前"></a>找到comments.swig在最后一个endif之前</h2><p>（目录：themes/next/layout/_partials/comments.swig）<br></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"gitalk-container"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p></p><h2 id="引入代码"><a href="#引入代码" class="headerlink" title="引入代码"></a>引入代码</h2><p>_layour.swig<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/src/pjax/comments/comments.gitalk.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>在这里引入而不再require引入的原因，就像我的另一篇文章，define只能定义一次，引不进去。<br>main.js<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  paths: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">"music"</span>: <span class="string">"/dist/music"</span>,</span><br><span class="line">    <span class="string">"aplayer"</span>: <span class="string">"/js/src/aplayer"</span>,</span><br><span class="line">    <span class="string">"backgroudLine"</span>: <span class="string">"/js/src/backgroudLine"</span>,</span><br><span class="line">    <span class="string">"category"</span>: <span class="string">"/js/src/category"</span>,</span><br><span class="line">    <span class="string">"jquery.share.min"</span>:<span class="string">"/js/src/pjax/share/jquery.share.min"</span>,</span><br><span class="line">    <span class="comment">/*不显示图标的话替换fonts*/</span></span><br><span class="line">    <span class="string">"share"</span>:<span class="string">"/js/src/pjax/share"</span>,</span><br><span class="line">    <span class="string">"css"</span>:<span class="string">"/js/src/pjax/css"</span>,</span><br><span class="line">    <span class="string">"comments"</span>:<span class="string">"/js/src/pjax/comments_git"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  shim: &#123;</span><br><span class="line">    <span class="string">'share'</span>: &#123;</span><br><span class="line">      deps: [</span><br><span class="line">        <span class="string">'css!/js/src/pjax/share/share.min'</span>,<span class="string">'jquery.share.min'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'comments'</span>: &#123;</span><br><span class="line">      deps: [</span><br><span class="line">        <span class="string">'css!https://unpkg.com/gitalk/dist/gitalk'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">require</span>([<span class="string">'backgroudLine'</span>,<span class="string">'music'</span>,<span class="string">'aplayer'</span>,<span class="string">'category'</span>,<span class="string">'jquery.share.min'</span>,<span class="string">'share'</span>,<span class="string">'css'</span>,<span class="string">'comments'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>如果没有用require的直接在_layout.swig<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://imsun.github.io/gitment/style/default.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://imsun.github.io/gitment/dist/gitment.browser.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">//再引入comments_git.js</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"xxxxxxxxxx/comments_git.js"</span>&gt;</span><span class="undefined"></span></span><br></pre></td></tr></table></figure><p></p><h1 id="pjax加入gitalk"><a href="#pjax加入gitalk" class="headerlink" title="pjax加入gitalk"></a>pjax加入gitalk</h1><p>同样重新调用comments_git.js即可</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="所有的页面共享的一个评论issue"><a href="#所有的页面共享的一个评论issue" class="headerlink" title="所有的页面共享的一个评论issue"></a>所有的页面共享的一个评论issue</h2><p>这个好像到现在的版本，人家已经优化的很好了。<br>注意上年的comments_git.js<br>中的配置id 改为location.pathname，即<br></p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">id:</span><span class="string"> location.pathname</span></span><br></pre></td></tr></table></figure><p></p><p>意思是，根据目录创建不同的iss</p><h2 id="本地4000启动报错401-没有权限"><a href="#本地4000启动报错401-没有权限" class="headerlink" title="本地4000启动报错401 没有权限"></a>本地4000启动报错401 没有权限</h2><p>push到远端就没问题了。</p><h2 id="未找到相关的Issues-进行评论，请联系xxx初始化创建"><a href="#未找到相关的Issues-进行评论，请联系xxx初始化创建" class="headerlink" title="未找到相关的Issues 进行评论，请联系xxx初始化创建"></a>未找到相关的Issues 进行评论，请联系xxx初始化创建</h2><p>这个issue每次需要管理员，即作者你创建，怎么创建呢？在你自己的博客进入评论，登录自己的github账号，访问没有创建issues的博客，就初始化了。<br>这样岂不是很麻烦？<br>解决博客：<a href="https://link.jianshu.com/?t=https%3A%2F%2Fdraveness.me%2Fgit-comments-initialize" target="_blank" rel="noopener">https://link.jianshu.com/?t=https%3A%2F%2Fdraveness.me%2Fgit-comments-initialize</a><br>这个方法，我试过，没有成功，时间有限，就不深追了~<br>tips：里面的sitmap地图，如果是next地图在网址:https://你的博客地址/sitemap.xml<br>以后有时间或者能力允许的话，可能会写一个类似爬虫的脚本，完成这一操作~</p><h3 id="发现自己的留言板明明评论了却不显示"><a href="#发现自己的留言板明明评论了却不显示" class="headerlink" title="发现自己的留言板明明评论了却不显示"></a>发现自己的留言板明明评论了却不显示</h3><p>原因：自己加入了pjax导致<br>手动刷新的地址是：<a href="https://mmmmmm.me/message/">https://mmmmmm.me/message/</a><br>pjax刷新的地址是：<a href="https://mmmmmm.me/message">https://mmmmmm.me/message</a><br>因为gitalk创建issues是根据地址来创建的，所以不同的地址当然issues是不一样的啊。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景
      
    
    </summary>
    
      <category term="hexo" scheme="http://mmmmmm.me/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://mmmmmm.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo next主题深度优化(四)，自定义一个share功能，share.js</title>
    <link href="http://mmmmmm.me/hexo_si_share.html"/>
    <id>http://mmmmmm.me/hexo_si_share.html</id>
    <published>2018-12-18T12:18:00.000Z</published>
    <updated>2019-08-14T11:30:09.537Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h1><p>之前一直用的addthis或者百度分享，可是加入pjax后失效，相应的接口重写也不行，故自己重新加一个分享的功能。</p><h1 id="开始："><a href="#开始：" class="headerlink" title="开始："></a>开始：</h1><h2 id="引入资源："><a href="#引入资源：" class="headerlink" title="引入资源："></a>引入资源：</h2><p><img alt="upload successful" data-original="../images/my_blog_20.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $config = &#123;</span><br><span class="line">  sites : [<span class="string">'weibo'</span>,<span class="string">'qq'</span>, <span class="string">'wechat'</span>,<span class="string">'tencent'</span>,<span class="string">'qzone'</span>,<span class="string">'douban'</span>, <span class="string">'facebook'</span>,  <span class="string">'google'</span>,<span class="string">'twitter'</span>],</span><br><span class="line">  disabled: [ <span class="string">'linkedin'</span>, <span class="string">'diandian'</span>],</span><br><span class="line">  wechatQrcodeTitle: <span class="string">"微信扫一扫"</span>,</span><br><span class="line">  wechatQrcodeHelper: <span class="string">'&lt;p&gt;微信扫一扫，右上角分享&lt;/p&gt;'</span>,</span><br><span class="line">  source: <span class="string">'Leesin Dong'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$(<span class="string">'.post-spread'</span>).share($config);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pjaxshare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  $(<span class="string">'.post-spread'</span>).share($config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键的一步"><a href="#关键的一步" class="headerlink" title="关键的一步"></a>关键的一步</h2><p>很多时候出现：</p><p><img alt="upload successful" data-original="../images/my_blog_21.png"><br>这是什么鬼？<br>下载网上的demo发现了问题。缺少雪碧图把？（猜想）<br>通过对比，需要引入demo中的fonts目录。</p><p><img alt="upload successful" data-original="../images/my_blog_22.png"></p><h2 id="附：方便学习的小demo"><a href="#附：方便学习的小demo" class="headerlink" title="附：方便学习的小demo"></a>附：方便学习的小demo</h2><p><a href="https://github.com/overtrue/share.js/zipball/master" target="_blank" rel="noopener">https://github.com/overtrue/share.js/zipball/master</a></p><h2 id="一次成功后还出现上面的bug"><a href="#一次成功后还出现上面的bug" class="headerlink" title="一次成功后还出现上面的bug"></a>一次成功后还出现上面的bug</h2><p>将fonts目录删掉，重新导入</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><h1 id="2018-12-23发现bug（读者可忽略）"><a href="#2018-12-23发现bug（读者可忽略）" class="headerlink" title="2018.12.23发现bug（读者可忽略）"></a>2018.12.23发现bug（读者可忽略）</h1><p>里面的图标变成了灰色，因为在护眼的js中对a标签的颜色进行了重新定义，加a:not()</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景
      
    
    </summary>
    
      <category term="hexo" scheme="http://mmmmmm.me/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://mmmmmm.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo next主题深度优化(三)，引入require.js,适配pjax</title>
    <link href="http://mmmmmm.me/hexo_san_require.html"/>
    <id>http://mmmmmm.me/hexo_san_require.html</id>
    <published>2018-12-18T12:16:00.000Z</published>
    <updated>2019-08-14T11:30:09.516Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><h1 id="require-js的好处，"><a href="#require-js的好处，" class="headerlink" title="require.js的好处，"></a>require.js的好处，</h1><p>总结一下就是：</p><ol><li>减少js文件之间的依赖关系</li><li>能够在页面呈现出来之后再加载js css等，提升系统性能</li><li>异步，跟第二步一个意思<h1 id="hexo-next中加入require-js"><a href="#hexo-next中加入require-js" class="headerlink" title="hexo next中加入require.js"></a>hexo next中加入require.js</h1><h2 id="新建一个main-js作为所有js的入口"><a href="#新建一个main-js作为所有js的入口" class="headerlink" title="新建一个main.js作为所有js的入口"></a>新建一个main.js作为所有js的入口</h2>这个我是用来加载首页的js的，因为加入了pjax<br>下面会弄pjax<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="selector-tag">require</span><span class="selector-class">.config</span>(&#123;</span><br><span class="line">  <span class="attribute">paths</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">"music"</span>: <span class="string">"/dist/music"</span>,</span><br><span class="line">    <span class="string">"aplayer"</span>: <span class="string">"/js/src/aplayer"</span>,</span><br><span class="line">    <span class="string">"backgroudLine"</span>: <span class="string">"/js/src/backgroudLine"</span>,</span><br><span class="line">    <span class="string">"category"</span>: <span class="string">"/js/src/category"</span>,</span><br><span class="line">    <span class="string">"jquery.share.min"</span>:<span class="string">"/js/src/pjax/share/jquery.share.min"</span>,</span><br><span class="line">    <span class="string">"share"</span>:<span class="string">"/js/src/pjax/share"</span>,</span><br><span class="line">    <span class="string">"css"</span>:<span class="string">"/js/src/pjax/css"</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="comment">//为了动态的增加css，require js中并没有这个功能，github上有相关的插件和文档，自行google</span></span><br><span class="line">  <span class="attribute">shim</span>: &#123;</span><br><span class="line">    <span class="string">'share'</span>: &#123;</span><br><span class="line">      <span class="attribute">deps</span>: [</span><br><span class="line">        <span class="string">'css!/js/src/pjax/share/share.min'</span>,<span class="string">'jquery.share.min'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="selector-tag">require</span>([<span class="string">'backgroudLine'</span>,<span class="string">'music'</span>,<span class="string">'aplayer'</span>,<span class="string">'category'</span>,<span class="string">'jquery.share.min'</span>,<span class="string">'share'</span>,<span class="string">'css'</span>], function ()&#123;</span><br><span class="line"> <span class="selector-tag">pjaxshare</span>()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>_layout.swig<br></p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;#<span class="name">require</span>主函数#&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/src/pjax/require.js"</span> <span class="attr">defer</span> <span class="attr">async</span>=<span class="string">"true"</span> <span class="attr">data-main</span>=<span class="string">"/js/src/pjax/main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p></p><p>网上说必须在相应的js文件中用define包住类似于<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">原来的js</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>可是我发现并不用呀</p><h2 id="pjax的require-js实现"><a href="#pjax的require-js实现" class="headerlink" title="pjax的require.js实现"></a>pjax的require.js实现</h2><p>_layout.swig<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/src/pjax/jquer_min_js.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/src/pjax/jquery_pjax_min_js.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/src/pjax/pjaxMain.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>pjaxmain.js<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).pjax(<span class="string">'a[target!=_blank]'</span>, <span class="string">'#pjax-container'</span>, &#123;</span><br><span class="line">  fragment: <span class="string">'#pjax-container'</span>,</span><br><span class="line">  timeout: <span class="number">5000</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//用户通过浏览器的前进后退按钮，需要加载的js</span></span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'popstate.pjax'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*原来不行后来加到complete中行了，后来又不行了*/</span></span><br><span class="line">    pjax();</span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'pjax:start'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;)</span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'pjax:complete'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>.config(&#123;</span><br><span class="line">      paths: &#123;</span><br><span class="line">        <span class="comment">// "category_js": "/js/src/pjax/category_js",</span></span><br><span class="line">        <span class="comment">// "opacity_js":"/js/src/pjax/opacity_js",</span></span><br><span class="line">        <span class="comment">// "motion_js":"/js/src/pjax/motion_js",</span></span><br><span class="line">        <span class="comment">// "scrollspy_js":"/js/src/pjax/scrollspy_js",</span></span><br><span class="line">        <span class="comment">// "post-details_js":"/js/src/pjax/post-details_js",</span></span><br><span class="line">        <span class="comment">// "lean_analytics":"/js/src/pjax/lean_analytics",</span></span><br><span class="line">        <span class="comment">// "baidutuisong":"/js/src/pjax/baidutuisong",</span></span><br><span class="line">        <span class="comment">// "utils_js":"/js/src/pjax/utils_js",</span></span><br><span class="line">        <span class="comment">//这个是单独的</span></span><br><span class="line">        <span class="string">"jquery.share.min"</span>:<span class="string">"/js/src/pjax/share/jquery.share.min"</span>,</span><br><span class="line">        <span class="comment">// "share":"/js/src/pjax/share",</span></span><br><span class="line">        <span class="comment">//这个也是单独的</span></span><br><span class="line">        <span class="string">"css"</span>:<span class="string">"/js/src/pjax/css"</span>,</span><br><span class="line">        <span class="string">"pjax_function_public"</span>:<span class="string">"/js/src/pjax/pjax_function_public"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      shim: &#123;</span><br><span class="line">        <span class="string">'share'</span>: &#123;</span><br><span class="line">          deps: [</span><br><span class="line">            <span class="string">'css!/js/src/pjax/share/share.min'</span>,<span class="string">'jquery.share.min'</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">require</span>([<span class="string">'jquery.share.min'</span>,<span class="string">'share'</span>,<span class="string">'css'</span>,<span class="string">'pjax_function_public'</span></span><br><span class="line">    ], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      pjax();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*因为下面的postdetails_js中的有个判断空指针的，如果加上就不能左移，如果去掉会报错，所以把这个放在首行来执行。*/</span></span><br><span class="line">  <span class="comment">/*现在已经解决,可以放在任意的位置*/</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      之前一直是好的突然有次就不好了，后来解决了右边sidebar滚轮效果消失的效果之后，突然又好了。</span></span><br><span class="line"><span class="comment">      原因是因为，之前放在detail js的下面，而detail的下面undfind的判断时报错的，所以不会往下走。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">/*判断#lv-container是否为空，目前这是我找到最好的办法，因为不判断，进入首页或其他的页面会空指针异常。*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ($(<span class="string">"#lv-container"</span>).length &gt; <span class="number">0</span> &amp;&amp;$(<span class="string">'comments'</span>).length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    $(<span class="string">".comments"</span>).css(&#123;<span class="attr">opacity</span>: <span class="number">1</span>&#125;);</span><br><span class="line">    $.getScript(<span class="string">"https://cdn-city.livere.com/js/embed.dist.js"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不蒜子js</span></span><br><span class="line">  $.getScript(<span class="string">"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自己写的分享</span></span><br><span class="line">  pjaxshare();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类的js</span></span><br><span class="line">  category_js();</span><br><span class="line"><span class="comment">// 局部刷新后文章内容不显示bug的js</span></span><br><span class="line">  opacity_js()</span><br><span class="line"><span class="comment">//点击有目录的文章sidebar不显示的bug解决</span></span><br><span class="line">  motion_js()</span><br><span class="line">  scrollspy_js()</span><br><span class="line">  <span class="comment">//utils_js()</span></span><br><span class="line">  postdetails_js()</span><br><span class="line"><span class="comment">//lean数量统计的js，原来的js是在themes/next/layout/_third-party/analytics/lean-analytics.swig文件中</span></span><br><span class="line">  lean_analytics();</span><br><span class="line">  <span class="comment">//百度推送js</span></span><br><span class="line">  baidutuisong();</span><br><span class="line"><span class="comment">//     //右边sidebar滚轮效果消失了。</span></span><br><span class="line">  initSidebarDimension()</span><br><span class="line">  <span class="comment">//懒加载</span></span><br><span class="line">  lazyLoad();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="关于require-js适配过程中报的错误"><a href="#关于require-js适配过程中报的错误" class="headerlink" title="关于require js适配过程中报的错误"></a>关于require js适配过程中报的错误</h1><h2 id="aplayer-min-js只能在——lauout加载"><a href="#aplayer-min-js只能在——lauout加载" class="headerlink" title="aplayer.min.js只能在——lauout加载"></a>aplayer.min.js只能在——lauout加载</h2><p>这个只能通过这里加载，因为RequireJS 介绍说一个JS文件里只能放一个Define，这个众所周知，不提</p><h2 id="一直报错：MISMATCHED-ANONYMOUS-DEFINE-MODULES-…"><a href="#一直报错：MISMATCHED-ANONYMOUS-DEFINE-MODULES-…" class="headerlink" title="一直报错：MISMATCHED ANONYMOUS DEFINE() MODULES …"></a>一直报错：MISMATCHED ANONYMOUS DEFINE() MODULES …</h2><p>解决：<a href="https://blog.csdn.net/u011558902/article/details/53691627" target="_blank" rel="noopener">https://blog.csdn.net/u011558902/article/details/53691627</a></p><p>pjaxrequire 解决<br>require（[xxxxxxx]fuction（）{<br>pjax<br>}）</p><h2 id="在博客中加requre-js时候，关于aplayer的插件需要。"><a href="#在博客中加requre-js时候，关于aplayer的插件需要。" class="headerlink" title="在博客中加requre.js时候，关于aplayer的插件需要。"></a>在博客中加requre.js时候，关于aplayer的插件需要。</h2><p>define aplayer 可是里面还有一个define定义APlayer函数（重点记录 RequireJS 介绍说一个JS文件里只能放一个Define，这个众所周知，不提。）<br>解决方法：因为RequireJS 介绍说一个JS文件里只能放一个Define，这个众所周知，不提。，只能将这个插件不通过require来进行加载。让系统上来就加载。</p><h2 id="如图"><a href="#如图" class="headerlink" title="如图"></a>如图</h2><p><img alt="upload successful" data-original="../images/my_blog_12.png"><br>这是因为我的apler 的js在requer和——layout中都进行了定义</p><h2 id="velocity函数报错"><a href="#velocity函数报错" class="headerlink" title="velocity函数报错"></a>velocity函数报错</h2><p><img alt="upload successful" data-original="../images/my_blog_13.png"><br>解决：jquery从require中去掉，原因不详，好像有什么循环依赖。<br>解决：jquery从require中去掉，原因不详，好像有什么循环依赖。</p><h2 id="针对pjax的require，我用这个requre主要就是来安排pjax的，因为要之前吧pjax的函数在家在一边，浪费很大的加载时间"><a href="#针对pjax的require，我用这个requre主要就是来安排pjax的，因为要之前吧pjax的函数在家在一边，浪费很大的加载时间" class="headerlink" title="针对pjax的require，我用这个requre主要就是来安排pjax的，因为要之前吧pjax的函数在家在一边，浪费很大的加载时间"></a>针对pjax的require，我用这个requre主要就是来安排pjax的，因为要之前吧pjax的函数在家在一边，浪费很大的加载时间</h2><p>发现：<br>我很多模块并没有用define进行定定义,但是仍然成功了，说明并不是一定要define定义才能用的。（我通过实际经验总结的，结论不一定正确，有不对的地方还请指出）<br>解决：<br><img alt="upload successful" data-original="../images/my_blog_14.png"><br><img alt="upload successful" data-original="../images/my_blog_15.png"></p><p>在pjaxmin里面写require的东西，可以发现我并没有在——类中写</p><p>并没有按照require的方式引入pjaxmain这个函数，但还是成功了，<br>说明，项目中只需要引入一次require这个js，便可以处处使用（目前根据我的实际操作得出的结论，不一定正确。）</p><p>这样的话，每次pjax 的complite的函数执行完了之后才会加载需要的函数，也就是在首页，或者其他的页面，是不需要加载这个些个文件的，在首页的首次加载中大大节省了时间完美！！！！！</p><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p><img alt="upload successful" data-original="../images/my_blog_16.png"></p><p>官方解释</p><p><img alt="upload successful" data-original="../images/my_blog_17.png"><br>这里的脚本错误并不是我们引入的js脚本错误，而是对编写的config require函数的脚本错误，<br>比如我就是路径不会的</p><h2 id="pajx-返回失效"><a href="#pajx-返回失效" class="headerlink" title="pajx 返回失效"></a>pajx 返回失效</h2><p>$(window).on(‘popstate.pjax’, function () {<br>$(‘img’).lazyload({<br>placeholder: ‘../images/loading.gif’,<br>effect: ‘fadeIn’,<br>threshold : 100,<br>failure_limit : 20,<br>skip_invisible : false<br>});</p><pre><code>pjax();</code></pre><p>})<br>和complite同样的代码，通过打断点，发现我的if（xxx&gt;0）{}并没有执行，说明是在页面加载完之前就开始执行这段代码了，<br>解决：<br>$(window).on(‘popstate.pjax’, function () {<br>$(document).on(‘pjax:complete’,<br>function () {<br>//<br>$(‘img’).lazyload({<br>placeholder: ‘../images/loading.gif’,<br>effect: ‘fadeIn’,<br>threshold : 100,<br>failure_limit : 20,<br>skip_invisible : false<br>});</p><pre><code>  pjax();})</code></pre><p>})</p><p>在之前加入，<br>$(document).on(‘pjax:complete’,）<br>意思是在pjax请求加载完了之后再进行如下的代码。</p><h2 id="pjaxshare函数（分享函数）老师报错pajaxshare（）-not-defined"><a href="#pjaxshare函数（分享函数）老师报错pajaxshare（）-not-defined" class="headerlink" title="pjaxshare函数（分享函数）老师报错pajaxshare（） not defined"></a>pjaxshare函数（分享函数）老师报错pajaxshare（） not defined</h2><p>解决：想着在pjaxshare函数上面加define（function（）{}）,按照网上的教程是这样的，可是我加上就是不行，去掉反而行了。</p><h2 id="require-css"><a href="#require-css" class="headerlink" title="require css"></a>require css</h2><p>从github上下载<br>deps:[‘css!libs/css/color.min’] 这里会优先加在css这个模块名下的文件(libs/js/css.min.js) 然后一个 “!”后面紧接着在基目录下加在libs/css/color.min.css<br>所以css.js文件下载下拉是不能改名的</p><p><img alt="upload successful" data-original="../images/my_blog_19.png"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;require-js的好处，&quot;&gt;&lt;a href=&quot;#require-js的好处，&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="hexo" scheme="http://mmmmmm.me/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://mmmmmm.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo next主题深度优化(二)，懒加载</title>
    <link href="http://mmmmmm.me/hexo_er_lazy.html"/>
    <id>http://mmmmmm.me/hexo_er_lazy.html</id>
    <published>2018-12-18T12:15:00.000Z</published>
    <updated>2019-08-14T11:30:09.550Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><h1 id="tip：没有耐心的可以直接看：正式在hexo-next中加入懒加载（最下面）"><a href="#tip：没有耐心的可以直接看：正式在hexo-next中加入懒加载（最下面）" class="headerlink" title="tip：没有耐心的可以直接看：正式在hexo next中加入懒加载（最下面）"></a>tip：没有耐心的可以直接看：正式在hexo next中加入懒加载（最下面）</h1><h1 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h1><p>本来想全部优化完，一起写博客的，大半夜的也不想太累，可是可能因为年纪大了吧（23了），怕隔天给忘记了，到时候回头找错误岂不是浪费更多的时间，索性，今天拖着疲惫的大脑，写下这篇博文吧~</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本人的博客mmmmmm.me （目前可能还是问题很多的，不介意的可以稍微看一下） pjax基本优化完了，目前我涉及到的，现在想优化一下网站的加载速度，因为我的网站刚进去的时候白屏大半天，然后浏览器的转盘转半天，（就是刷新那个标识了，不会表达），之后就是一堆查看通过浏览器的审查模式看network，发现首页的大图片占了很久的响应时间，之后发现我的hexo后台管理工具，hexo-admin（一个很方便的博客发布工具，有兴趣的看我另一篇博客，网上一搜一大堆），每次直接复制粘贴进去，它默认保存的是png格式的，关于jpg和png的区别，希望大家也了解一下，使得我的图片好几兆，我就手动复制成jpg格式的，但是还是不行的呀，这个时候，就上网查各种优化，发现，有个懒加载这个东东，客观往下看。</p><h1 id="懒加载简单介绍"><a href="#懒加载简单介绍" class="headerlink" title="懒加载简单介绍"></a>懒加载简单介绍</h1><blockquote><p>何为懒加载，简言之就是在html加载的时候，若果img标签的src是有内容的，在加载的过程中，img标签就回去请求这个图片，知道加载完，我们的浏览器的刷新那个图标才会停止转动，也就是才算请求玩，这个时候懒加载就应运而生。懒加载能够在你鼠标不懂得时候只加载目前电脑窗口内需要展示的图片，电脑屏幕内部需要展示的图片就暂时不加载，对于图片比较多的网站是不是很实用呢？</p></blockquote><p>关于懒加载的语法简单介绍一下：</p><h2 id="引入js"><a href="#引入js" class="headerlink" title="引入js"></a>引入js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"jquery.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">   &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"jquery.lazyload.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="重点！敲黑板了！！！"><a href="#重点！敲黑板了！！！" class="headerlink" title="重点！敲黑板了！！！"></a>重点！敲黑板了！！！</h2><p>修改图片属性（增加data-original属性，去掉src属性）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img alt=<span class="string">""</span> width=<span class="string">"640"</span> height=<span class="string">"480"</span> data-original=<span class="string">"img/example.jpg"</span> /&gt;</span><br></pre></td></tr></table></figure><h2 id="完善懒加载函数"><a href="#完善懒加载函数" class="headerlink" title="完善懒加载函数"></a>完善懒加载函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script&gt;</span><br><span class="line">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">"img"</span>).lazyload();</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;script&gt;</span><br><span class="line"><span class="string">``</span><span class="string">`   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 懒加载函数可配置的参数</span></span><br><span class="line"><span class="string">备注：这里必须设置图片的width和height,否则插件可能无法正常工作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　上面是最简单的调用，但是一般而言，我们还有一些特殊的需求，比如想要提前一点点加载，避免网络过慢时加载缓慢，加载隐藏图片等等，lazyload都为我们提供相应的参数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　1.设置临界点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　　　默认情况下图片会出现在屏幕时加载. 如果你想提前加载图片, 可以设置threshold 选项, 如：设置 threshold 为 200 令图片在距离屏幕 200 像素时提前加载.</span></span><br><span class="line"><span class="string">　　　　</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    $("img").lazyload(&#123;</span></span><br><span class="line"><span class="string">        threshold : 200</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　2.使用特效</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　　　默认情况下，图像完全加载并调用show()。你可以使用任何你想要的效果。下面的代码使用fadeIn （淡入效果）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">    $(<span class="string">"img"</span>).lazyload(&#123;</span><br><span class="line">        effect : <span class="string">"fadeIn"</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>3.当图片不连续时</p><p>滚动页面的时候, Lazy Load 会循环为加载的图片. 在循环中检测图片是否在可视区域内. 默认情况下在找到第一张不在可见区域的图片时停止循环. 图片被认为是流式分布的, 图片在页面中的次序和 HTML 代码中次序相同. 但是在一些布局中, 这样的假设是不成立的. 不过你可以通过 failurelimit 选项来控制加载行为.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"img"</span>).lazyload(&#123;</span><br><span class="line">    failure_limit : <span class="number">20</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将 failurelimit 设为 20 ，当插件找到 20 个不在可见区域的图片时停止搜索.</p><p>4.加载隐藏图片</p><p>当界面有很多隐藏图片的时候并希望加载他们的时候则使用kip_invisible 属性，将其设置为false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"img"</span>).lazyload(&#123; </span><br><span class="line">     skip_invisible : <span class="literal">false</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>到这里，上面的方法已经基本满足常规的懒加载使用了，还有特殊的使用，可查看官网API。</p><h1 id="正式在hexo-next中加入懒加载"><a href="#正式在hexo-next中加入懒加载" class="headerlink" title="正式在hexo next中加入懒加载"></a>正式在hexo next中加入懒加载</h1><p>之前尝试过很多方法：</p><h2 id="1："><a href="#1：" class="headerlink" title="1："></a>1：</h2><p>如上查看相关的懒加载api文档，自定义懒加载函数，但是忽略了，img中需要data-original，并且去掉src属性，之后发现然后弥补，想要通过js的方式动态的给我的img加入这个属性，然后去掉src属性，但是js加入的前提是加载完dom模型，加载完dom模型的前提是src中的内容已经加载了，所以是不行的，故尝试修改html，next主题中没有html事swig文件，img中的内容是通过js渲染出来的。故放弃。</p><h2 id="2："><a href="#2：" class="headerlink" title="2："></a>2：</h2><p>上谷歌查看，发现可以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-lazyload --save</span><br></pre></td></tr></table></figure><p>然后修改_config.yml文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazyload:</span><br><span class="line">     enable: <span class="literal">true</span></span><br><span class="line">     # className: #可选 e.g. .J-lazyload-img</span><br><span class="line">     # loadingImg: #可选 eg. .../images/loading.png</span><br></pre></td></tr></table></figure><p>可是我发现貌似是不行的，反正报各种错，网上好像是有人成功的。这个方法待定，附上原博客地址，感兴趣的可以研究。<br><a href="http://www.zhaojun.im/hexo-lazyload/" target="_blank" rel="noopener">http://www.zhaojun.im/hexo-lazyload/</a></p><h2 id="3：按我的步骤来，不要问为什么。"><a href="#3：按我的步骤来，不要问为什么。" class="headerlink" title="3：按我的步骤来，不要问为什么。"></a>3：按我的步骤来，不要问为什么。</h2><p>我自己成功的方法：<br>在主题文件夹下的scripts文件夹里，写一个 js 文件，名字不限，xxxx.js,比如wohaoshuai.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use strict<span class="string">';</span></span><br><span class="line"><span class="string">var cheerio = require('</span>cheerio<span class="string">'); </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">function lazyloadImg(source) &#123;</span></span><br><span class="line"><span class="string">    var LZ= cheerio.load(source, &#123;</span></span><br><span class="line"><span class="string">        decodeEntities: false</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    //遍历所有 img 标签，添加data-original属性</span></span><br><span class="line"><span class="string">    LZ('</span>img<span class="string">').each(function(index, element) &#123;</span></span><br><span class="line"><span class="string">        var oldsrc = LZ(element).attr('</span>src<span class="string">');</span></span><br><span class="line"><span class="string">        if (oldsrc) &#123;</span></span><br><span class="line"><span class="string">            LZ(element).removeAttr('</span>src<span class="string">');</span></span><br><span class="line"><span class="string">            LZ(element).attr(&#123;</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">                 '</span>data-original<span class="string">': oldsrc</span></span><br><span class="line"><span class="string">            &#125;);</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    return LZ.html();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//在渲染之前，更改 img 标签</span></span><br><span class="line"><span class="string">hexo.extend.filter.register('</span>after_render:html<span class="string">', lazyloadImg);</span></span><br></pre></td></tr></table></figure><p>然后网上是说在header或者footer中引入js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://libs.baidu.com/jquery/1.11.1/jquery.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"> <span class="comment">//也可替换其他的lazyload源</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://apps.bdimg.com/libs/jquery-lazyload/1.9.5/jquery.lazyload.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">      $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">      <span class="comment">//对所有 img 标签进行懒加载        </span></span><br><span class="line">          $(<span class="string">"img"</span>).lazyload(&#123;</span><br><span class="line">          <span class="comment">//设置占位图，我这里选用了一个 loading 的加载动画</span></span><br><span class="line">            placeholder:<span class="string">"/img/loading.gif"</span>,</span><br><span class="line">            <span class="comment">//加载效果</span></span><br><span class="line">              effect:<span class="string">"fadeIn"</span></span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>但是我发现hexo next主题中有个themes/next/source/js/src/utils.js文件。<br>找到这个方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lazyLoadPostsImages: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// $('#posts').find('img').lazyload(&#123;</span></span><br><span class="line">      <span class="comment">//   placeholder: '../images/loading.gif',</span></span><br><span class="line">      <span class="comment">//   effect: 'fadeIn',</span></span><br><span class="line">      <span class="comment">//   threshold : 0</span></span><br><span class="line">      <span class="comment">// &#125;);</span></span><br><span class="line">      $(<span class="string">'img'</span>).lazyload(&#123;</span><br><span class="line">         placeholder: <span class="string">'../images/loading.gif'</span>,</span><br><span class="line">        effect: <span class="string">'fadeIn'</span>,</span><br><span class="line">        threshold : <span class="number">100</span>,</span><br><span class="line">        failure_limit : <span class="number">20</span>,</span><br><span class="line">        skip_invisible : <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>修改内容即可，之前是注释掉的内容，意思是只对article中的内容进行懒加载，可是我需要的是全局的都懒加载，因为上面的scripts中的js已经将全局的img都替换了标签内容，不全局懒加载的话会有的不显示，<br>然后就是这两个配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">threshold : <span class="number">100</span>,</span><br><span class="line"> ailure_limit : <span class="number">20</span>,</span><br></pre></td></tr></table></figure><p>意思上面有关懒加载的说的很清楚了，为了解决有的图片可能会不显示。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;tip：没有耐心的可以直接看：正式在hexo-next中加入懒加载（最下面）&quot;&gt;&lt;a href=&quot;#tip：没有耐
      
    
    </summary>
    
      <category term="hexo" scheme="http://mmmmmm.me/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://mmmmmm.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo next主题深度优化(一)，加入pjax功能</title>
    <link href="http://mmmmmm.me/hexo_yi_pjax.html"/>
    <id>http://mmmmmm.me/hexo_yi_pjax.html</id>
    <published>2018-12-18T11:20:00.000Z</published>
    <updated>2019-08-14T11:29:18.886Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --><p>特别声明：<br><strong>看不懂没关系，往下读，因为我写的逻辑可能不是很清晰~<br>本人源码在github上实在不懂的 git clone自己扣一扣，github在博客中有连接<br>本人博客mmmmmm.me</strong></p><h1 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h1><p>我有强迫症，遇到好的东西就想给自己整上去，在这里想忠诚的奉劝大家一句，不要再搭建自己的博客了，这是一个无底洞，就跟打游戏一样，当你到达六十级之后，你发现版本更新了，顶级变成了八十级，而且，目前看来你自己只有三级，只是自己感觉自己是六十级，就像我，这个东西我足足花了一周多，当然也有我经常加班的原因吧，好了不吐槽了~~</p><h1 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h1><h2 id="pjax初体验–instantclick"><a href="#pjax初体验–instantclick" class="headerlink" title="pjax初体验–instantclick"></a>pjax初体验–instantclick</h2><p>首先本人加了一个不蒜子的群，看到有人说instantclick能够实现自己的博客实现不中断的播放（大家都知道博客一刷新，一换页，播放的歌曲插件肯定也会刷新，歌也就断了），看到这里是不是有感觉了~~，这个时候我就开始拼命的往里面加，大概花了两天放弃了，可是无奈中文文档也比较少，而且，bug巨多，最大的原因也是bug巨多，适配起来十分麻烦，比如多说评论系统等等。但是速度确实蛮快的，因为可以1鼠标放到标签上实现预加载2鼠标点下去的瞬间实现预加载，而且可以自己设定预加载的时间。（好像是这么回事，时间太久远了）<br>下面贴出我找到的几个教程，对于bug多这点不介意，喜欢钻研的同学可以看看：<br><a href="https://www.ihewro.com/archives/515/" target="_blank" rel="noopener">https://www.ihewro.com/archives/515/</a><br><a href="https://qqdie.com/archives/instantclick.html" target="_blank" rel="noopener">https://qqdie.com/archives/instantclick.html</a><br><a href="https://www.jianshu.com/p/c306360e4270" target="_blank" rel="noopener">https://www.jianshu.com/p/c306360e4270</a><br><a href="https://www.songhaifeng.com/razt/32.html" target="_blank" rel="noopener">https://www.songhaifeng.com/razt/32.html</a><br>好了就先这么多，google上也有好多，赶紧让我们进入正题吧~</p><h2 id="真正的pjax"><a href="#真正的pjax" class="headerlink" title="真正的pjax"></a>真正的pjax</h2><p>官方介绍：pushState + ajax = pjax 带来最直观的效果是整个网站变成单页应用。这样的效果将会极大的提升用户体验，并且可以减少https的请求的次数和内容。使用github上面的一个开源项目defunkt/jquery-pjax 可以很轻松的帮助我们实现pjax。</p><p>这样可以实现，刷新的时候只加载局部的html和css js 大大加快速度。<br>真诚提醒：如果对前端一点点基础都没有的话，要不就放弃吧。</p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>找到theme-&gt;next-&gt;layout-&gt;_layout.swig文件<br>在开头加入以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/src/pjax/pjaxBase.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>解释一下：前两行是引入jq文件和pjax的js文件，jq文件必须在pjax文件前面引入，第三行是引入我自己的文件，这个文件是我自己diy的目录如图。在第二行下面<script></script>中间加入内容是一样的效果。</p></blockquote><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>还是在这个文件中在底部加入</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;# 在这里依次加载<span class="name">pjax</span>需要的js文件 #&#125;</span><span class="xml">//swig文件中的注释是这样子的</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>   <span class="attr">src</span>=<span class="string">"/js/src/pjax/category_js.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>   <span class="attr">src</span>=<span class="string">"/js/src/pjax/opacity_js.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>   <span class="attr">src</span>=<span class="string">"/js/src/pjax/motion_js.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>   <span class="attr">src</span>=<span class="string">"/js/src/pjax/velocity.ui_js.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>   <span class="attr">src</span>=<span class="string">"/js/src/pjax/velocity_js.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>   <span class="attr">src</span>=<span class="string">"/js/src/pjax/bootstrap_js.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>   <span class="attr">src</span>=<span class="string">"/js/src/pjax/scrollspy_js.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>   <span class="attr">src</span>=<span class="string">"/js/src/pjax/utils_js.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>   <span class="attr">src</span>=<span class="string">"/js/src/pjax/post-details_js.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>注意这里的文件是有顺序的，具体的我会在下文详细讲述。</p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>第二步中的这些文件都是我自己加入的，原因是因为（划重点了！！！）<br><strong>在pjax中是局部刷新的也就是局部加载的，而以上的文件，next主题中本身是没有的，原来的文件名称没有我的_js后缀，在目录next-&gt;source-&gt;js-&gt;src下面，<br>源文件大部分都是$(document).ready()的，这个函数，大家可以上网好好查查，是加载完整个dom结构后进行加载的，当然了和js中的Window.onload是不一样的，后者是在图片等全部加载完之后才会加载js，好了不闲扯了，注意将这些文件复制到我上面的目录下并且重命名例如：/js/src/pjax/bootstrap_js.js然后将所有的文件都把$(document).ready()去掉，然后用function xxx包住，这样就可以外部调用了，我会在下面讲到，很有用哦。</strong></p><blockquote><p>为什么这么麻烦，因为next的js是相互调用的，本人比较懒，实在没有时间阅读全部的源码。</p></blockquote><p>目录：</p><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p><img alt="upload successful" data-original="../images/my_blog_11.png"></p><p>如上面的目录，这些有的是我复制的系统核心的，因为在p我单独还建了一个/js/src/pjax/pjaxBase.js，你可能就懂了第一步了。这个js是pjax的核心，下面贴出源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define(['jquery','jquery_pjax_min_js'],function () &#123;</span></span><br><span class="line">$(<span class="built_in">document</span>).pjax(<span class="string">'a[target!=_blank]'</span>, <span class="string">'#pjax-container'</span>, &#123;</span><br><span class="line">  fragment: <span class="string">'#pjax-container'</span>,</span><br><span class="line">  timeout: <span class="number">5000</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//用户通过浏览器的前进后退按钮，需要加载的js</span></span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'popstate.pjax'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="built_in">document</span>).on(<span class="string">'pjax:complete'</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      $(<span class="string">'img'</span>).lazyload(&#123;</span><br><span class="line">        placeholder: <span class="string">'../images/loading.gif'</span>,</span><br><span class="line">        effect: <span class="string">'fadeIn'</span>,</span><br><span class="line">        threshold : <span class="number">100</span>,</span><br><span class="line">        failure_limit : <span class="number">20</span>,</span><br><span class="line">        skip_invisible : <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line">      pjax();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'pjax:start'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;)</span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'pjax:complete'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>.config(&#123;</span><br><span class="line">      paths: &#123;</span><br><span class="line">      <span class="comment">//下面注释的这几个js是之前的版本，因为给主题加入了require.js提升性能，所以将他们整合到了下面pjax_function_public文件中，效果是一样的。</span></span><br><span class="line">        <span class="comment">// "category_js": "/js/src/pjax/category_js",</span></span><br><span class="line">        <span class="comment">// "opacity_js":"/js/src/pjax/opacity_js",</span></span><br><span class="line">        <span class="comment">// "motion_js":"/js/src/pjax/motion_js",</span></span><br><span class="line">        <span class="comment">// "scrollspy_js":"/js/src/pjax/scrollspy_js",</span></span><br><span class="line">        <span class="comment">// "post-details_js":"/js/src/pjax/post-details_js",</span></span><br><span class="line">        <span class="comment">// "lean_analytics":"/js/src/pjax/lean_analytics",</span></span><br><span class="line">        <span class="comment">// "baidutuisong":"/js/src/pjax/baidutuisong",</span></span><br><span class="line">        <span class="comment">// "utils_js":"/js/src/pjax/utils_js",</span></span><br><span class="line">        <span class="comment">//这个是单独的</span></span><br><span class="line">        <span class="string">"jquery.share.min"</span>:<span class="string">"/js/src/pjax/share/jquery.share.min"</span>,</span><br><span class="line">        <span class="comment">// "share":"/js/src/pjax/share",</span></span><br><span class="line">        <span class="comment">//这个也是单独的</span></span><br><span class="line">        <span class="string">"css"</span>:<span class="string">"/js/src/pjax/css"</span>,</span><br><span class="line">        <span class="comment">//我将上面注释的内容整合到了这个js中，为了更好的提升性能，因为虽然一样的内容，多次读取文件，和读一个文件，效率还是有很大的差距的。</span></span><br><span class="line">        <span class="string">"pjax_function_public"</span>:<span class="string">"/js/src/pjax/pjax_function_public"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      shim: &#123;</span><br><span class="line">        <span class="string">'share'</span>: &#123;</span><br><span class="line">          deps: [</span><br><span class="line">            <span class="string">'css!/js/src/pjax/share/share.min'</span>,<span class="string">'jquery.share.min'</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">require</span>([<span class="string">'jquery.share.min'</span>,<span class="string">'share'</span>,<span class="string">'css'</span>,<span class="string">'pjax_function_public'</span></span><br><span class="line">    ], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'img'</span>).lazyload(&#123;</span><br><span class="line">          placeholder: <span class="string">'../images/loading.gif'</span>,</span><br><span class="line">          effect: <span class="string">'fadeIn'</span>,</span><br><span class="line">          threshold : <span class="number">100</span>,</span><br><span class="line">          failure_limit : <span class="number">20</span>,</span><br><span class="line">          skip_invisible : <span class="literal">false</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      pjax();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*因为下面的postdetails_js中的有个判断空指针的，如果加上就不能左移，如果去掉会报错，所以把这个放在首行来执行。*/</span></span><br><span class="line">  <span class="comment">/*现在已经解决,可以放在任意的位置*/</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      之前一直是好的突然有次就不好了，后来解决了右边sidebar滚轮效果消失的效果之后，突然又好了。</span></span><br><span class="line"><span class="comment">      原因是因为，之前放在detail js的下面，而detail的下面undfind的判断时报错的，所以不会往下走。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">/*判断#lv-container是否为空，目前这是我找到最好的办法，因为不判断，进入首页或其他的页面会空指针异常。*/</span></span><br><span class="line">  <span class="keyword">if</span> ($(<span class="string">"#lv-container"</span>).length &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">    $(<span class="string">".comments"</span>).css(&#123;<span class="attr">opacity</span>: <span class="number">1</span>&#125;);</span><br><span class="line">    $.getScript(<span class="string">"https://cdn-city.livere.com/js/embed.dist.js"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不蒜子js</span></span><br><span class="line">  $.getScript(<span class="string">"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自己写的分享</span></span><br><span class="line">  pjaxshare();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类的js</span></span><br><span class="line">  category_js();</span><br><span class="line"><span class="comment">// 局部刷新后文章内容不显示bug的js</span></span><br><span class="line">  opacity_js()</span><br><span class="line"><span class="comment">//点击有目录的文章sidebar不显示的bug解决</span></span><br><span class="line">  motion_js()</span><br><span class="line">  scrollspy_js()</span><br><span class="line">  <span class="comment">//utils_js()</span></span><br><span class="line">  postdetails_js()</span><br><span class="line"><span class="comment">//lean数量统计的js，原来的js是在themes/next/layout/_third-party/analytics/lean-analytics.swig文件中</span></span><br><span class="line">  lean_analytics();</span><br><span class="line">  <span class="comment">//百度推送js</span></span><br><span class="line">  baidutuisong();</span><br><span class="line"><span class="comment">//     //右边sidebar滚轮效果消失了。</span></span><br><span class="line">  initSidebarDimension()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下：<br>$(document).pjax(‘a[target!=_blank]’ ‘#main’, {<br>fragment: ‘#main’,<br>timeout: 5000,<br>});<br>这个函数是pjax的核心，<br>‘a[target!=_blank]’是你将会点击的标签[target!=_blank]，是当你的标签是blank的时候就是需要点击出现一个新的窗口，比如友链之类的，这个时候就不进行局部加载了，没有类似a标签的可以省略。<br>‘#main’是你将会刷新的地方<br>fragment: ‘#main’,是把那个地方的代码刷新然后放到’#main’中<br>timeout，懂js得都懂就不解释了。</p><p>$(document).on(‘pjax:complete’,<br>function() {}<br>划重点了：这个函数是在局部加载完之后自己需要DIY的js，因为pjax是局部加载我已经强调了很多遍了，这个时候有的js会失效比如说评论功能。<br>这个时候引入我们之前定义好的函数。完成！</p><p>贴几个对我很有帮助的博文和hexo next的博客和一个github，实在不懂得可以扒一扒别人的github源码，有很大的帮助。<br><a href="https://www.ihewro.com/archives/354/comment-page-3#comments" target="_blank" rel="noopener">https://www.ihewro.com/archives/354/comment-page-3#comments</a><br><a href="https://www.jimoe.cn/archives/typecho-add-pjax.html" target="_blank" rel="noopener">https://www.jimoe.cn/archives/typecho-add-pjax.html</a><br><a href="http://yelog.org/2017/02/08/pjax/" target="_blank" rel="noopener">http://yelog.org/2017/02/08/pjax/</a><br><a href="https://www.jianshu.com/p/808a647dc324" target="_blank" rel="noopener">https://www.jianshu.com/p/808a647dc324</a><br><a href="https://blog.dyboy.cn/" target="_blank" rel="noopener">https://blog.dyboy.cn/</a><br><a href="https://blog.flysay.com/" target="_blank" rel="noopener">https://blog.flysay.com/</a><br><a href="https://github.com/DIYgod/hexo-theme-sagiri" target="_blank" rel="noopener">https://github.com/DIYgod/hexo-theme-sagiri</a><br><a href="http://www.qingpingshan.com/m/view.php?aid=355579" target="_blank" rel="noopener">http://www.qingpingshan.com/m/view.php?aid=355579</a><br><a href="https://diygod.me/" target="_blank" rel="noopener">https://diygod.me/</a><br>中间有个小技巧:chrom的审查元素里面的内容是可以移动和删除的，更利于我们的检查。</p><h1 id="专门基于hexo-next主题的pjax（将丢失的js效果重现）"><a href="#专门基于hexo-next主题的pjax（将丢失的js效果重现）" class="headerlink" title="专门基于hexo next主题的pjax（将丢失的js效果重现）"></a>专门基于hexo next主题的pjax（将丢失的js效果重现）</h1><h2 id="将下面讲到的提取出来"><a href="#将下面讲到的提取出来" class="headerlink" title="将下面讲到的提取出来"></a>将下面讲到的提取出来</h2><p><strong>因为很多事被包装在$(documnent).ready(function(){})里面的，所以pjax不能加载的原因就在这里。自己提取出来，封装成函数自己调用即可</strong><br><strong>下面的需要前端基础，会通过断点进行审查</strong></p><h2 id="点击右边的sidebar，sidebar不出现"><a href="#点击右边的sidebar，sidebar不出现" class="headerlink" title="点击右边的sidebar，sidebar不出现"></a>点击右边的sidebar，sidebar不出现</h2><p>经过阅读源码，点击事件在motion.js中，将相应的代码提取出来<br>motion.js<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.toggleEl.on(<span class="string">'click'</span>, <span class="keyword">this</span>.clickHandler.bind(<span class="keyword">this</span>));</span><br><span class="line">      <span class="keyword">this</span>.dimmerEl.on(<span class="string">'click'</span>, <span class="keyword">this</span>.clickHandler.bind(<span class="keyword">this</span>));</span><br><span class="line">      <span class="keyword">this</span>.toggleEl.on(<span class="string">'mouseenter'</span>, <span class="keyword">this</span>.mouseEnterHandler.bind(<span class="keyword">this</span>));</span><br><span class="line">      <span class="keyword">this</span>.toggleEl.on(<span class="string">'mouseleave'</span>, <span class="keyword">this</span>.mouseLeaveHandler.bind(<span class="keyword">this</span>));</span><br><span class="line">      <span class="keyword">this</span>.sidebarEl.on(<span class="string">'touchstart'</span>, <span class="keyword">this</span>.touchstartHandler.bind(<span class="keyword">this</span>));</span><br><span class="line">      <span class="keyword">this</span>.sidebarEl.on(<span class="string">'touchend'</span>, <span class="keyword">this</span>.touchendHandler.bind(<span class="keyword">this</span>));</span><br><span class="line">      <span class="keyword">this</span>.sidebarEl.on(<span class="string">'touchmove'</span>, function(e)&#123;e.preventDefault();&#125;);</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p></p><p>post_detail.js<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TOC item animation navigate &amp; prevent #item selector in adress bar.</span></span><br><span class="line">  $(<span class="string">'.post-toc a'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="keyword">var</span> targetSelector = NexT.utils.escapeSelector(<span class="keyword">this</span>.getAttribute(<span class="string">'href'</span>));</span><br><span class="line">    <span class="keyword">var</span> offset = $(targetSelector).offset().top;</span><br><span class="line"></span><br><span class="line">    hasVelocity ?</span><br><span class="line">      html.velocity(<span class="string">'stop'</span>).velocity(<span class="string">'scroll'</span>, &#123;</span><br><span class="line">        offset: offset  + <span class="string">'px'</span>,</span><br><span class="line">        mobileHA: <span class="literal">false</span></span><br><span class="line">      &#125;) :</span><br><span class="line">      $(<span class="string">'html, body'</span>).stop().animate(&#123;</span><br><span class="line">        scrollTop: offset</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p></p><p>这是线索，像java一样点到自己需要的地方，展开逻辑。</p><h3 id="sidebar自动隐藏，自动显示，点击出现，点击隐藏，回到首页，回到中间等操作"><a href="#sidebar自动隐藏，自动显示，点击出现，点击隐藏，回到首页，回到中间等操作" class="headerlink" title="sidebar自动隐藏，自动显示，点击出现，点击隐藏，回到首页，回到中间等操作"></a>sidebar自动隐藏，自动显示，点击出现，点击隐藏，回到首页，回到中间等操作</h3><p>里面如果遇到不认识的函数，可能是hexo自己封装的比如toc，<br>hexo自己的辅助函数：<a href="https://hexo.io/zh-cn/docs/helpers.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/helpers.html</a><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面这段代码是关于右边的sidebar的js的核心包括：</span></span><br><span class="line"><span class="comment">  自动隐藏，自动显示，点击出现，点击隐藏，回到首页，回到中间等操作*/</span></span><br><span class="line">  <span class="comment">// Expand sidebar on post detail page by default, when post has a toc.</span></span><br><span class="line">  var $tocContent = $(<span class="string">'.post-toc-content'</span>);</span><br><span class="line">  var isSidebarCouldDisplay = CONFIG.sidebar.display === <span class="string">'post'</span> ||</span><br><span class="line">      CONFIG.sidebar.display === <span class="string">'always'</span>;</span><br><span class="line">  var hasTOC = $tocContent.length &gt; <span class="number">0</span> &amp;&amp; $tocContent.html().trim().length &gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (isSidebarCouldDisplay &amp;&amp; hasTOC) &#123;</span><br><span class="line"></span><br><span class="line">      NexT.utils.displaySidebar();</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*判断this.sidebarEl是否为null，因为从首页进入留言板的时候并没有this.sidebarEl这个属性，回报类似于空指针的异常。</span></span><br><span class="line"><span class="comment"> 下面这个空指针的判断暂时注释掉因为，如果打开的，返回到首页的时候并没有this.sidebarEl，</span></span><br><span class="line"><span class="comment">下面的代码不会进行，下面的，文章在左面没回去的bug就无法得到解决。*/</span></span><br><span class="line"><span class="comment">/*已经将空指针异常的判断打开，因为下面的源码是this.sidebar，这里的this可能并不是element，所以会导致未定义，其实在element中是定义了的</span></span><br><span class="line"><span class="comment">* 在这里将this去掉就解决了*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 下面这段源码在motion.js中的hideSidebar方法。*/</span></span><br><span class="line">    var sidebarEl=$(<span class="string">'.sidebar'</span>)</span><br><span class="line">    <span class="keyword">if</span> (typeof(sidebarEl)!=  <span class="string">"undefined"</span>) &#123;</span><br><span class="line">      NexT.utils.isDesktop() &amp;&amp; $(<span class="string">'body'</span>).velocity(<span class="string">'stop'</span>).velocity(&#123;paddingRight: <span class="number">0</span>&#125;);</span><br><span class="line">      sidebarEl.find(<span class="string">'.motion-element'</span>).velocity(<span class="string">'stop'</span>).css(<span class="string">'display'</span>, <span class="string">'none'</span>);</span><br><span class="line">      sidebarEl.velocity(<span class="string">'stop'</span>).velocity(&#123;width: <span class="number">0</span>&#125;, &#123;display: <span class="string">'none'</span>&#125;);</span><br><span class="line">      <span class="comment">/*sidebarToggleLines是在motion js里面的，在这里回报错，在下面进行了引用*/</span></span><br><span class="line">      sidebarToggleLines.init();</span><br><span class="line">      sidebarEl.removeClass(<span class="string">'sidebar-active'</span>);</span><br><span class="line">      sidebarEl.trigger(<span class="string">'sidebar.isHiding'</span>);</span><br><span class="line">      <span class="comment">// Prevent adding TOC to Overview if Overview was selected when close &amp; open sidebar.</span></span><br><span class="line">      <span class="comment">/*下面的else的js是我自己加的因为，点击有目录的文章后右侧sidebar会自动出来，文章会自动往左面走，因为margin是0 auto的。这个时候点击主页，</span></span><br><span class="line"><span class="comment">      文章还是在左面的没有回去，为了解决这个bug*/</span></span><br><span class="line">      <span class="keyword">if</span> (!!$(<span class="string">'.post-toc-wrap'</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="string">'.site-overview-wrap'</span>).css(<span class="string">'display'</span>) === <span class="string">'block'</span>) &#123;</span><br><span class="line">          $(<span class="string">'.post-toc-wrap'</span>).removeClass(<span class="string">'motion-element'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          $(<span class="string">'.post-toc-wrap'</span>).addClass(<span class="string">'motion-element'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var sidebarToggleLines = &#123;</span><br><span class="line">  lines: [],</span><br><span class="line">  push: function (line) &#123;</span><br><span class="line">    <span class="keyword">this</span>.lines.push(line);</span><br><span class="line">  &#125;,</span><br><span class="line">  init: function () &#123;</span><br><span class="line">    <span class="keyword">this</span>.lines.forEach(function (line) &#123;</span><br><span class="line">      line.init();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  arrow: function () &#123;</span><br><span class="line">    <span class="keyword">this</span>.lines.forEach(function (line) &#123;</span><br><span class="line">      line.arrow();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  close: function () &#123;</span><br><span class="line">    <span class="keyword">this</span>.lines.forEach(function (line) &#123;</span><br><span class="line">      line.close();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p></p><h3 id="添加bootstrp出现闪屏的现象"><a href="#添加bootstrp出现闪屏的现象" class="headerlink" title="添加bootstrp出现闪屏的现象"></a>添加bootstrp出现闪屏的现象</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">.add</span><span class="params">(NexT.motion.middleWares.menu)</span>已经注释掉了</span><br></pre></td></tr></table></figure><p>貌似bootstrp不加也行,没有发现太需要重写的函数</p><h3 id="右边的sidebar鼠标滚动目录滑动事件没了"><a href="#右边的sidebar鼠标滚动目录滑动事件没了" class="headerlink" title="右边的sidebar鼠标滚动目录滑动事件没了"></a>右边的sidebar鼠标滚动目录滑动事件没了</h3><p>核心代码是utils.js中的initSidebarDimension（）函数<br>直接调用即可。<br>**强烈建议用有道词典看看那些个函数的注释，这个注释就写的很清楚，一开始我找了好久没有跟到相关的代码，最后，偶尔看到了，还好有点英语基础。<br>utils.js<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Init Sidebar &amp; TOC inner dimensions on all pages and for all schemes.</span></span><br><span class="line"><span class="comment">  * Need for Sidebar/TOC inner scrolling if content taller then viewport.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">initSidebarDimension</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> updateSidebarHeightTimer;</span><br><span class="line">   $(<span class="built_in">window</span>).on(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     updateSidebarHeightTimer &amp;&amp; clearTimeout(updateSidebarHeightTimer);</span><br><span class="line">     updateSidebarHeightTimer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> sidebarWrapperHeight = <span class="built_in">document</span>.body.clientHeight - NexT.utils.getSidebarSchemePadding();</span><br><span class="line">      updateSidebarHeight(sidebarWrapperHeight);</span><br><span class="line">     &#125;, <span class="number">0</span>);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p></p><h3 id="局部刷新文章不显示了，文章那里是空白的。"><a href="#局部刷新文章不显示了，文章那里是空白的。" class="headerlink" title="局部刷新文章不显示了，文章那里是空白的。"></a>局部刷新文章不显示了，文章那里是空白的。</h3><p>经过审查，是opacity变成了0，我自定义了一个回调函数。<br>opacity.js<br></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> opacity_js() &#123;</span><br><span class="line">  /<span class="regexp">/ $(".post-block").css(&#123;visibility: 'visible',opacity:1&#125;);</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ $(".post-header").css(&#123;visibility: 'visible',opacity:1&#125;);</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ $(".post-body").css(&#123;visibility: 'visible',opacity:1&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  $(".post-block").css(&#123;opacity:1&#125;);</span></span><br><span class="line"><span class="regexp">  $(".post-header").css(&#123;opacity:1&#125;);</span></span><br><span class="line"><span class="regexp">  $(".post-body").css(&#123;opacity:1&#125;);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p></p><h3 id="评论没了"><a href="#评论没了" class="headerlink" title="评论没了"></a>评论没了</h3><p>我用的是来必力，其他的评论系统都是一样的操作，去评论系统的官网，或者阅读源码，跟到调用的api重新调用即可。<br><strong>注：下面紧跟着这个是之前错误的仅供记录，下面提供了正确的做法</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*判断#lv-container、comments是否为空，目前这是我找到最好的办法，因为不判断，进入首页或其他的页面会空指针异常。*/</span></span><br><span class="line">  <span class="keyword">if</span> ($(<span class="string">"#lv-container"</span>).length &gt; <span class="number">0</span> &amp;&amp;$(<span class="string">'.comments'</span>).length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    $(<span class="string">".comments"</span>).css(&#123;<span class="attr">opacity</span>: <span class="number">1</span>&#125;);</span><br><span class="line">    $.getScript(<span class="string">"https://cdn-city.livere.com/js/embed.dist.js"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>注：上面的版本是之前错误的，经过阅读源码</strong><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($(<span class="string">"#lv-container"</span>).length &gt; <span class="number">0</span> &amp;&amp;$(<span class="string">'.comments'</span>).length&gt;<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p></p><p>这句话是没用的,因为每个页面里面易经理加入了这个,并且js是没有重写完整的<br><strong>正确做法：</strong><br></p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">function</span>(<span class="name">d</span>, s) &#123;</span><br><span class="line">    var j, e = d.getElementsByTagName(<span class="name">s</span>)[<span class="name">0</span>]<span class="comment">;</span></span><br><span class="line">    if (<span class="name">typeof</span> LivereTower === <span class="symbol">'function</span>') &#123; return<span class="comment">; &#125;</span></span><br><span class="line">    j = d.createElement(<span class="name">s</span>)<span class="comment">;</span></span><br><span class="line">    j.src = <span class="symbol">'https://cdn-city.livere.com/js/embed.dist.js</span>'<span class="comment">;</span></span><br><span class="line">    j.async = true<span class="comment">;</span></span><br><span class="line">    e.parentNode.insertBefore(<span class="name">j</span>, e)<span class="comment">;</span></span><br><span class="line">  &#125;)(<span class="name">document</span>, <span class="symbol">'script</span>')<span class="comment">;</span></span><br></pre></td></tr></table></figure><p></p><p>403的错误是localhost的原因，通过域名访问就没事了<br>不报错401就没问题<br>更新，虽然现实没问题，可是每次到首页总是会报错，id notfound，才疏学浅久久不能解决，决定换成gittalk评论。<br>参看我的另一篇文章。</p><h3 id="局部会闪一下"><a href="#局部会闪一下" class="headerlink" title="局部会闪一下"></a>局部会闪一下</h3><p>boostrap.js bootstrap是必须注释掉的</p><h3 id="阅读数没了"><a href="#阅读数没了" class="headerlink" title="阅读数没了"></a>阅读数没了</h3><p>自定义了一个js<br><strong>注意我第一行的注释</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lean_analytics</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*里面的参数原来是&#123;&#123;&#125;&#125;，可能会出现问题，所以在这里我直接将appid和key粘贴过来，具体问题是什么不详*/</span></span><br><span class="line">  AV.initialize(<span class="string">"6og9b7lpddMqazBCDe8z4HqL-gzGzoHsz"</span>, <span class="string">"faKN7dalSdXLmYYJTRq98B1f"</span>);</span><br><span class="line">  $.getScript(<span class="string">"https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showTime</span>(<span class="params">Counter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(Counter);</span><br><span class="line">    <span class="keyword">var</span> entries = [];</span><br><span class="line">    <span class="keyword">var</span> $visitors = $(<span class="string">".leancloud_visitors"</span>);</span><br><span class="line"></span><br><span class="line">    $visitors.each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      entries.push( $(<span class="keyword">this</span>).attr(<span class="string">"id"</span>).trim() );</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    query.containedIn(<span class="string">'url'</span>, entries);</span><br><span class="line">    query.find()</span><br><span class="line">      .done(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> COUNT_CONTAINER_REF = <span class="string">'.leancloud-visitors-count'</span>;</span><br><span class="line">        <span class="keyword">if</span> (results.length === <span class="number">0</span>) &#123;</span><br><span class="line">          $visitors.find(COUNT_CONTAINER_REF).text(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; results.length; i++) &#123;</span><br><span class="line">          <span class="keyword">var</span> item = results[i];</span><br><span class="line">          <span class="keyword">var</span> url = item.get(<span class="string">'url'</span>);</span><br><span class="line">          <span class="keyword">var</span> time = item.get(<span class="string">'time'</span>);</span><br><span class="line">          <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(url);</span><br><span class="line">          $(element).find(COUNT_CONTAINER_REF).text(time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; entries.length; i++) &#123;</span><br><span class="line">          <span class="keyword">var</span> url = entries[i];</span><br><span class="line">          <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(url);</span><br><span class="line">          <span class="keyword">var</span> countSpan = $(element).find(COUNT_CONTAINER_REF);</span><br><span class="line">          <span class="keyword">if</span>( countSpan.text() == <span class="string">''</span>) &#123;</span><br><span class="line">            countSpan.text(<span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .fail(<span class="function"><span class="keyword">function</span> (<span class="params">object, error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Error: "</span> + error.code + <span class="string">" "</span> + error.message);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addCount</span>(<span class="params">Counter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $visitors = $(<span class="string">".leancloud_visitors"</span>);</span><br><span class="line">    <span class="keyword">var</span> url = $visitors.attr(<span class="string">'id'</span>).trim();</span><br><span class="line">    <span class="keyword">var</span> title = $visitors.attr(<span class="string">'data-flag-title'</span>).trim();</span><br><span class="line">    <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(Counter);</span><br><span class="line"></span><br><span class="line">    query.equalTo(<span class="string">"url"</span>, url);</span><br><span class="line">    query.find(&#123;</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (results.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">var</span> counter = results[<span class="number">0</span>];</span><br><span class="line">          counter.fetchWhenSave(<span class="literal">true</span>);</span><br><span class="line">          counter.increment(<span class="string">"time"</span>);</span><br><span class="line">          counter.save(<span class="literal">null</span>, &#123;</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params">counter</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">var</span> $element = $(<span class="built_in">document</span>.getElementById(url));</span><br><span class="line">              $element.find(<span class="string">'.leancloud-visitors-count'</span>).text(counter.get(<span class="string">'time'</span>));</span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span>(<span class="params">counter, error</span>) </span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'Failed to save Visitor num, with error message: '</span> + error.message);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> newcounter = <span class="keyword">new</span> Counter();</span><br><span class="line">          <span class="comment">/* Set ACL */</span></span><br><span class="line">          <span class="keyword">var</span> acl = <span class="keyword">new</span> AV.ACL();</span><br><span class="line">          acl.setPublicReadAccess(<span class="literal">true</span>);</span><br><span class="line">          acl.setPublicWriteAccess(<span class="literal">true</span>);</span><br><span class="line">          newcounter.setACL(acl);</span><br><span class="line">          <span class="comment">/* End Set ACL */</span></span><br><span class="line">          newcounter.set(<span class="string">"title"</span>, title);</span><br><span class="line">          newcounter.set(<span class="string">"url"</span>, url);</span><br><span class="line">          newcounter.set(<span class="string">"time"</span>, <span class="number">1</span>);</span><br><span class="line">          newcounter.save(<span class="literal">null</span>, &#123;</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params">newcounter</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">var</span> $element = $(<span class="built_in">document</span>.getElementById(url));</span><br><span class="line">              $element.find(<span class="string">'.leancloud-visitors-count'</span>).text(newcounter.get(<span class="string">'time'</span>));</span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span>(<span class="params">newcounter, error</span>) </span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'Failed to create'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      error: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Error:'</span> + error.code + <span class="string">" "</span> + error.message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> Counter = AV.Object.extend(<span class="string">"Counter"</span>);</span><br><span class="line">  <span class="keyword">if</span> ($(<span class="string">'.leancloud_visitors'</span>).length == <span class="number">1</span>) &#123;</span><br><span class="line">    addCount(Counter);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($(<span class="string">'.post-title-link'</span>).length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    showTime(Counter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="百度统计-解决了footer自动推送"><a href="#百度统计-解决了footer自动推送" class="headerlink" title="百度统计(解决了footer自动推送)"></a>百度统计(解决了footer自动推送)</h3><p>baidutuisong.js<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baidutuisong</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bp = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">  <span class="keyword">var</span> curProtocol = <span class="built_in">window</span>.location.protocol.split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (curProtocol === <span class="string">'https'</span>) &#123;</span><br><span class="line">    bp.src = <span class="string">'https://zz.bdstatic.com/linksubmit/push.js'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    bp.src = <span class="string">'http://push.zhanzhang.baidu.com/push.js'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>];</span><br><span class="line">  s.parentNode.insertBefore(bp, s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="不蒜子阅读次数失效-解决"><a href="#不蒜子阅读次数失效-解决" class="headerlink" title="不蒜子阅读次数失效(解决)"></a>不蒜子阅读次数失效(解决)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">.getScript(<span class="string">"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>);</span></span><br></pre></td></tr></table></figure><h3 id="分类动态（css样式，js不行）"><a href="#分类动态（css样式，js不行）" class="headerlink" title="分类动态（css样式，js不行）"></a>分类动态（css样式，js不行）</h3><p>category.js<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">category_js</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//在a标签前面加个&gt;</span></span><br><span class="line">  <span class="keyword">if</span> ($(<span class="string">".jiantou"</span>).length==<span class="number">0</span>) &#123;</span><br><span class="line">    $(<span class="string">"&lt;div class='jiantou' style='float: left'&gt; &amp;nbsp&gt;&amp;nbsp &lt;/div&gt;"</span>).prependTo(<span class="string">".category-list-item"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//首相将子元素ul隐藏</span></span><br><span class="line">  $(<span class="string">".category-list-child"</span>).css(<span class="string">"display"</span>,<span class="string">"none"</span>);</span><br><span class="line">  <span class="comment">//改变a标签的样式，"display":"inline-block"同时拥有块元素和行元素的两种特性。</span></span><br><span class="line">  <span class="comment">//放到了css中</span></span><br><span class="line">  <span class="comment">// $(".category-list-link").css(&#123;"width":"1000px","display":"inline-block"&#125;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//加入过滤器功能，因为if貌似不支持this功能，a标签如果有同级元素ul的话会使跳转功能失效，没有同级元素ul的话继续跳转</span></span><br><span class="line">  $(<span class="string">".category-list-link"</span>).filter(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $(<span class="keyword">this</span>).siblings(<span class="string">".category-list-child"</span>).length&gt;<span class="number">0</span></span><br><span class="line">  &#125;).attr(<span class="string">"href"</span>,<span class="string">"javascript:void(0)"</span>).css(&#123;<span class="string">"font-weight"</span>:<span class="string">"bold"</span>&#125;);</span><br><span class="line">  <span class="comment">//点击出现隐藏功能，a标签如果有同级元素ul的话会使跳转功能失效，没有同级元素ul的话继续跳转，上面已经做了处理。</span></span><br><span class="line">  $(<span class="string">".category-list-link"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).siblings(<span class="string">".category-list-child"</span>).slideToggle();</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  $(<span class="string">".posts-expand .post-body ul li "</span>).css(<span class="string">"list-style-type"</span>, <span class="string">"none"</span>);</span><br><span class="line">  <span class="comment">//去掉下划线</span></span><br><span class="line">  $(<span class="string">".category-list-link "</span>).css(<span class="string">"border-bottom"</span>, <span class="string">"none"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="分享失败"><a href="#分享失败" class="headerlink" title="分享失败"></a>分享失败</h3><p>原来用的addthis，不行，又换百度，还是不行，干脆自己整了一个<br>网上有share.js(有兴趣的自己学习一下)<br>share.js<br></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// define([<span class="string">'jquery.share.min'</span>],<span class="function"><span class="keyword">function</span> <span class="params">()</span></span> &#123;</span><br><span class="line">var $<span class="built_in">config</span> = &#123;</span><br><span class="line">  sites : [<span class="string">'weibo'</span>,<span class="string">'qq'</span>, <span class="string">'wechat'</span>,<span class="string">'tencent'</span>,<span class="string">'qzone'</span>,<span class="string">'douban'</span>, <span class="string">'facebook'</span>,  <span class="string">'google'</span>,<span class="string">'twitter'</span>],</span><br><span class="line">  disabled: [ <span class="string">'linkedin'</span>, <span class="string">'diandian'</span>],</span><br><span class="line">  wechatQrcodeTitle: <span class="string">"微信扫一扫"</span>,</span><br><span class="line">  wechatQrcodeHelper: <span class="string">'&lt;p&gt;微信扫一扫，右上角分享&lt;/p&gt;'</span>,</span><br><span class="line">  source: <span class="string">'Leesin Dong'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$(<span class="string">'.post-spread'</span>).share($<span class="built_in">config</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pjaxshare</span><span class="params">()</span></span> &#123;</span><br><span class="line">  $(<span class="string">'.post-spread'</span>).share($<span class="built_in">config</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="评分系统（已经舍弃，感觉无用）"><a href="#评分系统（已经舍弃，感觉无用）" class="headerlink" title="评分系统（已经舍弃，感觉无用）"></a>评分系统（已经舍弃，感觉无用）</h3><h3 id="懒加载函数"><a href="#懒加载函数" class="headerlink" title="懒加载函数"></a>懒加载函数</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'img'</span>).lazyload(&#123;</span><br><span class="line"><span class="symbol">    placeholder:</span> <span class="string">'../images/loading.gif'</span>,</span><br><span class="line"><span class="symbol">    effect:</span> <span class="string">'fadeIn'</span>,</span><br><span class="line">    <span class="string">threshold :</span> <span class="number">100</span>,</span><br><span class="line">    <span class="string">failure_limit :</span> <span class="number">20</span>,</span><br><span class="line">    <span class="string">skip_invisible :</span> <span class="literal">false</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h1 id="忘了最后最重要的一点一点，点击浏览器的返回前进按钮，特效还是失败了"><a href="#忘了最后最重要的一点一点，点击浏览器的返回前进按钮，特效还是失败了" class="headerlink" title="忘了最后最重要的一点一点，点击浏览器的返回前进按钮，特效还是失败了"></a>忘了最后最重要的一点一点，点击浏览器的返回前进按钮，特效还是失败了</h1><p>辛辛苦苦google了三天的结果。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'popstate.pjax'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pjax();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>暂时先这么多吧~<br>喜欢的点个星星，加个关注。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 22 2019 22:26:32 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;特别声明：&lt;br&gt;&lt;strong&gt;看不懂没关系，往下读，因为我写的逻辑可能不是很清晰~&lt;br&gt;本人源码在github上实在不
      
    
    </summary>
    
      <category term="hexo" scheme="http://mmmmmm.me/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://mmmmmm.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>肖申克的救赎</title>
    <link href="http://mmmmmm.me/To_myself.html"/>
    <id>http://mmmmmm.me/To_myself.html</id>
    <published>2018-10-15T06:57:00.000Z</published>
    <updated>2019-08-03T15:15:11.965Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --><blockquote><p>如题</p></blockquote><a id="more"></a><h1 id="肖申克的救赎读后感"><a href="#肖申克的救赎读后感" class="headerlink" title="肖申克的救赎读后感"></a>肖申克的救赎读后感</h1><p>一部值得细细品味的片子。</p><h2 id="面对无法改变的现实，破嘴咆哮、嚎啕大哭和恐惧是丝毫没有作用的，只会让结果更加糟糕。"><a href="#面对无法改变的现实，破嘴咆哮、嚎啕大哭和恐惧是丝毫没有作用的，只会让结果更加糟糕。" class="headerlink" title="面对无法改变的现实，破嘴咆哮、嚎啕大哭和恐惧是丝毫没有作用的，只会让结果更加糟糕。"></a>面对无法改变的现实，破嘴咆哮、嚎啕大哭和恐惧是丝毫没有作用的，只会让结果更加糟糕。</h2><p>入狱的第一天晚上，老鸟捉弄菜鸟”肥臀“，肥臀嚎啕大哭，换来的是监狱所有人的嘲笑和无视，警卫进来，“肥臀”破嘴咆哮，换来的是被活活打死。<br>真正的智者是安迪，一声没坑。</p><p>生活中亦是如此：事已至此，你我都没有错，面对无法改变的现实，只能去接受，想办法解决，而不是咆哮、大哭亦或者恐惧，否则结果会更加的糟糕。</p><h2 id="想要成功，一定要有十足的规划。"><a href="#想要成功，一定要有十足的规划。" class="headerlink" title="想要成功，一定要有十足的规划。"></a>想要成功，一定要有十足的规划。</h2><p>最初，安迪心事重重并不怎么与人交流。直到一个月后，他找到了瑞德，希望他帮自己搞到地质锤。他用一个月的时间来规划，等到时机成熟，才迈出了第一步。</p><p>生活中亦是如此：万事都要规划好，再进行。</p><h2 id="做任何事都要学会隐藏自己最初的想法"><a href="#做任何事都要学会隐藏自己最初的想法" class="headerlink" title="做任何事都要学会隐藏自己最初的想法"></a>做任何事都要学会隐藏自己最初的想法</h2><p>安迪通过买地质锤，并不断的刻石头，让人们取消对他想越狱的顾虑；在一个合适的时机：犯人看美女电影的时候，向瑞德要美女壁画，用来掩盖通道；通过阅读圣经，将地质锤隐藏在自己的圣经中，没错“得救之道，就在其中”；通过帮助典狱长洗黑钱，用邮件向各政府部门申请遗失证件补发，构建了一个根本不存在的人，为他越狱成功之后的身份提供了很好的保障<br>如果安迪每天嚷嚷着“我要越狱了！”，它会成功吗？每次将自己的真实目的隐藏起来，以一个非常普通的、不会让人起疑心的理由，并且在恰当的时机。</p><p>生活中亦是如此：如果每天跟同事说“我要跳槽了”，那你永远也别想走！</p><h2 id="要抓住时机，不要犹豫，哪怕粉身碎骨"><a href="#要抓住时机，不要犹豫，哪怕粉身碎骨" class="headerlink" title="要抓住时机，不要犹豫，哪怕粉身碎骨"></a>要抓住时机，不要犹豫，哪怕粉身碎骨</h2><p>在修屋顶的时候，狱警海利哥哥留下了三万五千美元财产，但是这笔钱要交税，安迪冒着被推下去的危险，当机立断的走上去，帮他解决了问题。如果当时徘徊不定，不会有后面的图书馆、帮典狱长洗黑钱的经历。</p><p>生活中亦是如此：万事不要犹豫不定，一定要当机立断！</p><h2 id="不论当前的处境多么的糟糕，也要充满希望，充满对自由的渴望"><a href="#不论当前的处境多么的糟糕，也要充满希望，充满对自由的渴望" class="headerlink" title="不论当前的处境多么的糟糕，也要充满希望，充满对自由的渴望"></a>不论当前的处境多么的糟糕，也要充满希望，充满对自由的渴望</h2><p>影片中，帮助预警海利躲过交税后，请大家喝啤酒；政府向图书馆发来拨款中有能使大家快乐的音碟，冒着很大的风险，让所有的人都能听到这美妙的音乐，这短暂的自由，即使被关一周的禁闭；在监狱开设图书馆，帮助人们取得初等教育认证等等</p><p>生活中亦是如此：不论处境多么糟糕，也不要丧失对希望、对自由的渴望</p><h2 id="不要被万恶的命运体制化"><a href="#不要被万恶的命运体制化" class="headerlink" title="不要被万恶的命运体制化"></a>不要被万恶的命运体制化</h2><p>影片中多次出现的一个词就是“体制化”，还被很多人嘲笑是瑞德编造出来的词语，很好的例子就是出狱后的老布，无法适应外面的生活，选择自杀。<br>生后中亦是如此：被苦难折磨的太久，我们都被“体制化”了，选择妥协，影片中的瑞德是一个现实生活中的表面的智者，选择去接受，一声不吭，但是真正的智者是安迪，永远都不会体制化，因为人心是关不住的。</p><p>生活中亦是如此：你自己都不想救自己，谁还能救你？</p><h2 id="学会善用那些利用你的人"><a href="#学会善用那些利用你的人" class="headerlink" title="学会善用那些利用你的人"></a>学会善用那些利用你的人</h2><p>安迪因为自己的长处被预警海利和典狱长赏识，也是用过认识了他们，他们帮他摆脱了，一直以来骚扰他的“三姐妹”，典狱长利用安迪洗黑钱，安迪最后将黑钱汇到自己的帐上，为自己的重生做了很好的“经济基础”<br>生活中亦是如此：人生来就是需要帮助的，在这世上，一个人是很难办成事情的。</p><h2 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a>坚持</h2><p>影片最想突出的我感觉是“坚持”，这个就不赘述了</p><p>生活中亦是如此：坚持</p><h2 id="反正人只有两个选择，忙着生或忙着死"><a href="#反正人只有两个选择，忙着生或忙着死" class="headerlink" title="反正人只有两个选择，忙着生或忙着死"></a>反正人只有两个选择，忙着生或忙着死</h2><h2 id="重生"><a href="#重生" class="headerlink" title="重生"></a>重生</h2><p>没错，重生！</p><h1 id="短暂的一生"><a href="#短暂的一生" class="headerlink" title="短暂的一生"></a>短暂的一生</h1><blockquote><ul><li>人这一辈子除了死，什么都不宜迟，不要再去等永远，再久的永远也是有限的，四月，趁阳光正好，趁微风不噪， 趁繁花还未开至荼蘼，好好的去爱，尽情的去做，<br>不要等到老了，才发觉，该说的话还没说，该做的事还没做，该见的人还没见，该牵的手，还没有牵…</li></ul></blockquote><blockquote><ul><li>如果一个人只是度过一天算一天，什么希望也没有，他的生命实际上也就停止了。</li></ul></blockquote><blockquote><ul><li>人生一世不就是为了化短暂的事物为永久的吗？要做到这一步，就须懂得如何珍视这短暂和永久。</li></ul></blockquote><blockquote><ul><li>一个人如果碌碌无为，只为自己渺小的生存而虚度一生，那么，即使他高寿活到一百岁，又有什么价值和意义呢？</li></ul></blockquote><blockquote><ul><li>人生就像一本书，傻瓜们走马看花似地随手翻阅它，聪明的人用心地阅读它。因为他知道这本书只能读一次。</li></ul></blockquote><blockquote><ul><li>做自己喜欢的事情吧！去接触新的事物吧！去做时间的朋友吧！</li><li>人生是一场旅程。我们经历了几次轮回，才换来这个旅程。而这个旅程很短，因此不妨大胆一些，不妨大胆一些去爱一个人，去攀一座山，去追一个梦……有很多事我都不明白。但我相信一件事。上天让我们来到这个世上，就是为了让我们创造奇迹。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 22 2019 22:26:31 GMT+0800 (China Standard Time) --&gt;&lt;blockquote&gt;&lt;p&gt;如题&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="short life" scheme="http://mmmmmm.me/categories/short-life/"/>
    
      <category term="short life" scheme="http://mmmmmm.me/categories/short-life/short-life/"/>
    
    
      <category term="人生" scheme="http://mmmmmm.me/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
</feed>
